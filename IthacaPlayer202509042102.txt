===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"
#include <sstream>

std::atomic<bool> Logger::loggingEnabled{true};

/**
 * @brief Konstruktor Logger.
 * Inicializuje singleton a p≈ôid√°v√° file logger.
 * üîß Zmƒõna: Vytvo≈ôen√≠ FileLogger pro z√°pis do souboru.
 */
Logger::Logger() {
    // üîß Zmƒõna: Inicializace file loggeru (um√≠stƒõn√≠ v default app log slo≈æce)
    fileLogger_ = juce::FileLogger::createDefaultAppLogger("IthacaPlayer", "IthacaPlayer.log", "Start IthacaPlayer logu", 0);
}

/**
 * @brief Vr√°t√≠ singleton instanci Logger.
 * @return Reference na instanci
 */
Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

/**
 * @brief Loguje zpr√°vu s ƒçasov√Ωm raz√≠tkem, komponentou a z√°va≈ænost√≠.
 * @param component Komponenta (nap≈ô. t≈ô√≠da/metoda)
 * @param severity Z√°va≈ænost (info, debug, error, warn)
 * @param message Zpr√°va
 * üîß Zmƒõna: P≈ôid√°n z√°pis do fileLogger, pokud existuje.
 */
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled.load(std::memory_order_relaxed))
        return;

    try {
        auto now = juce::Time::getCurrentTime();
        juce::String timestamp = now.formatted("%Y-%m-%d %H:%M:%S");
        juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

        pushToLogQueue(logEntry);
        scheduleGUIUpdate();

        // üîß Zmƒõna: Z√°pis do souboru, pokud fileLogger existuje
        if (fileLogger_ != nullptr) {
            fileLogger_->logMessage(logEntry);
        }
    } catch (...) {
        // Bezpeƒçn√Ω fallback p≈ôi chybƒõ
    }
}

void Logger::pushToLogQueue(const juce::String& logEntry)
{
    std::lock_guard<std::mutex> lock(logMutex_);

    uint8_t writeIndex = logQueue_.writeIndex.load();
    uint8_t currentCount = logQueue_.count.load();

    logQueue_.logs[writeIndex] = logEntry;
    logQueue_.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));

    if (currentCount < 256) {
        logQueue_.count.store(currentCount + 1);
    } else {
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + 1);
    }

    if (logQueue_.count.load() > MAX_LOG_ENTRIES) {
        uint8_t excess = logQueue_.count.load() - MAX_LOG_ENTRIES;
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + excess);
        logQueue_.count.store(MAX_LOG_ENTRIES);
    }
}

void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    std::lock_guard<std::mutex> lock(editorMutex_);
    editorPtr_ = ed;
}

void Logger::scheduleGUIUpdate()
{
    juce::MessageManager::callAsync([this]() {
        std::lock_guard<std::mutex> lock(editorMutex_);
        if (editorPtr_ != nullptr) {
            editorPtr_->updateLogDisplay();
        }
    });
}

juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}

juce::StringArray Logger::getCurrentLogs() const
{
    std::lock_guard<std::mutex> lock(logMutex_);

    juce::StringArray result;
    uint8_t currentCount = logQueue_.count.load();
    uint8_t readIndex = logQueue_.readIndex;

    for (uint8_t i = 0; i < currentCount; ++i) {
        uint8_t index = static_cast<uint8_t>(readIndex + i);
        result.add(logQueue_.logs[index]);
    }
    return result;
}

void Logger::clearLogs()
{
    std::lock_guard<std::mutex> lock(logMutex_);
    logQueue_.writeIndex.store(0);
    logQueue_.count.store(0);
    logQueue_.readIndex = 0;
    for (auto& log : logQueue_.logs) {
        log = juce::String();
    }
}

size_t Logger::getLogCount() const
{
    return logQueue_.count.load(std::memory_order_relaxed);
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>
#include <mutex>
#include <array>

#define MAX_LOG_ENTRIES 100

class AudioPluginAudioProcessorEditor;

class Logger
{
public:
    static Logger& getInstance();

    void log(const juce::String& component, const juce::String& severity, const juce::String& message);
    static std::atomic<bool> loggingEnabled;

    void setEditor(AudioPluginAudioProcessorEditor* ed);

    juce::StringArray getLogBuffer() const;
    void clearLogs();
    size_t getLogCount() const;

private:
    Logger();
    ~Logger() = default;

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    struct LogQueue {
        std::array<juce::String, 256> logs;
        std::atomic<uint8_t> writeIndex{0};
        std::atomic<uint8_t> count{0};
        uint8_t readIndex{0};
    };

    LogQueue logQueue_;

    mutable std::mutex logMutex_;
    mutable std::mutex editorMutex_;

    // üîß Oprava: U≈æ jen raw pointer (JUCE spravuje lifecycle editoru)
    AudioPluginAudioProcessorEditor* editorPtr_{nullptr};

    void pushToLogQueue(const juce::String& logEntry);
    juce::StringArray getCurrentLogs() const;
    void scheduleGUIUpdate();

    // üîß Zmƒõna: P≈ôid√°n file logger pro persistentn√≠ v√Ωstup do souboru
    juce::ScopedPointer<juce::FileLogger> fileLogger_;  // Automaticky uvolnƒõno p≈ôi destrukci
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"
#include <algorithm>
#include <cassert>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244)  // Varov√°n√≠ konverze pro MIDI hodnoty
#endif

/**
 * @brief Konstruktor MidiStateManager.
 * Inicializuje logger, resetuje queue a nastav√≠ v√Ωchoz√≠ hodnoty controller≈Ø podle MIDI standardu.
 */
MidiStateManager::MidiStateManager()
    : logger_(Logger::getInstance())
{
    logger_.log("MidiStateManager/constructor", "info", "=== INICIALIZACE MIDI STATE MANAGER ===");
    
    // Inicializace aktivn√≠ch not
    for (auto& note : activeNotes_) {
        note.store(false);  // V≈°echny noty neaktivn√≠
    }
    
    // Inicializace MIDI controller hodnot
    for (int channel = 0; channel < MIDI_CHANNELS; ++channel) {
        for (int controller = 0; controller < 128; ++controller) {
            controllerValues_[channel][controller] = 0;  // V√Ωchoz√≠ 0
        }
        
        // V√Ωchoz√≠ hodnoty pro standardn√≠ controllery
        controllerValues_[channel][7] = 100;   // Volume (v√Ωchoz√≠ vysok√°)
        controllerValues_[channel][10] = 64;   // Pan (st≈ôed)
        controllerValues_[channel][11] = 127;  // Expression (max)
        controllerValues_[channel][64] = 0;    // Sustain pedal (vypnut√Ω)
        controllerValues_[channel][91] = 0;    // Reverb (vypnut√Ω)
        controllerValues_[channel][93] = 0;    // Chorus (vypnut√Ω)
    }
    
    // Reset v≈°ech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    logger_.log("MidiStateManager/constructor", "info", "Inicializace dokonƒçena.");
}

/**
 * @brief Resetuje NoteQueue na v√Ωchoz√≠ stav.
 * Nastav√≠ indexy a poƒçet na 0, nemus√≠ ƒçistit array (p≈ôeps√°no p≈ôi pou≈æit√≠).
 */
void MidiStateManager::NoteQueue::reset() {
    writeIndex.store(0);
    count.store(0);
    readIndex = 0;
}

/**
 * @brief P≈ôid√° note-on do queue a aktualizuje stav aktivn√≠ noty a velocity.
 * @param channel MIDI kan√°l (0-15)
 * @param note MIDI nota (0-127)
 * @param velocity Velocity (0-127)
 */
void MidiStateManager::pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;  // Bezpeƒçnostn√≠ kontrola
    
    pushToQueue(noteOnQueues_[channel], note);
    activeNotes_[note].store(true);
    velocities_[channel][note] = velocity;
    
    logger_.log("MidiStateManager/pushNoteOn", "debug", "NoteOn kan√°l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief P≈ôid√° note-off do queue a deaktivuje notu.
 * @param channel MIDI kan√°l (0-15)
 * @param note MIDI nota (0-127)
 */
void MidiStateManager::pushNoteOff(uint8_t channel, uint8_t note) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;
    
    pushToQueue(noteOffQueues_[channel], note);
    activeNotes_[note].store(false);
    
    logger_.log("MidiStateManager/pushNoteOff", "debug", "NoteOff kan√°l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief Vyt√°hne note-on z queue pro dan√Ω kan√°l.
 * @param channel MIDI kan√°l
 * @return Nota (0-127) nebo 255 pokud pr√°zdn√° queue (üîß Zmƒõna: Pro odstranƒõn√≠ warningu C4244)
 */
uint8_t MidiStateManager::popNoteOn(uint8_t channel) {  // üîß Zmƒõna: Zmƒõnƒõno na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOnQueues_[channel]);
}

/**
 * @brief Vyt√°hne note-off z queue pro dan√Ω kan√°l.
 * @param channel MIDI kan√°l
 * @return Nota (0-127) nebo 255 pokud pr√°zdn√° queue (üîß Zmƒõna: Pro odstranƒõn√≠ warningu C4244)
 */
uint8_t MidiStateManager::popNoteOff(uint8_t channel) {  // üîß Zmƒõna: Zmƒõnƒõno na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOffQueues_[channel]);
}

/**
 * @brief Zkontroluje, zda je nota aktivn√≠.
 * @param channel MIDI kan√°l
 * @param note MIDI nota
 * @return True pokud aktivn√≠
 */
bool MidiStateManager::isNoteActive(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return false;
    return activeNotes_[note].load();
}

/**
 * @brief Vr√°t√≠ velocity aktivn√≠ noty.
 * @param channel MIDI kan√°l
 * @param note MIDI nota
 * @return Velocity (0-127)
 */
uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return 0;
    return velocities_[channel][note];
}

/**
 * @brief Nastav√≠ hodnotu MIDI controlleru.
 * @param channel MIDI kan√°l
 * @param controller ƒå√≠slo controlleru (0-127)
 * @param value Hodnota (0-127)
 */
void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value) {
    if (channel >= MIDI_CHANNELS || controller > 127) return;
    controllerValues_[channel][controller] = value;
}

/**
 * @brief Vr√°t√≠ hodnotu MIDI controlleru.
 * @param channel MIDI kan√°l
 * @param controller ƒå√≠slo controlleru
 * @return Hodnota (0-127)
 */
uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const {
    if (channel >= MIDI_CHANNELS || controller > 127) return 0;
    return controllerValues_[channel][controller];
}

/**
 * @brief P≈ôid√° prvek do circular queue s automatick√Ωm p≈ôeteƒçen√≠m.
 * @param queue Reference na queue
 * @param note Hodnota k p≈ôid√°n√≠
 * Zjednodu≈°eno: Pou≈æ√≠v√° modulo pro index, atomic operace pro count.
 */
void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() >= 256) {
        logger_.log("MidiStateManager/pushToQueue", "warn", "Queue pln√° - zpr√°va ztracena");
        return;  // Zachov√°no varov√°n√≠ p≈ôi pln√© queue
    }

    uint8_t index = queue.writeIndex.load();
    queue.notes[index] = note;
    queue.writeIndex.store((index + 1) % 256);  // Automatick√© p≈ôeteƒçen√≠ modulo 256
    queue.count.fetch_add(1);  // Atomic inkrement poƒçtu
}

/**
 * @brief Vyt√°hne prvek z circular queue.
 * @param queue Reference na queue
 * @return Hodnota nebo 255 p≈ôi pr√°zdn√© queue (üîß Zmƒõna: Pro konzistenci s uint8_t)
 */
uint8_t MidiStateManager::popFromQueue(NoteQueue& queue) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() == 0) {
        return 255;  // üîß Zmƒõna: 255 m√≠sto 0xff pro uint8_t (pr√°zdn√° queue)
    }

    uint8_t note = queue.notes[queue.readIndex];
    queue.readIndex = (queue.readIndex + 1) % 256;  // Modulo pro p≈ôeteƒçen√≠
    queue.count.fetch_sub(1);  // Atomic dekrement poƒçtu
    return note;
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <array>
#include <atomic>
#include <mutex>
#include "Logger.h"

// Konstanty pro MIDI rozsahy
constexpr uint8_t MIDI_NOTES = 128;  // Standardn√≠ poƒçet MIDI not (0-127)
constexpr uint8_t MIDI_CHANNELS = 16;  // Standardn√≠ poƒçet MIDI kan√°l≈Ø

/**
 * @class MidiStateManager
 * @brief Spravuje stav MIDI zpr√°v, vƒçetnƒõ aktivn√≠ch not, velocity, controller≈Ø a queue pro note-on/off.
 * 
 * Tato t≈ô√≠da je thread-safe d√≠ky mutex≈Øm a atomic promƒõnn√Ωm. Poskytuje metody pro push/pop MIDI ud√°lost√≠,
 * sledov√°n√≠ aktivn√≠ch not a controller hodnot. Inicializuje v√Ωchoz√≠ hodnoty controller≈Ø podle MIDI standardu.
 */
class MidiStateManager
{
public:
    MidiStateManager();

    // Metody pro note-on/off
    void pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity);  // P≈ôid√° note-on do queue a aktualizuje stav
    void pushNoteOff(uint8_t channel, uint8_t note);  // P≈ôid√° note-off do queue a aktualizuje stav
    uint8_t popNoteOn(uint8_t channel);  // üîß Zmƒõna: Zmƒõnƒõno na uint8_t, vrac√≠ 255 pokud pr√°zdn√° (pro odstranƒõn√≠ warningu C4244)
    uint8_t popNoteOff(uint8_t channel);  // üîß Zmƒõna: Zmƒõnƒõno na uint8_t, vrac√≠ 255 pokud pr√°zdn√°

    // Metody pro aktivn√≠ noty
    bool isNoteActive(uint8_t channel, uint8_t note) const;  // Zkontroluje, zda je nota aktivn√≠
    uint8_t getVelocity(uint8_t channel, uint8_t note) const;  // Vr√°t√≠ velocity aktivn√≠ noty

    // Metody pro MIDI controllery
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);  // Nastav√≠ hodnotu controlleru
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;  // Vr√°t√≠ hodnotu controlleru

private:
    Logger& logger_;  // Reference na logger pro logov√°n√≠ ud√°lost√≠

    // Struktura pro circular buffer queue (zachov√°na pro efektivitu a thread-safety)
    struct NoteQueue {
        std::array<uint8_t, 256> notes;  // Circular buffer o velikosti 256 (magick√© ƒç√≠slo zachov√°no)
        std::atomic<uint8_t> writeIndex{0};  // Atomic index pro z√°pis (thread-safe)
        std::atomic<uint8_t> count{0};  // Poƒçet prvk≈Ø v queue (atomic pro bezpeƒçn√Ω p≈ô√≠stup)
        uint8_t readIndex{0};  // Index pro ƒçten√≠ (chr√°nƒõn mutexem)
        mutable std::mutex mutex;  // Mutex pro synchronizaci p≈ô√≠stupu

        void reset();  // Resetuje queue na v√Ωchoz√≠ stav
    };

    // Queue pro note-on a note-off pro ka≈æd√Ω kan√°l
    std::array<NoteQueue, MIDI_CHANNELS> noteOnQueues_;
    std::array<NoteQueue, MIDI_CHANNELS> noteOffQueues_;

    // Pole pro aktivn√≠ noty a velocity
    std::array<std::atomic<bool>, MIDI_NOTES> activeNotes_;  // Atomic pro thread-safety
    std::array<std::array<uint8_t, MIDI_NOTES>, MIDI_CHANNELS> velocities_;  // Velocity pro ka≈æd√Ω kan√°l a notu
    std::array<std::array<uint8_t, 128>, MIDI_CHANNELS> controllerValues_;  // Controller hodnoty

    // Intern√≠ helper metody
    void pushToQueue(NoteQueue& queue, uint8_t note);  // P≈ôid√° do queue s automatick√Ωm p≈ôeteƒçen√≠m
    uint8_t popFromQueue(NoteQueue& queue);  // Vyt√°hne z queue, vrac√≠ 255 p≈ôi pr√°zdn√©
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    
    // Logov√°n√≠ vytv√°≈ôen√≠ editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytv√°≈ôeni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lep≈°√≠ ƒçitelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmavƒõ ≈°ed√© pozad√≠
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelen√Ω text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmav√Ω okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tlaƒç√≠tka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vyƒçi≈°tƒõn√≠ display p≈ôi vypnut√≠
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // P≈ôid√°n√≠ tlaƒç√≠tka pro vyƒçi≈°tƒõn√≠ log≈Ø
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastaven√≠ reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Roz≈°√≠≈ôen√° velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKONƒåENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logov√°n√≠ p≈ôed destrukc√≠
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstranƒõn√≠ reference p≈ôi destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    // Logov√°n√≠ pouze p≈ôi prvn√≠m vykreslen√≠
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozad√≠
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horn√≠ sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Oddƒõlovac√≠ ƒç√°ra
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    // Logov√°n√≠ zmƒõny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozlo≈æen√≠ komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zab√≠r√° vƒõt≈°inu m√≠sta
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tlaƒç√≠tka ve spodn√≠ ƒç√°sti
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    // Z√≠sk√°n√≠ bufferu z Loggeru p≈ôes getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestaven√≠ textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastaven√≠ textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledov√°n√≠ nov√Ωch ud√°lost√≠
    logDisplay->moveCaretToEnd();
    
    // Jednoduch√Ω scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logov√°n√≠ a ovl√°d√°n√≠
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

/**
 * @brief Konstruktor AudioPluginAudioProcessor.
 * Inicializuje komponenty a stav.
 */
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true))
    , logger_(Logger::getInstance())
    , voiceManager_(sampleLibrary_)  // VoiceManager vy≈æaduje SampleLibrary
{
    logger_.log("PluginProcessor/constructor", "info", "PluginProcessor inicializov√°n.");
}

/**
 * @brief Destruktor.
 */
AudioPluginAudioProcessor::~AudioPluginAudioProcessor() {}

/**
 * @brief P≈ôiprav√≠ na p≈ôehr√°v√°n√≠ (inicializuje syntetiz√©r).
 * @param sampleRate Sample rate
 * @param samplesPerBlock Blok velikost
 */
void AudioPluginAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    sampleRate_ = sampleRate;
    initializeSynth();
}

/**
 * @brief Uvoln√≠ zdroje (vyƒçist√≠ sample library).
 */
void AudioPluginAudioProcessor::releaseResources()
{
    sampleLibrary_.clear();
    synthState_.store(SynthState::Uninitialized);
}

/**
 * @brief Inicializuje syntetiz√©r (sample library atd.).
 * Pou≈æ√≠v√° try-catch pro chyby, s centr√°ln√≠m error handlingem.
 */
void AudioPluginAudioProcessor::initializeSynth()
{
    if (synthState_.load() != SynthState::Uninitialized) return;

    synthState_.store(SynthState::Initializing);
    try {
        sampleLibrary_.initialize(sampleRate_);
        synthState_.store(SynthState::Ready);
        logger_.log("PluginProcessor/initializeSynth", "info", "Syntetiz√©r p≈ôipraven.");
    } catch (const std::exception& e) {
        handleSynthError("Inicializace selhala: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    }
}

/**
 * @brief Centr√°ln√≠ handling chyb (loguje, m≈Ø≈æe p≈ôidat recovery).
 * @param errorMessage Zpr√°va
 */
void AudioPluginAudioProcessor::handleSynthError(const juce::String& errorMessage)
{
    logger_.log("PluginProcessor/handleSynthError", "error", errorMessage);
    // Zde m≈Ø≈æe b√Ωt p≈ôid√°no recovery (nap≈ô. reset), ale bez nov√© funkcionality
}

/**
 * @brief Vr√°t√≠ popis stavu.
 * @return String
 */
juce::String AudioPluginAudioProcessor::getStateDescription() const
{
    switch (synthState_.load()) {
        case SynthState::Uninitialized: return "Neinicializov√°no";
        case SynthState::Initializing: return "Inicializace";
        case SynthState::Ready: return "P≈ôipraveno";
        case SynthState::Error: return "Chyba";
        default: return "Nezn√°m√Ω stav";
    }
}

/**
 * @brief Zpracuje audio blok (MIDI + audio generace).
 * @param buffer Audio buffer
 * @param midiMessages MIDI buffer
 * Pou≈æ√≠v√° centr√°ln√≠ error handling p≈ôi ne-ready stavu.
 */
void AudioPluginAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    auto currentState = synthState_.load();
    if (currentState != SynthState::Ready) {
        buffer.clear();
        handleSynthError("Audio block p≈ôeskoƒçen - stav: " + getStateDescription());
        return;
    }

    // Zpracov√°n√≠ MIDI zpr√°v
    for (const auto metadata : midiMessages) {
        auto msg = metadata.getMessage();
        if (msg.isNoteOn()) {
            midiState_.pushNoteOn(msg.getChannel() - 1, msg.getNoteNumber(), msg.getVelocity());
        } else if (msg.isNoteOff()) {
            midiState_.pushNoteOff(msg.getChannel() - 1, msg.getNoteNumber());
        } else if (msg.isController()) {
            midiState_.setControllerValue(msg.getChannel() - 1, msg.getControllerNumber(), msg.getControllerValue());
        }
    }

    // Zpracov√°n√≠ MIDI ud√°lost√≠ a generace audio
    voiceManager_.processMidiEvents(midiState_);
    buffer.clear();
    float* channelData = buffer.getWritePointer(0);
    voiceManager_.generateAudio(channelData, buffer.getNumSamples());

    // Mono -> Stereo (kop√≠rov√°n√≠ do druh√©ho kan√°lu)
    buffer.copyFrom(1, 0, 0, buffer.getNumSamples());  // Oprava: Druh√Ω parametr je offset, t≈ôet√≠ je source channel (0)
}

juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    return new AudioPluginAudioProcessorEditor(*this);
}

/**
 * @brief Exportovan√° funkce pro JUCE plugin (vy≈æadov√°na pro VST3 a dal≈°√≠ form√°ty).
 * Vrac√≠ novou instanci procesoru.
 * üîß Zmƒõna: P≈ôid√°no pro opravu linker erroru LNK2019.
 */
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioPluginAudioProcessor();
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "SampleLibrary.h"
#include "VoiceManager.h"
#include "MidiStateManager.h"
#include "Logger.h"

// Enum pro stavy syntetiz√©ru
enum class SynthState {
    Uninitialized,
    Initializing,
    Ready,
    Error
};

/**
 * @class AudioPluginAudioProcessor
 * @brief Hlavn√≠ audio procesor pluginu (JUCE-based).
 * 
 * Spravuje inicializaci, zpracov√°n√≠ audio/MIDI a stav syntetiz√©ru.
 * Novƒõ p≈ôid√°na centr√°ln√≠ metoda pro error handling.
 */
class AudioPluginAudioProcessor : public juce::AudioProcessor
{
public:
    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    // Dal≈°√≠ JUCE metody (standardn√≠)
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }
    const juce::String getName() const override { return JucePlugin_Name; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&) override {}
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

private:
    Logger& logger_;  // Reference na logger
    std::atomic<SynthState> synthState_{SynthState::Uninitialized};  // Stav syntetiz√©ru

    SampleLibrary sampleLibrary_;  // Knihovna vzork≈Ø
    VoiceManager voiceManager_;  // Manager hlas≈Ø
    MidiStateManager midiState_;  // Manager MIDI stavu

    double sampleRate_{44100.0};  // Aktu√°ln√≠ sample rate

    /**
     * @brief Inicializuje syntetiz√©r (vzorky, voices atd.).
     */
    void initializeSynth();

    /**
     * @brief Centr√°ln√≠ metoda pro handling chyb (loguje a recovery).
     * @param errorMessage Zpr√°va o chybƒõ
     */
    void handleSynthError(const juce::String& errorMessage);

    /**
     * @brief Vr√°t√≠ popis aktu√°ln√≠ho stavu syntetiz√©ru.
     * @return String popis
     */
    juce::String getStateDescription() const;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioPluginAudioProcessor)
};


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe


## Nastaven√≠ v√Ωvojov√©ho prost≈ôed√≠

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) proveƒète n√°sleduj√≠c√≠ kroky. P≈ôedpokl√°d√° se instalace Visual Studio Build Tools (s MSVC kompil√°torem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Po≈æadavky
- Visual Studio Build Tools (MSVC kompil√°tor).
- CMake nainstalovan√Ω a p≈ôid√°n do PATH (nap≈ô. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastaven√≠
1. **Instalace roz≈°√≠≈ôen√≠ ve VS Code**:
   - Otev≈ôete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a ladƒõn√≠) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otev≈ôen√≠ projektu**:
   - P≈ôejdƒõte na File > Open Folder a vyberte slo≈æku s CMakeLists.txt.
3. **V√Ωbƒõr kompil√°toru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napi≈°te "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle pot≈ôeby (nap≈ô. x64 pro modern√≠ syst√©my).
4. **Konfigurace projektu**:
   - V Command Palette napi≈°te "CMake: Configure". To vygeneruje build soubory (obvykle ve slo≈æce "build").
5. **Build projektu**:
   - V Command Palette napi≈°te "CMake: Build" nebo pou≈æijte Shift+Ctrl+B (nyn√≠ nab√≠dne CMake √∫lohy).
6. **Debugov√°n√≠ (volitelnƒõ)**:
   - Nastavte breakpointy a spus≈•te "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovan√Ω v JUCE frameworku, inspirovan√Ω hardwarov√Ωmi syntez√°tory s modul√°rn√≠ architekturou.

## Architektura Syst√©mu

### P≈ôehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
‚îú‚îÄ‚îÄ SampleLibrary (Pre-computed Audio Storage)
‚îú‚îÄ‚îÄ MidiStateManager (MIDI Event Processing)  
‚îú‚îÄ‚îÄ VoiceManager (Voice Allocation & Control)
‚îî‚îÄ‚îÄ Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**√öƒçel:** Spr√°va pre-computed audio sampel≈Ø pro jednotliv√© MIDI noty

**Kl√≠ƒçov√© vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not √ó 12 sekund √ó sample rate
- **Pre-computed sine waves:** Generov√°n√≠ p≈ôi inicializaci m√≠sto realtime synt√©zy
- **Memory management:** Per-nota allocation s bezpeƒçn√Ωm uvol≈àov√°n√≠m
- **Roz≈°i≈ôitelnost:** P≈ôipraveno pro naƒç√≠t√°n√≠ WAV soubor≈Ø

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementaƒçn√≠ detaily:**
- Ka≈æd√Ω sample m√° pevnou d√©lku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe p≈ô√≠stup k sample dat≈Øm

### 2. MidiStateManager
**√öƒçel:** Centr√°ln√≠ spr√°va MIDI stavu a ud√°lost√≠

**Inspirov√°no:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracov√°n√≠
- Queue-based event distribution
- State tracking pro aktivn√≠ noty a controllery

**Kl√≠ƒçov√© struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Oddƒõlen√© queues pro Note On/Off ud√°losti
- Per-channel event routing (16 MIDI kan√°l≈Ø)
- Pop/push pattern podobn√Ω hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**√öƒçel:** Polyphonic voice allocation a audio generov√°n√≠

**Inspirov√°no:** Hardware Performer class
- 16 polyphonic hlas≈Ø
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hled√° existuj√≠c√≠ hlas s touto notou
    // 2. Hled√° neaktivn√≠ hlas s nejvy≈°≈°√≠ queue pozic√≠  
    // 3. Krade aktivn√≠ hlas s nejvy≈°≈°√≠ queue pozic√≠
}
```

**Queue Management (mixleQueue):**
Algoritmus p≈ôevzat√Ω z HW implementace:
1. Vybran√Ω hlas ‚Üí queue pozice 0
2. Ostatn√≠ hlasy ‚Üí pozice++
3. Komprese queue pozic > p≈Øvodn√≠ pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se p≈ôehraje jednou)

### 4. Logger System
**√öƒçel:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logov√°n√≠ z audio vl√°kna
- Sliding window buffer (100 zpr√°v)
- Kategorizace: info/debug/warn
- GUI integration p≈ôes MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
‚îú‚îÄ‚îÄ Create SampleLibrary (dummy sample rate)
‚îú‚îÄ‚îÄ Create MidiStateManager  
‚îî‚îÄ‚îÄ Create VoiceManager (16 voices)

prepareToPlay:
‚îú‚îÄ‚îÄ Reinit SampleLibrary (correct sample rate)
‚îú‚îÄ‚îÄ Generate sine wave pro Middle C (nota 60)
‚îî‚îÄ‚îÄ Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celkov√° alokace:** ~292MB pro kompletn√≠ library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic p≈ôi destrukci

### Voice Memory
- **16 SynthVoice objekt≈Ø:** Minim√°ln√≠ memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporovan√© MIDI zpr√°vy:
- **Note On/Off:** Kompletn√≠ support vƒçetnƒõ Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 a≈æ +8191)
- **Control Change:** 128 controllers √ó 16 kan√°l≈Ø
- **Channel support:** 16 MIDI kan√°l≈Ø

### MIDI Routing:
- **Prototype:** Pouze kan√°l 0 aktivn√≠
- **Full version:** V≈°ech 16 kan√°l≈Ø p≈ôipraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
‚îú‚îÄ‚îÄ PluginProcessor.h/cpp
‚îú‚îÄ‚îÄ PluginEditor.h/cpp

Synth Engine:
‚îú‚îÄ‚îÄ SampleLibrary.h/cpp
‚îú‚îÄ‚îÄ MidiStateManager.h/cpp
‚îú‚îÄ‚îÄ VoiceManager.h/cpp

Utilities:
‚îî‚îÄ‚îÄ Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro v≈°ech 128 not
2. **WAV loading:** Implementace naƒç√≠t√°n√≠ extern√≠ch sampel≈Ø
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** V≈°e se loguje do GUI
- **MIDI monitoring:** Detailn√≠ MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms p≈ôi 480 samples/48kHz)
- **Polyphony:** 16 hlas≈Ø

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal d√≠ky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB p≈ôi full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - vƒõt≈°inou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - ≈æ√°dn√© allokace v audio vl√°knƒõ
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**D≈Øvod:** Konzistentn√≠ CPU usage, mo≈ænost komplexn√≠ch waveforms
**Trade-off:** Vysok√° pamƒõ≈• vs stabiln√≠ performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**D≈Øvod:** Zachov√°n√≠ hardware workflow, p≈ôedv√≠dateln√© chov√°n√≠
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centr√°ln√≠ state s queue distribution
**D≈Øvod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**D≈Øvod:** Complex debugging po≈æadavky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include <cmath>

SampleLibrary::SampleLibrary()
    : logger_(Logger::getInstance())
{
    // nic d√°l v konstruktoru - actual allocation happens in initialize()
}

/*
 * initialize
 *  - ulo≈æ√≠ sampleRate a vygeneruje v≈°echno (MIN_NOTE..MAX_NOTE)
 *  - pokud generov√°n√≠ nƒõjak√© noty sel≈æe, loguje a pokraƒçuje (nep≈ôeru≈°√≠ ostatn√≠)
 *  - OPRAVA: Odebr√°n lock mutexu, proto≈æe inicializace je single-threaded (z prepareToPlay),
 *    co≈æ zabra≈àuje deadlocku p≈ôi rekurzivn√≠m zamyk√°n√≠ v generateSampleForNote.
 */
void SampleLibrary::initialize(double sampleRate)
{
    if (sampleRate <= 0.0) {
        logger_.log("SampleLibrary/initialize", "error", "Invalid sampleRate: " + juce::String(sampleRate));
        throw std::invalid_argument("Invalid sampleRate");
    }

    sampleRate_ = sampleRate;
    clear();

    logger_.log("SampleLibrary/initialize", "info",
                "Inicializace sample library se sampleRate=" + juce::String(sampleRate_));

    int success = 0;
    int fail = 0;
    for (uint8_t n = MIN_NOTE; n <= MAX_NOTE; ++n) {
        if (generateSampleForNote(n)) ++success;
        else ++fail;
    }

    logger_.log("SampleLibrary/initialize", "info",
                "Generov√°n√≠ sampl≈Ø dokonƒçeno. Success: " + juce::String(success) +
                " Fail: " + juce::String(fail));
}


/*
 * clear - vyma≈æe intern√≠ data
 */
void SampleLibrary::clear()
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    for (auto& seg : sampleSegments_)
        seg.reset();

    logger_.log("SampleLibrary/clear", "debug", "SampleLibrary cleared");
}

/*
 * generateSampleForNote
 *  - vygeneruje sinusovku d√©lky SAMPLE_SECONDS pro danou notu
 *  - vr√°t√≠ true pokud uspƒõje
 */
bool SampleLibrary::generateSampleForNote(uint8_t note)
{
    // lok√°ln√≠ kalkulace bez dr≈æen√≠ locku po dobu generov√°n√≠ (alokaƒçnƒõ-intenzivn√≠)
    double freq = getFrequencyForNote(note);
    uint32_t sampleLength = static_cast<uint32_t>(sampleRate_ * SAMPLE_SECONDS);

    if (sampleLength < 1) {
        logger_.log("SampleLibrary/generateSampleForNote", "error",
                    "Invalid sample length for note " + juce::String((int)note));
        return false;
    }

    std::unique_ptr<float[]> tmpData;
    try {
        tmpData = std::make_unique<float[]>(sampleLength);
    } catch (const std::bad_alloc&) {
        logger_.log("SampleLibrary/generateSampleForNote", "error",
                    "Allocation failed for note " + juce::String((int)note));
        return false;
    }

    const double twoPi = 2.0 * juce::MathConstants<double>::pi;
    const double phaseInc = twoPi * freq / sampleRate_;

    for (uint32_t i = 0; i < sampleLength; ++i) {
        double phase = phaseInc * static_cast<double>(i);
        // explicit cast -> potlaƒç√≠ warning C4244
        tmpData[i] = SAMPLE_AMPLITUDE * static_cast<float>(std::sin(phase));
    }

    // commit: ulo≈æen√≠ do intern√≠ struktury pod lockem (atomic-ish)
    {
        std::lock_guard<std::mutex> lock(accessMutex_);
        SampleSegment& seg = sampleSegments_[note];
        seg.sampleData = std::move(tmpData);
        seg.lengthSamples = sampleLength;
        seg.midiNote = note;
        seg.isAllocated = true;
    }

    logger_.log("SampleLibrary/generateSampleForNote", "debug",
                "Vzorek vygenerov√°n pro notu " + juce::String((int)note) +
                " freq=" + juce::String(freq, 2) +
                " samples=" + juce::String(sampleLength));
    return true;
}

/*
 * getSampleData / getSampleLength / isNoteAvailable
 *  - vrac√≠ read-only data (chr√°nƒõn√© mutexem)
 */
const float* SampleLibrary::getSampleData(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated)
        return sampleSegments_[midiNote].sampleData.get();
    return nullptr;
}

uint32_t SampleLibrary::getSampleLength(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated)
        return sampleSegments_[midiNote].lengthSamples;
    return 0;
}

bool SampleLibrary::isNoteAvailable(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    return midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated;
}

double SampleLibrary::getFrequencyForNote(uint8_t midiNote) const
{
    // standardn√≠ formule A4=440Hz (MIDI 69)
    return 440.0 * std::pow(2.0, (static_cast<int>(midiNote) - 69) / 12.0);
}


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <memory>
#include <array>
#include "Logger.h"

/*
 * SampleSegment
 *   - vlastn√≠ jednoduch√© √∫lo≈æi≈°tƒõ pro float vzorek (unique_ptr)
 *   - lengthSamples = d√©lka v samplech
 */
struct SampleSegment
{
    std::unique_ptr<float[]> sampleData;
    uint32_t lengthSamples{0};
    uint8_t midiNote{0};
    bool isAllocated{false};

    void reset()
    {
        sampleData.reset();
        lengthSamples = 0;
        midiNote = 0;
        isAllocated = false;
    }
};

/*
 * SampleLibrary
 * - refaktorizovan√°, thread-safe (intern√≠ mutex pro mutace)
 * - initialize(sampleRate) p≈ôiprav√≠ (vygeneruje) v≈°echny vzorky v rozsahu MIN_NOTE..MAX_NOTE
 * - poskytuje read-only p≈ô√≠stup: getSampleData/getSampleLength/isNoteAvailable
 */
class SampleLibrary
{
public:
    SampleLibrary();
    ~SampleLibrary() = default;

    // Inicializace knihovny (nutn√© zavolat p≈ôed pou≈æit√≠m)
    // Vygeneruje v≈°echny vzorky v rozsahu MIN_NOTE..MAX_NOTE (12 sekund ka≈æd√Ω)
    void initialize(double sampleRate);

    // Vyƒçist√≠ v≈°echny vzorky (uvoln√≠ pamƒõ≈•)
    void clear();

    // Generuje a ulo≈æ√≠ vzorek pro konkr√©tn√≠ notu (pou≈æito internƒõ i externƒõ)
    // Vrac√≠ true pokud generace probƒõhla √∫spƒõ≈°nƒõ.
    bool generateSampleForNote(uint8_t note);

    // Read-only p≈ô√≠stup
    const float* getSampleData(uint8_t midiNote) const;
    uint32_t getSampleLength(uint8_t midiNote) const;
    bool isNoteAvailable(uint8_t midiNote) const;

    // Konstanty
    static constexpr uint8_t MIN_NOTE = 21;   // A0
    static constexpr uint8_t MAX_NOTE = 108;  // C8
    static constexpr double SAMPLE_SECONDS = 12.0; // d√©lka v sekund√°ch

private:
    // intern√≠ helper pro frekvenci
    double getFrequencyForNote(uint8_t midiNote) const;

    mutable std::mutex accessMutex_;                // chr√°n√≠ sampleSegments_
    std::array<SampleSegment, 128> sampleSegments_; // √∫lo≈æi≈°tƒõ pro v≈°echny MIDInoty
    double sampleRate_{44100.0};
    Logger& logger_;
    static constexpr float SAMPLE_AMPLITUDE = 0.25f; // bezpeƒçn√° amplitude
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"
#include "Logger.h"

/**
 * @brief Konstruktor SynthVoice.
 * Inicializuje logger a resetuje stav.
 */
SynthVoice::SynthVoice()
    : logger_(Logger::getInstance())
{
    reset();
}

/**
 * @brief Spust√≠ hlas s kontrolou dostupnosti vzorku.
 * @param midiNote MIDI nota
 * @param velocity Velocity
 * @param library SampleLibrary pro data
 */
void SynthVoice::start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library)
{
    reset();

    midiNote_ = midiNote;
    velocity_ = velocity;

    if (!library.isNoteAvailable(midiNote)) {
        logger_.log("SynthVoice/start", "error", "Po≈æadovan√° nota nen√≠ dostupn√°: " + juce::String((int)midiNote));
        isActive_ = false;
        return;
    }

    sampleData_ = library.getSampleData(midiNote);
    sampleLength_ = library.getSampleLength(midiNote);

    if (!sampleData_ || sampleLength_ == 0) {
        logger_.log("SynthVoice/start", "error", "Neplatn√Ω vzorek pro notu " + juce::String((int)midiNote));
        isActive_ = false;
        return;
    }

    position_ = 0;
    isActive_ = true;

    logger_.log("SynthVoice/start", "debug", "Spustƒõna nota " + juce::String((int)midiNote) +
                                             " d√©lka=" + juce::String(sampleLength_));
}

void SynthVoice::stop()
{
    isActive_ = false;  // Okam≈æit√© zastaven√≠ (m≈Ø≈æe b√Ωt roz≈°√≠≈ôeno o release f√°zi)
}

void SynthVoice::reset()
{
    midiNote_ = 0;
    velocity_ = 0;
    isActive_ = false;
    sampleData_ = nullptr;
    sampleLength_ = 0;
    position_ = 0;
    queue_ = 0;  // Reset queue na dno
}

/**
 * @brief Renderuje audio s gainem podle velocity.
 * @param outputBuffer Buffer pro p≈ôiƒçten√≠
 * @param numSamples Poƒçet sampl≈Ø
 */
void SynthVoice::render(float* outputBuffer, int numSamples)
{
    if (!isActive_ || sampleData_ == nullptr || sampleLength_ == 0)
        return;

    const float gain = static_cast<float>(velocity_) / 127.0f;  // Line√°rn√≠ gain z velocity

    for (int i = 0; i < numSamples; ++i) {
        if (position_ >= sampleLength_) {
            stop();  // Dohr√°no -> deaktivace
            break;
        }
        outputBuffer[i] += sampleData_[position_] * gain;
        ++position_;
    }
}

// ======================== VoiceManager =========================

/**
 * @brief Konstruktor VoiceManager.
 * Vytvo≈ô√≠ voices s v√Ωchoz√≠ queue=0.
 * @param library SampleLibrary
 * @param numVoices Poƒçet hlas≈Ø
 */
VoiceManager::VoiceManager(const SampleLibrary& library, int numVoices)
    : logger_(Logger::getInstance()), sampleLibrary_(library)
{
    voices_.reserve(numVoices);
    for (int i = 0; i < numVoices; ++i) {
        voices_.emplace_back(std::make_unique<SynthVoice>());
        voices_.back()->setQueue(0);  // V√Ωchoz√≠ queue na 0 (dno stacku)
    }

    logger_.log("VoiceManager/constructor", "info", "VoiceManager vytvo≈ôen s " + juce::String(numVoices) + " hlasy");
}

/**
 * @brief Zpracuje MIDI ud√°losti (note-on/off) z queue.
 * @param midiState MidiStateManager
 * üîß Zmƒõna: Upraveno pro uint8_t z popNoteOn/popNoteOff, kontrola if (raw == 255)
 */
void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // Zpracov√°n√≠ NOTE ON
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOn(ch);  // üîß Zmƒõna: uint8_t m√≠sto int
            if (raw == 255) break;  // üîß Zmƒõna: 255 m√≠sto 0xff
            uint8_t note = raw;  // Bez cast, proto≈æe u≈æ uint8_t
            uint8_t vel = midiState.getVelocity(ch, note);
            startVoice(note, vel);
        }
    }

    // Zpracov√°n√≠ NOTE OFF
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOff(ch);  // üîß Zmƒõna: uint8_t m√≠sto int
            if (raw == 255) break;  // üîß Zmƒõna: 255 m√≠sto 0xff
            uint8_t note = raw;  // Bez cast
            stopVoice(note);
        }
    }
}

/**
 * @brief Generuje audio mixem hlas≈Ø.
 * @param buffer Audio buffer
 * @param numSamples Poƒçet sampl≈Ø
 */
void VoiceManager::generateAudio(float* buffer, int numSamples)
{
    if (buffer == nullptr || numSamples <= 0) return;

    // Mix v≈°ech aktivn√≠ch hlas≈Ø
    for (auto& v : voices_) {
        if (v->isActive()) v->render(buffer, numSamples);
    }
}

void VoiceManager::refresh()
{
    // M≈Ø≈æe b√Ωt roz≈°√≠≈ôeno o statistiky / voice stealing atd. (aktu√°lnƒõ pr√°zdn√©)
}

/**
 * @brief Spust√≠ hlas s lep≈°√≠m voice stealingem (inspirov√°no HW syntetiz√©rem).
 * Nejprve hled√° existuj√≠c√≠, pak volnou s max queue, pak ukradne.
 * @param midiNote Nota
 * @param velocity Velocity
 */
void VoiceManager::startVoice(uint8_t midiNote, uint8_t velocity)
{
    // Nejprve hledej existuj√≠c√≠ voice pro tuto notu
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->start(midiNote, velocity, sampleLibrary_);
            mixleQueue(v->getQueue());  // P≈ôeuspo≈ô√°dej queue
            v->setQueue(static_cast<uint8_t>(voices_.size() - 1));  // Nastav na top
            return;
        }
    }

    // Hledej volnou voice s nejvy≈°≈°√≠m queue (nejstar≈°√≠ na top)
    SynthVoice* candidate = nullptr;
    uint8_t maxQueue = 0;
    for (auto& v : voices_) {
        if (!v->isActive() && v->getQueue() >= maxQueue) {
            candidate = v.get();
            maxQueue = v->getQueue();
        }
    }

    // Pokud nen√≠ voln√°, ukradni s nejvy≈°≈°√≠m queue
    if (!candidate) {
        for (auto& v : voices_) {
            if (v->getQueue() >= maxQueue) {
                candidate = v.get();
                maxQueue = v->getQueue();
            }
        }
        logger_.log("VoiceManager/startVoice", "warn", "Voice stealing: ukraden voice pro notu " + juce::String((int)midiNote));
    }

    if (candidate) {
        mixleQueue(candidate->getQueue());  // P≈ôeuspo≈ô√°dej
        candidate->start(midiNote, velocity, sampleLibrary_);
        candidate->setQueue(static_cast<uint8_t>(voices_.size() - 1));  // Nastav na top
    }
}

/**
 * @brief Zastav√≠ hlas a p≈ôeuspo≈ô√°d√° queue.
 * @param midiNote Nota
 */
void VoiceManager::stopVoice(uint8_t midiNote)
{
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->stop();
            mixleQueue(v->getQueue());  // P≈ôeuspo≈ô√°dej po uvolnƒõn√≠
            v->setQueue(0);  // Reset na dno
            return;
        }
    }
}

/**
 * @brief P≈ôeuspo≈ô√°d√° queue: Posune vybranou na dno, ostatn√≠ posune nahoru/dol≈Ø.
 * @param queueNumber ƒå√≠slo queue k mixlov√°n√≠
 */
void VoiceManager::mixleQueue(uint8_t queueNumber) {
    for (auto& v : voices_) {
        if (v->getQueue() == queueNumber) {
            v->setQueue(0);  // Posun na dno
        } else if (v->getQueue() > queueNumber) {
            v->setQueue(v->getQueue() - 1);  // Posun dol≈Ø
        } else {
            v->setQueue(v->getQueue() + 1);  // Posun nahoru
        }
    }
}


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <cstdint>
#include <memory>
#include <vector>
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "Logger.h"

/**
 * @class SynthVoice
 * @brief Jednoduch√Ω renderer pro jeden hlas (voice), dr≈æ√≠ data vzorku a pozici.
 * 
 * Renderuje audio z readonly dat SampleLibrary. Podporuje start/stop/reset a rendering do bufferu.
 * Novƒõ p≈ôid√°na queue pro voice stealing (priorita: vy≈°≈°√≠ = novƒõj≈°√≠).
 */
class SynthVoice
{
public:
    SynthVoice();

    /**
     * @brief Spust√≠ hlas s danou notou a velocity.
     * @param midiNote MIDI nota
     * @param velocity Velocity (0-127)
     * @param library Reference na SampleLibrary
     */
    void start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library);

    /**
     * @brief Zastav√≠ hlas (deaktivuje ho).
     */
    void stop();

    /**
     * @brief Resetuje hlas do v√Ωchoz√≠ho stavu.
     */
    void reset();

    /**
     * @brief Renderuje audio do bufferu (p≈ôiƒç√≠t√° k existuj√≠c√≠m dat≈Øm).
     * @param outputBuffer Ukazatel na buffer
     * @param numSamples Poƒçet sampl≈Ø k renderov√°n√≠
     */
    void render(float* outputBuffer, int numSamples);

    bool isActive() const { return isActive_; }  // Vr√°t√≠, zda je hlas aktivn√≠
    uint8_t getNote() const { return midiNote_; }  // Vr√°t√≠ aktu√°ln√≠ notu
    uint8_t getQueue() const { return queue_; }  // Vr√°t√≠ prioritu queue
    void setQueue(uint8_t queue) { queue_ = queue; }  // Nastav√≠ prioritu queue

private:
    Logger& logger_;  // Reference na logger

    uint8_t midiNote_{0};  // Aktu√°ln√≠ MIDI nota
    uint8_t velocity_{0};  // Velocity
    bool isActive_{false};  // Stav aktivity

    const float* sampleData_{nullptr};  // Ukazatel na data vzorku
    uint32_t sampleLength_{0};  // D√©lka vzorku
    uint32_t position_{0};  // Aktu√°ln√≠ pozice v vzorku

    uint8_t queue_{0};  // Prioritn√≠ queue pro stealing (0 = dno, vy≈°≈°√≠ = top)
};

/**
 * @class VoiceManager
 * @brief Spravuje kolekci hlas≈Ø (voices), zpracov√°v√° MIDI ud√°losti a generuje audio.
 * 
 * Vy≈æaduje SampleLibrary. Podporuje voice stealing inspirovan√Ω HW syntetiz√©rem (s queue prioritou).
 * Procesuje MIDI z MidiStateManager a mixuje audio z hlas≈Ø.
 */
class VoiceManager
{
public:
    /**
     * @brief Konstruktor s referenc√≠ na SampleLibrary.
     * @param library Reference na SampleLibrary
     * @param numVoices Poƒçet hlas≈Ø (v√Ωchoz√≠ 16)
     */
    VoiceManager(const SampleLibrary& library, int numVoices = 16);

    ~VoiceManager() = default;

    /**
     * @brief Zpracuje MIDI ud√°losti z MidiStateManager (note-on/off).
     * @param midiState Reference na MidiStateManager
     */
    void processMidiEvents(MidiStateManager& midiState);

    /**
     * @brief Generuje audio mixem v≈°ech aktivn√≠ch hlas≈Ø.
     * @param buffer Ukazatel na audio buffer
     * @param numSamples Poƒçet sampl≈Ø
     */
    void generateAudio(float* buffer, int numSamples);

    /**
     * @brief Housekeeping: M≈Ø≈æe b√Ωt roz≈°√≠≈ôeno (aktu√°lnƒõ pr√°zdn√©).
     */
    void refresh();

private:
    Logger& logger_;  // Reference na logger
    const SampleLibrary& sampleLibrary_;  // Povinn√° reference na vzorky
    std::vector<std::unique_ptr<SynthVoice>> voices_;  // Kolekce hlas≈Ø

    /**
     * @brief Spust√≠ hlas pro danou notu (s voice stealingem).
     * @param midiNote MIDI nota
     * @param velocity Velocity
     */
    void startVoice(uint8_t midiNote, uint8_t velocity);

    /**
     * @brief Zastav√≠ hlas pro danou notu.
     * @param midiNote MIDI nota
     */
    void stopVoice(uint8_t midiNote);

    /**
     * @brief P≈ôeuspo≈ô√°d√° queue priorit (posune vybranou na dno, ostatn√≠ posune).
     * @param queueNumber ƒå√≠slo queue k mixlov√°n√≠
     */
    void mixleQueue(uint8_t queueNumber);
};



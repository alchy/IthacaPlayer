===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"

// Inicializace statické proměnné
bool Logger::loggingEnabled = true;

/**
 * Získání instance singletonu.
 */
Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

/**
 * Metoda pro logování s thread-safety pro GUI aktualizace.
 */
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled) return;

    // Vytvoření timestampu
    juce::String timestamp = juce::Time::getCurrentTime().formatted("%Y-%m-%d %H:%M:%S");

    // Formátovaný log
    juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

    // Přidání do bufferu
    logBuffer.add(logEntry);

    // Omezení velikosti (sliding window)
    if (logBuffer.size() > MAX_LOG_ENTRIES)
    {
        logBuffer.removeRange(0, 1);
    }

    // Thread-safe aktualizace GUI
    auto currentEditor = editor.load();
    if (currentEditor != nullptr)
    {
        // Použití MessageManager pro bezpečnou aktualizaci GUI z libovolného vlákna
        juce::MessageManager::callAsync([this, currentEditor]() {
            // Dvojitá kontrola po async volání
            if (editor.load() == currentEditor && currentEditor != nullptr)
            {
                currentEditor->updateLogDisplay();
            }
        });
    }
}

/**
 * Thread-safe nastavení reference na editor.
 */
void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    editor.store(ed);
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>

// Definice maximálního počtu logovacích záznamů (sliding window)
#define MAX_LOG_ENTRIES 100

// Forward declaration pro AudioPluginAudioProcessorEditor
class AudioPluginAudioProcessorEditor;

/**
 * Třída Logger - Thread-safe Singleton pro logování událostí v pluginu.
 * 
 * Poskytuje metodu pro logování s timestampem, komponentou, severity a zprávou.
 * Ukládá logy do bufferu s omezenou velikostí (sliding window).
 * Logování lze globálně zapnout/vypnout.
 * Thread-safe aktualizace GUI pomocí MessageManager.
 */
class Logger
{
public:
    // Získání instance singletonu
    static Logger& getInstance();

    // Thread-safe metoda pro logování
    void log(const juce::String& component, const juce::String& severity, const juce::String& message);

    // Globální přepínač logování
    static bool loggingEnabled;

    // Thread-safe nastavení reference na editor
    void setEditor(AudioPluginAudioProcessorEditor* ed);

    // Getter pro přístup k bufferu logů (const reference pro bezpečný přístup)
    const juce::StringArray& getLogBuffer() const { return logBuffer; }

private:
    // Privátní konstruktor pro singleton
    Logger() = default;

    // Zabránění kopírování
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    // Buffer pro logy
    juce::StringArray logBuffer;

    // Reference na editor pro update GUI
    std::atomic<AudioPluginAudioProcessorEditor*> editor{nullptr};
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

MidiStateManager::MidiStateManager()
    : pitchWheel_(0)
    , logger_(Logger::getInstance())
{
    // Inicializace všech aktivních not
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        activeNotes_[i] = ActiveNote();
    }
    
    // Inicializace controller values (výchozí hodnoty podle MIDI standardu)
    for (int channel = 0; channel < 16; channel++) {
        for (int controller = 0; controller < 128; controller++) {
            controllerValues_[channel][controller] = 0;
        }
        // Výchozí hodnoty pro některé standardní controllery
        controllerValues_[channel][7] = 100;  // Volume - defaultně 100
        controllerValues_[channel][10] = 64;  // Pan - defaultně center
        controllerValues_[channel][64] = 0;   // Sustain pedal - defaultně off
    }
    
    logger_.log("MidiStateManager/constructor", "info", "MidiStateManager inicializovan");
    logger_.log("MidiStateManager/constructor", "info", "Max aktivnich not: " + juce::String(MAX_ACTIVE_NOTES));
}

void MidiStateManager::putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity)
{
    if (channel >= 16 || key >= 128) {
        logger_.log("MidiStateManager/putNoteOn", "warn", "Neplatny channel nebo key: ch=" + 
                    juce::String(channel) + " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOn", "info", "Note ON - Ch:" + juce::String(channel) + 
                " Key:" + juce::String(key) + " Vel:" + juce::String(velocity));
    
    // Najdi existující slot pro tuto notu nebo vytvoř nový
    int slot = findNoteSlot(channel, key);
    if (slot == -1) {
        slot = findFreeSlot();
    }
    
    if (slot != -1) {
        activeNotes_[slot].channel = channel;
        activeNotes_[slot].key = key;
        activeNotes_[slot].velocity = velocity;
        activeNotes_[slot].isActive = true;
        activeNotes_[slot].triggerTime = juce::Time::getMillisecondCounter();
        
        // Přidej do note-on queue
        pushToQueue(noteOnQueue_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOn", "warn", "Zadny volny slot pro novou notu");
    }
}

void MidiStateManager::putNoteOff(uint8_t channel, uint8_t key)
{
    if (channel >= 16 || key >= 128) {
        logger_.log("MidiStateManager/putNoteOff", "warn", "Neplatny channel nebo key: ch=" + 
                    juce::String(channel) + " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOff", "info", "Note OFF - Ch:" + juce::String(channel) + 
                " Key:" + juce::String(key));
    
    // Najdi slot s touto notou a označ ji jako neaktivní
    int slot = findNoteSlot(channel, key);
    if (slot != -1) {
        activeNotes_[slot].isActive = false;
        
        // Přidej do note-off queue
        pushToQueue(noteOffQueue_[channel], key);
    }
}

uint8_t MidiStateManager::popNoteOn(uint8_t channel)
{
    if (channel >= 16) {
        return 0xff;
    }
    
    return popFromQueue(noteOnQueue_[channel]);
}

uint8_t MidiStateManager::popNoteOff(uint8_t channel)
{
    if (channel >= 16) {
        return 0xff;
    }
    
    return popFromQueue(noteOffQueue_[channel]);
}

uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t key) const
{
    int slot = findNoteSlot(channel, key);
    if (slot != -1 && activeNotes_[slot].isActive) {
        return activeNotes_[slot].velocity;
    }
    
    return 0; // Defaultní velocity pokud nota není aktivní
}

void MidiStateManager::setPitchWheel(int16_t pitchWheelValue)
{
    pitchWheel_ = pitchWheelValue;
    logger_.log("MidiStateManager/setPitchWheel", "debug", "Pitch wheel: " + juce::String(pitchWheelValue));
}

void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
{
    if (channel >= 16 || controller >= 128) {
        logger_.log("MidiStateManager/setControllerValue", "warn", "Neplatny channel nebo controller: ch=" + 
                    juce::String(channel) + " cc=" + juce::String(controller));
        return;
    }
    
    controllerValues_[channel][controller] = value;
    
    // Logování pouze pro důležité controllery
    if (controller == 1 || controller == 7 || controller == 10 || controller == 64) {
        juce::String ccName = "CC" + juce::String(controller);
        if (controller == 1) ccName = "Modulation";
        else if (controller == 7) ccName = "Volume";
        else if (controller == 10) ccName = "Pan";
        else if (controller == 64) ccName = "Sustain";
        
        logger_.log("MidiStateManager/setControllerValue", "info", 
                    ccName + " Ch:" + juce::String(channel) + " Val:" + juce::String(value));
    }
}

uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const
{
    if (channel >= 16 || controller >= 128) {
        return 0;
    }
    
    return controllerValues_[channel][controller];
}

void MidiStateManager::processMidiBuffer(const juce::MidiBuffer& midiBuffer)
{
    for (const auto& midiMetadata : midiBuffer) {
        auto message = midiMetadata.getMessage();
        
        if (message.isNoteOn()) {
            // MIDI Note On s velocity 0 = Note Off
            if (message.getVelocity() == 0) {
                putNoteOff(message.getChannel() - 1, message.getNoteNumber());
            } else {
                putNoteOn(message.getChannel() - 1, message.getNoteNumber(), message.getVelocity());
            }
        }
        else if (message.isNoteOff()) {
            putNoteOff(message.getChannel() - 1, message.getNoteNumber());
        }
        else if (message.isPitchWheel()) {
            // Převod z JUCE formátu na signed int16 (-8192 až +8191)
            int pitchWheelValue = message.getPitchWheelValue() - 8192;
            setPitchWheel(pitchWheelValue);
        }
        else if (message.isController()) {
            setControllerValue(message.getChannel() - 1, message.getControllerNumber(), message.getControllerValue());
        }
    }
}

void MidiStateManager::logActiveNotes() const
{
    int activeCount = 0;
    juce::String noteList;
    
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].isActive) {
            activeCount++;
            if (noteList.isNotEmpty()) noteList += ", ";
            noteList += juce::String(activeNotes_[i].key);
        }
    }
    
    logger_.log("MidiStateManager/logActiveNotes", "debug", 
                "Aktivnich not: " + juce::String(activeCount) + " [" + noteList + "]");
}

int MidiStateManager::getActiveNoteCount() const
{
    int count = 0;
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].isActive) {
            count++;
        }
    }
    return count;
}

int MidiStateManager::findNoteSlot(uint8_t channel, uint8_t key) const
{
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].channel == channel && activeNotes_[i].key == key) {
            return i;
        }
    }
    return -1; // Nenalezen
}

int MidiStateManager::findFreeSlot() const
{
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (!activeNotes_[i].isActive) {
            return i;
        }
    }
    return -1; // Žádný volný slot
}

void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note)
{
    if (queue.count < 128) {
        queue.notes[queue.writeIndex] = note;
        queue.writeIndex = (queue.writeIndex + 1) % 128;
        queue.count++;
    }
}

uint8_t MidiStateManager::popFromQueue(NoteQueue& queue)
{
    if (queue.count > 0) {
        uint8_t note = queue.notes[queue.readIndex];
        queue.readIndex = (queue.readIndex + 1) % 128;
        queue.count--;
        return note;
    }
    return 0xff; // Queue je prázdná
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "Logger.h"

/**
 * ActiveNote - reprezentuje aktivní MIDI notu
 * Inspirováno vaší Note strukturou v MidiParser
 */
struct ActiveNote {
    uint8_t key;           // MIDI nota (0-127)
    uint8_t velocity;      // Velocity (0-127)
    uint8_t channel;       // MIDI channel (0-15)
    bool isActive;         // Flag pro aktivní stav
    uint32_t triggerTime;  // Timestamp spuštění (pro voice stealing)
    
    ActiveNote() : key(0), velocity(0), channel(0), isActive(false), triggerTime(0) {}
};

/**
 * MidiStateManager - centrální správa MIDI stavu
 * Inspirováno vaší ActiveKeys třídou s podobným rozhraním
 * Kombinuje funkčnost vašeho MidiParser + ActiveKeys
 */
class MidiStateManager 
{
public:
    MidiStateManager();
    
    // Metody inspirované vaším ActiveKeys interface
    void putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity);
    void putNoteOff(uint8_t channel, uint8_t key);
    
    // Pop methods podobné vašemu pop_map_note_on/off pattern
    uint8_t popNoteOn(uint8_t channel);   // Vrací key nebo 0xff pokud žádný není
    uint8_t popNoteOff(uint8_t channel);  // Vrací key nebo 0xff pokud žádný není
    
    // Velocity lookup podobné vašemu get_map_velocity
    uint8_t getVelocity(uint8_t channel, uint8_t key) const;
    
    // Pitch wheel handling (podobné vašemu pitchwheel management)
    void setPitchWheel(int16_t pitchWheelValue);
    int16_t getPitchWheel() const { return pitchWheel_; }
    
    // Control Change handling (inspirováno vaší ControlChange strukturou)
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;
    
    // Debug metody
    void logActiveNotes() const;
    int getActiveNoteCount() const;
    
    // Processing MIDI buffer (hlavní vstupní bod pro MIDI data)
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer);
    
private:
    // Internal note management (podobné vašemu circular buffer přístupu)
    void updateNoteQueues();
    int findNoteSlot(uint8_t channel, uint8_t key) const;
    int findFreeSlot() const;
    
    // Member variables podobné vašim buffer strukturám
    static const int MAX_ACTIVE_NOTES = 128;
    ActiveNote activeNotes_[MAX_ACTIVE_NOTES];
    
    // Pitch wheel state (podobné vaší note.pitchwheel struktuře)
    int16_t pitchWheel_;
    
    // Control change state (podobné vaší cc struktur)
    uint8_t controllerValues_[16][128];  // [channel][controller]
    
    // Queue management pro note on/off events (inspirováno vaším buffer pattern)
    struct NoteQueue {
        uint8_t notes[128];
        int readIndex;
        int writeIndex;
        int count;
        
        NoteQueue() : readIndex(0), writeIndex(0), count(0) {
            for (int i = 0; i < 128; i++) notes[i] = 0xff;
        }
    };
    
    NoteQueue noteOnQueue_[16];   // Queue pro každý MIDI channel
    NoteQueue noteOffQueue_[16];  // Oddělené queues pro on/off events
    
    // Logger instance
    Logger& logger_;
    
    // Internal helper methods
    void pushToQueue(NoteQueue& queue, uint8_t note);
    uint8_t popFromQueue(NoteQueue& queue);
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    
    // Logování vytváření editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytvářeni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lepší čitelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmavě šedé pozadí
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelený text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmavý okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tlačítka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vyčištění display při vypnutí
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // Přidání tlačítka pro vyčištění logů
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastavení reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Rozšířená velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKONČENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logování před destrukcí
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstranění reference při destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    // Logování pouze při prvním vykreslení
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozadí
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horní sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Oddělovací čára
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    // Logování změny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozložení komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zabírá většinu místa
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tlačítka ve spodní části
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    // Získání bufferu z Loggeru přes getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestavení textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastavení textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledování nových událostí
    logDisplay->moveCaretToEnd();
    
    // Jednoduchý scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logování a ovládání
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       ), synthInitialized_(false)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== ITHACA PLAYER SPUSTEN ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Inicializace procesoru");
    
    // Základní info o pluginu (podobné vašemu printf výpisu v main)
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Plugin nazev: " + getName());
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Je synthesizer: " + juce::String(JucePlugin_IsSynth ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Prijima MIDI: " + juce::String(acceptsMidi() ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Produkuje MIDI: " + juce::String(producesMidi() ? "ANO" : "NE"));
    
    // Inicializace synth komponent (podobné vašemu main() - vytvoření objektů)
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== VYTVARENI SYNTH KOMPONENT ===");
    
    // Zatím používáme dummy sample rate - bude aktualizován v prepareToPlay (podobné vaší setupMIDI logice)
    sampleLibrary_ = std::make_unique<SampleLibrary>(44100.0);
    midiStateManager_ = std::make_unique<MidiStateManager>();
    voiceManager_ = std::make_unique<VoiceManager>(16); // 16 hlasů jako ve vaší voice_[16]
    
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Sample Library vytvoren");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "MIDI State Manager vytvoren");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Voice Manager vytvoren s " + juce::String(voiceManager_->getVoiceCount()) + " hlasy");
    
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== KONSTRUKTOR DOKONCEN ===");
}

AudioPluginAudioProcessor::~AudioPluginAudioProcessor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== ITHACA PLAYER SE UKONCUJE ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Zahajeni destrukce procesoru");
    
    // Nejprve odstraníme referenci na editor v Loggeru (bezpečnost)
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Logger reference odstranena");
    
    // Uvolnění synth komponent (v opačném pořadí než byly vytvořeny)
    voiceManager_.reset();
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Voice Manager uvolnen");
    
    midiStateManager_.reset();
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "MIDI State Manager uvolnen");
    
    sampleLibrary_.reset();
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Sample Library uvolnena");
    
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== DESTRUKCE DOKONCENA ===");
}

//==============================================================================
const juce::String AudioPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool AudioPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

double AudioPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int AudioPluginAudioProcessor::getNumPrograms()
{
    return 1;
}

int AudioPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void AudioPluginAudioProcessor::setCurrentProgram (int index)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setCurrentProgram", "info", "Zmena programu na index: " + juce::String(index));
    juce::ignoreUnused (index);
}

const juce::String AudioPluginAudioProcessor::getProgramName (int index)
{
    juce::ignoreUnused (index);
    return {};
}

void AudioPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/changeProgramName", "info", "Zmena nazvu programu [" + juce::String(index) + "]: " + newName);
    juce::ignoreUnused (index, newName);
}

//==============================================================================
void AudioPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== PRIPRAVA AUDIO PROCESINGU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Sample rate: " + juce::String(sampleRate, 1) + " Hz");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Buffer size: " + juce::String(samplesPerBlock) + " samples");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vstupni kanaly: " + juce::String(getTotalNumInputChannels()));
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vystupni kanaly: " + juce::String(getTotalNumOutputChannels()));
    
    // Výpočet latence
    double latencyMs = (double)samplesPerBlock / sampleRate * 1000.0;
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Odhadovana latence: " + juce::String(latencyMs, 2) + " ms");
    
    // Inicializace synth pouze jednou nebo při změně sample rate (podobné vaší setupMIDI + lfo_ticker.attach logice)
    if (!synthInitialized_ || sampleLibrary_->getSampleRate() != sampleRate) {
        Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== INICIALIZACE SAMPLE LIBRARY ===");
        
        // Reinicializace s korektní sample rate (podobné vašemu scan_bus workflow)
        sampleLibrary_ = std::make_unique<SampleLibrary>(sampleRate);
        sampleLibrary_->initializeLibrary();
        
        // Generování prototypu pro střední C (podobné vašemu build_dumb_voices -> assign_dcos_to_voices workflow)
        float middleCFreq = 261.63f; // C4 frequency
        if (sampleLibrary_->generateSineWaveForNote(SAMPLE_NOTE_FOR_PROTOTYPE, middleCFreq)) {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", 
                "Sample pro MIDI notu " + juce::String(SAMPLE_NOTE_FOR_PROTOTYPE) + " (Middle C) vygenerovan");
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", 
                "Frekvence: " + juce::String(middleCFreq, 2) + " Hz");
        } else {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "warn", 
                "CHYBA: Nepodal se vygenerovat sample pro MIDI notu " + juce::String(SAMPLE_NOTE_FOR_PROTOTYPE));
        }
        
        synthInitialized_ = true;
        Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== SYNTH READY TO PLAY ===");
    }
    
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void AudioPluginAudioProcessor::releaseResources()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "=== UVOLNOVANI AUDIO ZDROJU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "Audio processing zastaven");
    
    // Reset synth state při ukončení audio processingu
    synthInitialized_ = false;
}

bool AudioPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    auto mainOutput = layouts.getMainOutputChannelSet();
    auto mainInput = layouts.getMainInputChannelSet();
    
    Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "debug", 
        "Kontrola layoutu - Input: " + mainInput.getDescription() + 
        ", Output: " + mainOutput.getDescription());
    
    if (mainOutput != juce::AudioChannelSet::mono() && mainOutput != juce::AudioChannelSet::stereo())
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Nepodporovany output layout: " + mainOutput.getDescription());
        return false;
    }

   #if ! JucePlugin_IsSynth
    if (mainOutput != mainInput)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Input a output layout se neshoduji");
        return false;
    }
   #endif

    return true;
  #endif
}

void AudioPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer,
                                              juce::MidiBuffer& midiMessages)
{
    // Počítadlo pro omezení logování (podobné vašemu printf omezení)
    static int processCount = 0;
    processCount++;
    
    // Logování prvních několika bloků pro debugging
    if (processCount <= 5) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Audio blok #" + juce::String(processCount) + " - samples: " + juce::String(buffer.getNumSamples()) + 
            ", kanaly: " + juce::String(buffer.getNumChannels()));
    } else if (processCount % 1000 == 0) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "debug", 
            "Zpracovano " + juce::String(processCount) + " audio bloku");
    }
    
    // Pokud synth není inicializován, vygeneruj tichý výstup
    if (!synthInitialized_) {
        buffer.clear();
        return;
    }
    
    juce::ScopedNoDenormals noDenormals;
    auto totalNumInputChannels  = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    // Vyčištění přebytečných výstupních kanálů
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // === HLAVNÍ SYNTH PROCESSING LOOP - inspirováno vaší main while(1) loop ===
    
    // 1. MIDI zpracování (podobné vašemu midiParser.Parse())
    if (!midiMessages.isEmpty()) {
        if (processCount <= 10) { // Log pouze prvních 10 bloků s MIDI
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", "=== ZPRACOVANI MIDI ZPRAV ===");
        }
        midiStateManager_->processMidiBuffer(midiMessages);
    }
    
    // 2. Voice management - zpracování MIDI událostí (podobné vašemu pop_map_note_on/off pattern)
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio generování (podobné vašemu performer.refresh())
    for (int channel = 0; channel < totalNumOutputChannels; ++channel) {
        auto* channelData = buffer.getWritePointer(channel);
        
        // Pro prototyp - generuj pouze do prvního kanálu, kopíruj do ostatních
        if (channel == 0) {
            // Vyčisti buffer
            buffer.clear(channel, 0, buffer.getNumSamples());
            
            // Generuj audio ze všech hlasů
            voiceManager_->generateAudio(channelData, buffer.getNumSamples(), *sampleLibrary_);
        } else {
            // Kopíruj z prvního kanálu (mono -> stereo pro prototyp)
            auto* sourceData = buffer.getReadPointer(0);
            for (int sample = 0; sample < buffer.getNumSamples(); ++sample) {
                channelData[sample] = sourceData[sample];
            }
        }
    }
    
    // 4. Refresh cycle (podobné vašemu performer.refresh())
    voiceManager_->refresh();
    
    // Periodické logování aktivních hlasů pro debugging
    if (processCount % 5000 == 0) {
        midiStateManager_->logActiveNotes();
    }
}

//==============================================================================
bool AudioPluginAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "=== VYTVARENI GUI EDITORU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "Inicializace uzivatelského rozhrani");
    return new AudioPluginAudioProcessorEditor (*this);
}

//==============================================================================
void AudioPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/getStateInformation", "info", "Ukladani stavu pluginu");
    juce::ignoreUnused (destData);
}

void AudioPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setStateInformation", "info", 
        "Nacitani stavu pluginu (velikost: " + juce::String(sizeInBytes) + " bytu)");
    juce::ignoreUnused (data, sizeInBytes);
}

//==============================================================================
// POVINNÁ factory funkce pro JUCE pluginy
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioPluginAudioProcessor();
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Logger.h"
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "VoiceManager.h"

//==============================================================================
class AudioPluginAudioProcessor final : public juce::AudioProcessor
{
public:
    //==============================================================================
    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    using AudioProcessor::processBlock;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

private:
    // Synth komponenty - inspirováno vaším global dco[16], chain[64] pattern
    std::unique_ptr<SampleLibrary> sampleLibrary_;
    std::unique_ptr<MidiStateManager> midiStateManager_;
    std::unique_ptr<VoiceManager> voiceManager_;
    
    // State management
    bool synthInitialized_;
    
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessor)
};


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe


## Nastavení vývojového prostředí

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) proveďte následující kroky. Předpokládá se instalace Visual Studio Build Tools (s MSVC kompilátorem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Požadavky
- Visual Studio Build Tools (MSVC kompilátor).
- CMake nainstalovaný a přidán do PATH (např. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastavení
1. **Instalace rozšíření ve VS Code**:
   - Otevřete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a ladění) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otevření projektu**:
   - Přejděte na File > Open Folder a vyberte složku s CMakeLists.txt.
3. **Výběr kompilátoru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napište "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle potřeby (např. x64 pro moderní systémy).
4. **Konfigurace projektu**:
   - V Command Palette napište "CMake: Configure". To vygeneruje build soubory (obvykle ve složce "build").
5. **Build projektu**:
   - V Command Palette napište "CMake: Build" nebo použijte Shift+Ctrl+B (nyní nabídne CMake úlohy).
6. **Debugování (volitelně)**:
   - Nastavte breakpointy a spusťte "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovaný v JUCE frameworku, inspirovaný hardwarovými syntezátory s modulární architekturou.

## Architektura Systému

### Přehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
├── SampleLibrary (Pre-computed Audio Storage)
├── MidiStateManager (MIDI Event Processing)  
├── VoiceManager (Voice Allocation & Control)
└── Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**Účel:** Správa pre-computed audio sampelů pro jednotlivé MIDI noty

**Klíčové vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not × 12 sekund × sample rate
- **Pre-computed sine waves:** Generování při inicializaci místo realtime syntézy
- **Memory management:** Per-nota allocation s bezpečným uvolňováním
- **Rozšiřitelnost:** Připraveno pro načítání WAV souborů

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementační detaily:**
- Každý sample má pevnou délku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe přístup k sample datům

### 2. MidiStateManager
**Účel:** Centrální správa MIDI stavu a událostí

**Inspirováno:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracování
- Queue-based event distribution
- State tracking pro aktivní noty a controllery

**Klíčové struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Oddělené queues pro Note On/Off události
- Per-channel event routing (16 MIDI kanálů)
- Pop/push pattern podobný hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**Účel:** Polyphonic voice allocation a audio generování

**Inspirováno:** Hardware Performer class
- 16 polyphonic hlasů
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hledá existující hlas s touto notou
    // 2. Hledá neaktivní hlas s nejvyšší queue pozicí  
    // 3. Krade aktivní hlas s nejvyšší queue pozicí
}
```

**Queue Management (mixleQueue):**
Algoritmus převzatý z HW implementace:
1. Vybraný hlas → queue pozice 0
2. Ostatní hlasy → pozice++
3. Komprese queue pozic > původní pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se přehraje jednou)

### 4. Logger System
**Účel:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logování z audio vlákna
- Sliding window buffer (100 zpráv)
- Kategorizace: info/debug/warn
- GUI integration přes MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
├── Create SampleLibrary (dummy sample rate)
├── Create MidiStateManager  
└── Create VoiceManager (16 voices)

prepareToPlay:
├── Reinit SampleLibrary (correct sample rate)
├── Generate sine wave pro Middle C (nota 60)
└── Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celková alokace:** ~292MB pro kompletní library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic při destrukci

### Voice Memory
- **16 SynthVoice objektů:** Minimální memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporované MIDI zprávy:
- **Note On/Off:** Kompletní support včetně Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 až +8191)
- **Control Change:** 128 controllers × 16 kanálů
- **Channel support:** 16 MIDI kanálů

### MIDI Routing:
- **Prototype:** Pouze kanál 0 aktivní
- **Full version:** Všech 16 kanálů připraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
├── PluginProcessor.h/cpp
├── PluginEditor.h/cpp

Synth Engine:
├── SampleLibrary.h/cpp
├── MidiStateManager.h/cpp
├── VoiceManager.h/cpp

Utilities:
└── Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro všech 128 not
2. **WAV loading:** Implementace načítání externích sampelů
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** Vše se loguje do GUI
- **MIDI monitoring:** Detailní MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms při 480 samples/48kHz)
- **Polyphony:** 16 hlasů

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal díky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB při full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - většinou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - žádné allokace v audio vlákně
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**Důvod:** Konzistentní CPU usage, možnost komplexních waveforms
**Trade-off:** Vysoká paměť vs stabilní performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**Důvod:** Zachování hardware workflow, předvídatelné chování
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centrální state s queue distribution
**Důvod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**Důvod:** Complex debugging požadavky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include <cmath>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

SampleLibrary::SampleLibrary(double sampleRate)
    : sampleRate_(sampleRate)
    , maxSampleLength_(0)
    , logger_(Logger::getInstance())
{
    calculateBufferSizes();
    
    // Inicializace všech segmentů
    for (int i = 0; i < MIDI_NOTE_COUNT; i++) {
        segments_[i] = SampleSegment();
        segments_[i].midiNote = i;
    }
    
    logger_.log("SampleLibrary/constructor", "info", "SampleLibrary inicializovana pro sample rate: " + juce::String(sampleRate, 1));
    logger_.log("SampleLibrary/constructor", "info", "Max sample length: " + juce::String(maxSampleLength_) + " samples");
}

SampleLibrary::~SampleLibrary()
{
    logger_.log("SampleLibrary/destructor", "info", "Uvolnovani Sample Library");
    
    // Uvolnění všech alokovaných segmentů
    for (int i = 0; i < MIDI_NOTE_COUNT; i++) {
        deallocateSegment(i);
    }
    
    logger_.log("SampleLibrary/destructor", "info", "Sample Library uvolnena");
}

void SampleLibrary::initializeLibrary()
{
    logger_.log("SampleLibrary/initializeLibrary", "info", "=== INICIALIZACE SAMPLE LIBRARY ===");
    logger_.log("SampleLibrary/initializeLibrary", "info", "Priprava pro " + juce::String(MIDI_NOTE_COUNT) + " MIDI not");
    logger_.log("SampleLibrary/initializeLibrary", "info", "Delka kazdeho sample: " + juce::String(MAX_SAMPLE_LENGTH_SECONDS) + " sekund");
    
    // Výpočet celkové paměti
    double totalMemoryMB = (maxSampleLength_ * MIDI_NOTE_COUNT * sizeof(float)) / (1024.0 * 1024.0);
    logger_.log("SampleLibrary/initializeLibrary", "info", "Potencialni pamet: " + juce::String(totalMemoryMB, 1) + " MB");
    
    logger_.log("SampleLibrary/initializeLibrary", "info", "Sample Library pripravena k pouziti");
}

bool SampleLibrary::generateSineWaveForNote(uint8_t midiNote, float frequency)
{
    if (midiNote >= MIDI_NOTE_COUNT) {
        logger_.log("SampleLibrary/generateSineWaveForNote", "warn", "MIDI nota mimo rozsah: " + juce::String(midiNote));
        return false;
    }
    
    logger_.log("SampleLibrary/generateSineWaveForNote", "info", "Generovani sine wave pro MIDI notu " + juce::String(midiNote) + 
                " (frekvence: " + juce::String(frequency, 2) + " Hz)");
    
    // Alokace paměti pro segment
    if (!allocateSegment(midiNote)) {
        logger_.log("SampleLibrary/generateSineWaveForNote", "warn", "Chyba pri alokaci pameti pro notu " + juce::String(midiNote));
        return false;
    }
    
    // Generování sine wave dat
    fillSineWaveData(segments_[midiNote].sampleData, segments_[midiNote].lengthSamples, frequency, sampleRate_);
    
    logger_.log("SampleLibrary/generateSineWaveForNote", "info", "Sample pro notu " + juce::String(midiNote) + " uspesne vygenerovan");
    logger_.log("SampleLibrary/generateSineWaveForNote", "info", "Delka: " + juce::String(segments_[midiNote].lengthSamples) + " samples");
    
    return true;
}

const float* SampleLibrary::getSampleData(uint8_t midiNote) const
{
    if (midiNote >= MIDI_NOTE_COUNT || !segments_[midiNote].isAllocated) {
        return nullptr;
    }
    
    return segments_[midiNote].sampleData;
}

uint32_t SampleLibrary::getSampleLength(uint8_t midiNote) const
{
    if (midiNote >= MIDI_NOTE_COUNT || !segments_[midiNote].isAllocated) {
        return 0;
    }
    
    return segments_[midiNote].lengthSamples;
}

bool SampleLibrary::isNoteAvailable(uint8_t midiNote) const
{
    if (midiNote >= MIDI_NOTE_COUNT) {
        return false;
    }
    
    return segments_[midiNote].isAllocated;
}

void SampleLibrary::calculateBufferSizes()
{
    maxSampleLength_ = static_cast<uint32_t>(MAX_SAMPLE_LENGTH_SECONDS * sampleRate_);
    
    logger_.log("SampleLibrary/calculateBufferSizes", "info", "Vypocitana max delka bufferu: " + juce::String(maxSampleLength_) + " samples");
}

bool SampleLibrary::allocateSegment(uint8_t midiNote)
{
    if (midiNote >= MIDI_NOTE_COUNT) {
        return false;
    }
    
    // Pokud už je alokován, nejdříve uvolni
    if (segments_[midiNote].isAllocated) {
        deallocateSegment(midiNote);
    }
    
    try {
        segments_[midiNote].sampleData = new float[maxSampleLength_];
        segments_[midiNote].lengthSamples = maxSampleLength_;
        segments_[midiNote].isAllocated = true;
        
        // Vyčištění bufferu
        for (uint32_t i = 0; i < maxSampleLength_; i++) {
            segments_[midiNote].sampleData[i] = 0.0f;
        }
        
        logger_.log("SampleLibrary/allocateSegment", "debug", "Segment pro notu " + juce::String(midiNote) + " alokovan");
        return true;
    }
    catch (const std::bad_alloc& e) {
        logger_.log("SampleLibrary/allocateSegment", "warn", "Chyba alokace pameti pro notu " + juce::String(midiNote));
        return false;
    }
}

void SampleLibrary::deallocateSegment(uint8_t midiNote)
{
    if (midiNote >= MIDI_NOTE_COUNT) {
        return;
    }
    
    if (segments_[midiNote].isAllocated && segments_[midiNote].sampleData != nullptr) {
        delete[] segments_[midiNote].sampleData;
        segments_[midiNote].sampleData = nullptr;
        segments_[midiNote].lengthSamples = 0;
        segments_[midiNote].isAllocated = false;
        
        logger_.log("SampleLibrary/deallocateSegment", "debug", "Segment pro notu " + juce::String(midiNote) + " uvolnen");
    }
}

void SampleLibrary::fillSineWaveData(float* buffer, uint32_t length, float frequency, double sampleRate)
{
    if (buffer == nullptr || length == 0) {
        return;
    }
    
    const float twoPi = 2.0f * 3.14159265359f;
    const float increment = twoPi * frequency / static_cast<float>(sampleRate);
    
    for (uint32_t i = 0; i < length; i++) {
        float phase = increment * static_cast<float>(i);
        buffer[i] = 0.3f * std::sin(phase); // 0.3f amplitude aby nebyl příliš hlasitý
    }
    
    logger_.log("SampleLibrary/fillSineWaveData", "debug", "Sine wave data vygenerovana: " + 
                juce::String(length) + " samples, frekvence " + juce::String(frequency, 2) + " Hz");
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <atomic>
#include "Logger.h"

// Konstanta inspirovaná vaším přístupem k DCO_PER_VOICE_DEFAULT
#define MAX_SAMPLE_LENGTH_SECONDS 12.0f
#define MIDI_NOTE_COUNT 128
#define SAMPLE_NOTE_FOR_PROTOTYPE 60  // Middle C pro prototyp

/**
 * SampleSegment - reprezentuje jeden pre-computed sample pro jednu MIDI notu
 * Inspirováno vaší DeviceDCO strukturou pro jednotlivé generátory
 */
struct SampleSegment {
    float* sampleData;           // Pointer na audio data (podobné vašim DCO buffer pointerům)
    uint32_t lengthSamples;      // Délka v samples
    uint8_t midiNote;           // MIDI nota (0-127)
    bool isAllocated;           // Flag pro alokaci (podobné vašim device type checks)
    
    SampleSegment() : sampleData(nullptr), lengthSamples(0), midiNote(0), isAllocated(false) {}
};

/**
 * SampleLibrary - centrální správce pre-computed samples
 * Inspirováno vaším Performer pattern - centrální orchestrace zdrojů
 */
class SampleLibrary 
{
public:
    SampleLibrary(double sampleRate);
    ~SampleLibrary();
    
    // Inicializace podobná vaší scan_bus() metodě
    void initializeLibrary();
    
    // Generování sine wave pro jednu notu (podobné vašemu build_dumb_voices)
    bool generateSineWaveForNote(uint8_t midiNote, float frequency);
    
    // Získání sample dat pro playback (podobné vašemu get/pop pattern)
    const float* getSampleData(uint8_t midiNote) const;
    uint32_t getSampleLength(uint8_t midiNote) const;
    bool isNoteAvailable(uint8_t midiNote) const;
    
    // Utility methods
    double getSampleRate() const { return sampleRate_; }
    uint32_t getMaxSampleLength() const { return maxSampleLength_; }
    
private:
    // Vypočet délky bufferu pro danou sample rate
    void calculateBufferSizes();
    
    // Alokace paměti (podobné vašemu memory management přístupu)
    bool allocateSegment(uint8_t midiNote);
    void deallocateSegment(uint8_t midiNote);
    
    // Generování sine wave dat
    void fillSineWaveData(float* buffer, uint32_t length, float frequency, double sampleRate);
    
    // Member variables podobné vašim global arrays dco[16], chain[64]
    SampleSegment segments_[MIDI_NOTE_COUNT];
    double sampleRate_;
    uint32_t maxSampleLength_;         // Maximální délka v samples pro 12s
    
    // Logger instance pro debugging (podobně jako v main kódu)
    Logger& logger_;
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

// SynthVoice implementace
SynthVoice::SynthVoice(int voiceNumber)
    : voiceNumber_(voiceNumber)
    , currentNote_(0)
    , velocity_(0)
    , isPlaying_(false)
    , queuePosition_(0)
    , samplePosition_(0)
    , pitchWheel_(0)
    , logger_(Logger::getInstance())
{
    logger_.log("SynthVoice/constructor", "debug", "Voice " + juce::String(voiceNumber_) + " vytvoren");
}

void SynthVoice::play(bool gate, uint8_t note)
{
    if (gate) {
        // Note ON
        currentNote_ = note;
        isPlaying_ = true;
        samplePosition_ = 0; // Reset sample position na začátek
        
        logger_.log("SynthVoice/play", "info", "Voice " + juce::String(voiceNumber_) + 
                    " Note ON: " + juce::String(note));
    } else {
        // Note OFF - podle vašeho kódu jen vypneme gate
        isPlaying_ = false;
        
        logger_.log("SynthVoice/play", "info", "Voice " + juce::String(voiceNumber_) + 
                    " Note OFF: " + juce::String(currentNote_));
    }
}

void SynthVoice::setVelocity(uint8_t velocity)
{
    velocity_ = velocity;
    logger_.log("SynthVoice/setVelocity", "debug", "Voice " + juce::String(voiceNumber_) + 
                " velocity: " + juce::String(velocity));
}

void SynthVoice::setPitchWheel(int16_t pitchWheel)
{
    pitchWheel_ = pitchWheel;
    // Logování pouze při změně
    static int16_t lastPitchWheel = 0;
    if (pitchWheel != lastPitchWheel) {
        logger_.log("SynthVoice/setPitchWheel", "debug", "Voice " + juce::String(voiceNumber_) + 
                    " pitch wheel: " + juce::String(pitchWheel));
        lastPitchWheel = pitchWheel;
    }
}

void SynthVoice::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    if (!isPlaying_ || outputBuffer == nullptr) {
        return;
    }
    
    // Pro prototyp používáme pouze notu 60 (middle C) ze sample library
    const float* sampleData = sampleLibrary.getSampleData(SAMPLE_NOTE_FOR_PROTOTYPE);
    uint32_t sampleLength = sampleLibrary.getSampleLength(SAMPLE_NOTE_FOR_PROTOTYPE);
    
    if (sampleData == nullptr || sampleLength == 0) {
        return;
    }
    
    // Generování audio samples
    for (int i = 0; i < numSamples; i++) {
        if (samplePosition_ < sampleLength) {
            // Velocity scaling (0-127 -> 0.0-1.0)
            float velocityScale = velocity_ / 127.0f;
            outputBuffer[i] += sampleData[samplePosition_] * velocityScale;
            samplePosition_++;
        } else {
            // Konec sample - vypni hlas (bez loop podle požadavku)
            isPlaying_ = false;
            break;
        }
    }
}

void SynthVoice::reset()
{
    isPlaying_ = false;
    currentNote_ = 0;
    velocity_ = 0;
    samplePosition_ = 0;
    pitchWheel_ = 0;
    
    logger_.log("SynthVoice/reset", "debug", "Voice " + juce::String(voiceNumber_) + " reset");
}

// VoiceManager implementace
VoiceManager::VoiceManager(int maxVoices)
    : voiceCount_(0)
    , globalPitchWheel_(0)
    , logger_(Logger::getInstance())
{
    // Omezení počtu hlasů
    int actualVoiceCount = juce::jmin(maxVoices, MAX_VOICES);
    
    // Vytvoření hlasů (podobné vašemu build_dumb_voices)
    for (int i = 0; i < actualVoiceCount; i++) {
        voices_[i] = new SynthVoice(i);
        voices_[i]->setQueue(i); // Inicializační queue pozice
    }
    
    setVoiceCount(actualVoiceCount);
    
    logger_.log("VoiceManager/constructor", "info", "VoiceManager vytvoren s " + juce::String(voiceCount_) + " hlasy");
}

VoiceManager::~VoiceManager()
{
    logger_.log("VoiceManager/destructor", "info", "Uvolnovani VoiceManager");
    
    for (int i = 0; i < voiceCount_; i++) {
        delete voices_[i];
        voices_[i] = nullptr;
    }
    
    logger_.log("VoiceManager/destructor", "info", "VoiceManager uvolnen");
}

void VoiceManager::play(bool gate, uint8_t note, uint8_t velocity)
{
    if (!gate) {
        // Note OFF - najdi všechny hlasy s touto notou a vypni je
        for (int voice = 0; voice < voiceCount_; voice++) {
            if (voices_[voice]->getNote() == note) {
                voices_[voice]->play(false, note);
            }
        }
    } else {
        // Note ON - najdi volný hlas nebo ukradni jeden
        int freeVoice = getFreeVoice(note);
        voices_[freeVoice]->play(true, note);
        voices_[freeVoice]->setVelocity(velocity); // Velocity se nastavuje pouze při note on
    }
}

void VoiceManager::setPitchWheel(int16_t pitchWheel)
{
    globalPitchWheel_ = pitchWheel;
    
    // Aplikuj na všechny hlasy
    for (int voice = 0; voice < voiceCount_; voice++) {
        voices_[voice]->setPitchWheel(pitchWheel);
    }
}

void VoiceManager::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    if (outputBuffer == nullptr || numSamples <= 0) {
        return;
    }
    
    // Vyčištění output bufferu
    for (int i = 0; i < numSamples; i++) {
        outputBuffer[i] = 0.0f;
    }
    
    // Mix všech aktivních hlasů
    for (int voice = 0; voice < voiceCount_; voice++) {
        if (voices_[voice]->getGate()) {
            voices_[voice]->generateAudio(outputBuffer, numSamples, sampleLibrary);
        }
    }
}

void VoiceManager::refresh()
{
    // Podobné vašemu performer.refresh() - zde můžeme implementovat dodatečnou logiku
    // Pro zatím neděláme nic speciálního
}

void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // Zpracuj všechny MIDI kanály (pro prototyp používáme kanál 0)
    uint8_t channel = 0;
    
    // Zpracuj note ON události
    uint8_t key;
    while ((key = midiState.popNoteOn(channel)) != 0xff) {
        uint8_t velocity = midiState.getVelocity(channel, key);
        play(true, key, velocity);
        
        logger_.log("VoiceManager/processMidiEvents", "info", "MIDI Note ON zpracovana: key=" + 
                    juce::String(key) + " vel=" + juce::String(velocity));
    }
    
    // Zpracuj note OFF události
    while ((key = midiState.popNoteOff(channel)) != 0xff) {
        play(false, key, 0);
        
        logger_.log("VoiceManager/processMidiEvents", "info", "MIDI Note OFF zpracovana: key=" + 
                    juce::String(key));
    }
    
    // Zpracuj pitch wheel
    int16_t pitchWheel = midiState.getPitchWheel();
    if (pitchWheel != globalPitchWheel_) {
        setPitchWheel(pitchWheel);
    }
}

// Implementace vašeho voice allocation algoritmu
int VoiceManager::getFreeVoice(uint8_t note)
{
    int voice, voiceCandidate = -1;
    
    // První průchod: hledej hlas který už hraje tuto notu nebo který přestal hrát a nebyl nahrazen
    for (voice = 0; voice < voiceCount_; voice++) {
        if (voices_[voice]->getNote() == note) {
            return voice; // Našel hlas s touto notou
        }
    }
    
    // Druhý průchod: najdi nepoužívaný hlas s nejvyšším queue číslem
    for (voice = 0; voice < voiceCount_; voice++) {
        if (!voices_[voice]->getGate()) { // Hlas není aktivní
            if (voiceCandidate == -1) {
                voiceCandidate = voice; // První kandidát
            } else {
                if (voices_[voice]->getQueue() > voices_[voiceCandidate]->getQueue()) {
                    voiceCandidate = voice; // Tento má vyšší queue pozici
                }
            }
        }
    }
    
    if (voiceCandidate != -1) {
        mixleQueue(voices_[voiceCandidate]->getQueue()); // Přeorganizuj queue
        return voiceCandidate;
    }
    
    // Třetí průchod: musíme ukradnout hlas - vyber ten s nejvyšším queue číslem
    for (voice = 0; voice < voiceCount_; voice++) {
        if (voices_[voice]->getQueue() == voiceCount_ - 1) { // Hlas na vrcholu stacku
            mixleQueue(voices_[voice]->getQueue());
            return voice;
        }
    }
    
    return 0; // Fallback - tohle by se nikdy nemělo stát
}

// Implementace vašeho mixle_queue algoritmu
void VoiceManager::mixleQueue(int queueNumber)
{
    // První průchod: najdi hlas s daným queue číslem a nastav ho na 0
    for (int alpha = 0; alpha < voiceCount_; alpha++) {
        if (voices_[alpha]->getQueue() == queueNumber) {
            voices_[alpha]->setQueue(0);
        } else {
            voices_[alpha]->setQueue(voices_[alpha]->getQueue() + 1);
        }
    }
    
    // Druhý průchod: komprese - snižit všechny queue pozice vyšší než queueNumber
    for (int alpha = 0; alpha < voiceCount_; alpha++) {
        if (voices_[alpha]->getQueue() > queueNumber) {
            voices_[alpha]->setQueue(voices_[alpha]->getQueue() - 1);
        }
    }
    
    logger_.log("VoiceManager/mixleQueue", "debug", "Queue reorganizovana pro pozici " + juce::String(queueNumber));
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include "MidiStateManager.h"
#include "SampleLibrary.h"
#include "Logger.h"

/**
 * SynthVoice - reprezentuje jeden hlas syntezátoru
 * Inspirováno vaší DeviceVoice třídou
 */
class SynthVoice 
{
public:
    SynthVoice(int voiceNumber);
    
    // Voice control methods (podobné vašemu DeviceVoice interface)
    void play(bool gate, uint8_t note);
    void setVelocity(uint8_t velocity);
    void setPitchWheel(int16_t pitchWheel);
    
    // Playback state (podobné vaším get/set metodám)
    uint8_t getNote() const { return currentNote_; }
    bool getGate() const { return isPlaying_; }
    uint8_t getQueue() const { return queuePosition_; }
    void setQueue(uint8_t position) { queuePosition_ = position; }
    
    // Audio generation - hlavní metoda pro generování audio
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Reset methods
    void reset();
    
private:
    int voiceNumber_;           // Číslo hlasu (podobné vaším voice indexům)
    uint8_t currentNote_;       // Aktuálně hraná nota
    uint8_t velocity_;          // Velocity noty
    bool isPlaying_;           // Gate stav (podobné vašemu gate flag)
    uint8_t queuePosition_;    // Pozice v queue pro voice stealing
    
    // Playback state pro sample library
    uint32_t samplePosition_;   // Aktuální pozice v sample
    int16_t pitchWheel_;       // Pitch wheel value
    
    Logger& logger_;
};

/**
 * VoiceManager - správce hlasů syntezátoru
 * Přímá inspirace vaší Performer třídou s podobnými metodami
 */
class VoiceManager 
{
public:
    VoiceManager(int maxVoices = 16);
    ~VoiceManager();
    
    // Hlavní metody inspirované vaším Performer interface
    void play(bool gate, uint8_t note, uint8_t velocity);
    void setPitchWheel(int16_t pitchWheel);
    
    // Audio generation - kombinuje všechny hlasy
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Voice management methods (podobné vašim Performer metodám)
    void refresh();  // Podobné vašemu refresh()
    int getVoiceCount() const { return voiceCount_; }
    
    // Integration s MidiStateManager
    void processMidiEvents(MidiStateManager& midiState);
    
private:
    // Voice allocation methods (přesně podle vaší logiky)
    int getFreeVoice(uint8_t note);  // Váš algoritmus
    void mixleQueue(int queueNumber); // Váš mixle_queue algoritmus
    
    // Member variables podobné vašim voice_ arrays
    static const int MAX_VOICES = 16;
    SynthVoice* voices_[MAX_VOICES];
    int voiceCount_;
    
    // Pitch wheel state pro všechny hlasy
    int16_t globalPitchWheel_;
    
    Logger& logger_;
    
    // Helper methods
    void setVoiceCount(int count) { voiceCount_ = count; }
};



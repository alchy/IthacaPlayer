===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        # Core system
        Logger.h
        Logger.cpp
        
        # Enhanced sample management with dynamic levels
        SampleLoader.h
        SampleLoader.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        
        # MIDI and voice management
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        
        # JUCE plugin interface
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
        juce::juce_audio_formats  # P콏id치no pro WAV loading
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"
#include <sstream>

std::atomic<bool> Logger::loggingEnabled{true};

/**
 * @brief Konstruktor Logger.
 * Inicializuje singleton a p콏id치v치 file logger.
 * Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer.
 */
Logger::Logger() {
    // Oprava: Inicializace file loggeru (um칤st캩n칤 v default app log slo쬮e)
    fileLogger_ = std::unique_ptr<juce::FileLogger>(
        juce::FileLogger::createDefaultAppLogger("IthacaPlayer", "IthacaPlayer.log", "Start IthacaPlayer logu", 0)
    );
    DBG("Logger initialized.");  // P콏idan칳 debug pro konzoli
}

/**
 * @brief Vr치t칤 singleton instanci Logger.
 * @return Reference na instanci
 */
Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

/**
 * @brief Loguje zpr치vu s 캜asov칳m raz칤tkem, komponentou a z치va쬹ost칤.
 * @param component Komponenta (nap콏. t콏칤da/metoda)
 * @param severity Z치va쬹ost (info, debug, error, warn)
 * @param message Zpr치va
 * Oprava: P콏id치n z치pis do fileLogger, pokud existuje.
 */
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled.load(std::memory_order_relaxed))
        return;

    try {
        auto now = juce::Time::getCurrentTime();
        juce::String timestamp = now.formatted("%Y-%m-%d %H:%M:%S");
        juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

        pushToLogQueue(logEntry);
        scheduleGUIUpdate();

        // Oprava: Z치pis do souboru, pokud fileLogger existuje
        if (fileLogger_ != nullptr) {
            fileLogger_->logMessage(logEntry);
        }
    } catch (...) {
        // Bezpe캜n칳 fallback p콏i chyb캩
        DBG("Logger error in log method.");  // P콏idan칳 debug pro chyby
    }
}

void Logger::pushToLogQueue(const juce::String& logEntry)
{
    std::lock_guard<std::mutex> lock(logMutex_);

    uint8_t writeIndex = logQueue_.writeIndex.load();
    uint8_t currentCount = logQueue_.count.load();

    logQueue_.logs[writeIndex] = logEntry;
    logQueue_.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));

    if (currentCount < 256) {
        logQueue_.count.store(currentCount + 1);
    } else {
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + 1);
    }

    if (logQueue_.count.load() > MAX_LOG_ENTRIES) {
        uint8_t excess = logQueue_.count.load() - MAX_LOG_ENTRIES;
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + excess);
        logQueue_.count.store(MAX_LOG_ENTRIES);
    }
}

void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    std::lock_guard<std::mutex> lock(editorMutex_);
    editorPtr_ = ed;
    DBG("Editor set in Logger.");  // P콏idan칳 debug pro nastaven칤 editoru
}

void Logger::scheduleGUIUpdate()
{
    juce::MessageManager::callAsync([this]() {
        std::lock_guard<std::mutex> lock(editorMutex_);
        if (editorPtr_ != nullptr) {
            editorPtr_->updateLogDisplay();
        }
    });
}

juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}

juce::StringArray Logger::getCurrentLogs() const
{
    std::lock_guard<std::mutex> lock(logMutex_);

    juce::StringArray result;
    uint8_t currentCount = logQueue_.count.load();
    uint8_t readIndex = logQueue_.readIndex;

    for (uint8_t i = 0; i < currentCount; ++i) {
        uint8_t index = static_cast<uint8_t>(readIndex + i);
        result.add(logQueue_.logs[index]);
    }
    return result;
}

void Logger::clearLogs()
{
    std::lock_guard<std::mutex> lock(logMutex_);
    logQueue_.writeIndex.store(0);
    logQueue_.count.store(0);
    logQueue_.readIndex = 0;
    for (auto& log : logQueue_.logs) {
        log = juce::String();
    }
    DBG("Logs cleared.");  // P콏idan칳 debug pro 캜i코t캩n칤 log콢
}

size_t Logger::getLogCount() const
{
    return logQueue_.count.load(std::memory_order_relaxed);
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>
#include <mutex>
#include <array>
#include <memory>

#define MAX_LOG_ENTRIES 100

class AudioPluginAudioProcessorEditor;

class Logger
{
public:
    static Logger& getInstance();

    void log(const juce::String& component, const juce::String& severity, const juce::String& message);
    static std::atomic<bool> loggingEnabled;

    void setEditor(AudioPluginAudioProcessorEditor* ed);

    juce::StringArray getLogBuffer() const;
    void clearLogs();
    size_t getLogCount() const;

private:
    Logger();
    ~Logger() = default;

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    struct LogQueue {
        std::array<juce::String, 256> logs;
        std::atomic<uint8_t> writeIndex{0};
        std::atomic<uint8_t> count{0};
        uint8_t readIndex{0};
    };

    LogQueue logQueue_;

    mutable std::mutex logMutex_;
    mutable std::mutex editorMutex_;

    // Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer
    AudioPluginAudioProcessorEditor* editorPtr_{nullptr};

    void pushToLogQueue(const juce::String& logEntry);
    juce::StringArray getCurrentLogs() const;
    void scheduleGUIUpdate();

    // Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer
    std::unique_ptr<juce::FileLogger> fileLogger_;
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"
#include <algorithm>
#include <cassert>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244)  // Varov치n칤 konverze pro MIDI hodnoty
#endif

/**
 * @brief Konstruktor MidiStateManager.
 * Inicializuje logger, resetuje queue a nastav칤 v칳choz칤 hodnoty controller콢 podle MIDI standardu.
 */
MidiStateManager::MidiStateManager()
    : logger_(Logger::getInstance())
{
    logger_.log("MidiStateManager/constructor", "info", "=== INICIALIZACE MIDI STATE MANAGER ===");
    
    // Inicializace aktivn칤ch not
    for (auto& note : activeNotes_) {
        note.store(false);  // V코echny noty neaktivn칤
    }
    
    // Inicializace MIDI controller hodnot
    for (int channel = 0; channel < MIDI_CHANNELS; ++channel) {
        for (int controller = 0; controller < 128; ++controller) {
            controllerValues_[channel][controller] = 0;  // V칳choz칤 0
        }
        
        // V칳choz칤 hodnoty pro standardn칤 controllery
        controllerValues_[channel][7] = 100;   // Volume (v칳choz칤 vysok치)
        controllerValues_[channel][10] = 64;   // Pan (st콏ed)
        controllerValues_[channel][11] = 127;  // Expression (max)
        controllerValues_[channel][64] = 0;    // Sustain pedal (vypnut칳)
        controllerValues_[channel][91] = 0;    // Reverb (vypnut칳)
        controllerValues_[channel][93] = 0;    // Chorus (vypnut칳)
    }
    
    // Reset v코ech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    logger_.log("MidiStateManager/constructor", "info", "Inicializace dokon캜ena.");
    DBG("MidiStateManager initialized.");  // P콏idan칳 debug pro konzoli
}

/**
 * @brief Resetuje NoteQueue na v칳choz칤 stav.
 * Nastav칤 indexy a po캜et na 0, nemus칤 캜istit array (p콏eps치no p콏i pou쬴t칤).
 */
void MidiStateManager::NoteQueue::reset() {
    writeIndex.store(0);
    count.store(0);
    readIndex = 0;
}

/**
 * @brief P콏id치 note-on do queue a aktualizuje stav aktivn칤 noty a velocity.
 * @param channel MIDI kan치l (0-15)
 * @param note MIDI nota (0-127)
 * @param velocity Velocity (0-127)
 */
void MidiStateManager::pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;  // Bezpe캜nostn칤 kontrola
    
    pushToQueue(noteOnQueues_[channel], note);
    activeNotes_[note].store(true);
    velocities_[channel][note] = velocity;
    
    logger_.log("MidiStateManager/pushNoteOn", "debug", "NoteOn kan치l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief P콏id치 note-off do queue a deaktivuje notu.
 * @param channel MIDI kan치l (0-15)
 * @param note MIDI nota (0-127)
 */
void MidiStateManager::pushNoteOff(uint8_t channel, uint8_t note) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;
    
    pushToQueue(noteOffQueues_[channel], note);
    activeNotes_[note].store(false);
    
    logger_.log("MidiStateManager/pushNoteOff", "debug", "NoteOff kan치l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief Vyt치hne note-on z queue pro dan칳 kan치l.
 * @param channel MIDI kan치l
 * @return Nota (0-127) nebo 255 pokud pr치zdn치 queue (游댢 Zm캩na: Pro odstran캩n칤 warningu C4244)
 */
uint8_t MidiStateManager::popNoteOn(uint8_t channel) {  // 游댢 Zm캩na: Zm캩n캩no na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOnQueues_[channel]);
}

/**
 * @brief Vyt치hne note-off z queue pro dan칳 kan치l.
 * @param channel MIDI kan치l
 * @return Nota (0-127) nebo 255 pokud pr치zdn치 queue (游댢 Zm캩na: Pro odstran캩n칤 warningu C4244)
 */
uint8_t MidiStateManager::popNoteOff(uint8_t channel) {  // 游댢 Zm캩na: Zm캩n캩no na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOffQueues_[channel]);
}

/**
 * @brief Zkontroluje, zda je nota aktivn칤.
 * @param channel MIDI kan치l
 * @param note MIDI nota
 * @return True pokud aktivn칤
 */
bool MidiStateManager::isNoteActive(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return false;
    return activeNotes_[note].load();
}

/**
 * @brief Vr치t칤 velocity aktivn칤 noty.
 * @param channel MIDI kan치l
 * @param note MIDI nota
 * @return Velocity (0-127)
 */
uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return 0;
    return velocities_[channel][note];
}

/**
 * @brief Nastav칤 hodnotu MIDI controlleru.
 * @param channel MIDI kan치l
 * @param controller 캛칤slo controlleru (0-127)
 * @param value Hodnota (0-127)
 */
void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value) {
    if (channel >= MIDI_CHANNELS || controller > 127) return;
    controllerValues_[channel][controller] = value;
}

/**
 * @brief Vr치t칤 hodnotu MIDI controlleru.
 * @param channel MIDI kan치l
 * @param controller 캛칤slo controlleru
 * @return Hodnota (0-127)
 */
uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const {
    if (channel >= MIDI_CHANNELS || controller > 127) return 0;
    return controllerValues_[channel][controller];
}

/**
 * @brief P콏id치 prvek do circular queue s automatick칳m p콏ete캜en칤m.
 * @param queue Reference na queue
 * @param note Hodnota k p콏id치n칤
 * Zjednodu코eno: Pou쮂셨치 modulo pro index, atomic operace pro count.
 */
void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() >= 256) {
        logger_.log("MidiStateManager/pushToQueue", "warn", "Queue pln치 - zpr치va ztracena");
        return;  // Zachov치no varov치n칤 p콏i pln칠 queue
    }

    uint8_t index = queue.writeIndex.load();
    queue.notes[index] = note;
    queue.writeIndex.store((index + 1) % 256);  // Automatick칠 p콏ete캜en칤 modulo 256
    queue.count.fetch_add(1);  // Atomic inkrement po캜tu
}

/**
 * @brief Vyt치hne prvek z circular queue.
 * @param queue Reference na queue
 * @return Hodnota nebo 255 p콏i pr치zdn칠 queue (游댢 Zm캩na: Pro konzistenci s uint8_t)
 */
uint8_t MidiStateManager::popFromQueue(NoteQueue& queue) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() == 0) {
        return 255;  // 游댢 Zm캩na: 255 m칤sto 0xff pro uint8_t (pr치zdn치 queue)
    }

    uint8_t note = queue.notes[queue.readIndex];
    queue.readIndex = (queue.readIndex + 1) % 256;  // Modulo pro p콏ete캜en칤
    queue.count.fetch_sub(1);  // Atomic dekrement po캜tu
    return note;
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <array>
#include <atomic>
#include <mutex>
#include "Logger.h"

// Konstanty pro MIDI rozsahy
constexpr uint8_t MIDI_NOTES = 128;  // Standardn칤 po캜et MIDI not (0-127)
constexpr uint8_t MIDI_CHANNELS = 16;  // Standardn칤 po캜et MIDI kan치l콢

/**
 * @class MidiStateManager
 * @brief Spravuje stav MIDI zpr치v, v캜etn캩 aktivn칤ch not, velocity, controller콢 a queue pro note-on/off.
 * 
 * Tato t콏칤da je thread-safe d칤ky mutex콢m a atomic prom캩nn칳m. Poskytuje metody pro push/pop MIDI ud치lost칤,
 * sledov치n칤 aktivn칤ch not a controller hodnot. Inicializuje v칳choz칤 hodnoty controller콢 podle MIDI standardu.
 */
class MidiStateManager
{
public:
    MidiStateManager();

    // Metody pro note-on/off
    void pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity);  // P콏id치 note-on do queue a aktualizuje stav
    void pushNoteOff(uint8_t channel, uint8_t note);  // P콏id치 note-off do queue a aktualizuje stav
    uint8_t popNoteOn(uint8_t channel);  // 游댢 Zm캩na: Zm캩n캩no na uint8_t, vrac칤 255 pokud pr치zdn치 (pro odstran캩n칤 warningu C4244)
    uint8_t popNoteOff(uint8_t channel);  // 游댢 Zm캩na: Zm캩n캩no na uint8_t, vrac칤 255 pokud pr치zdn치

    // Metody pro aktivn칤 noty
    bool isNoteActive(uint8_t channel, uint8_t note) const;  // Zkontroluje, zda je nota aktivn칤
    uint8_t getVelocity(uint8_t channel, uint8_t note) const;  // Vr치t칤 velocity aktivn칤 noty

    // Metody pro MIDI controllery
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);  // Nastav칤 hodnotu controlleru
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;  // Vr치t칤 hodnotu controlleru

private:
    Logger& logger_;  // Reference na logger pro logov치n칤 ud치lost칤

    // Struktura pro circular buffer queue (zachov치na pro efektivitu a thread-safety)
    struct NoteQueue {
        std::array<uint8_t, 256> notes;  // Circular buffer o velikosti 256 (magick칠 캜칤slo zachov치no)
        std::atomic<uint8_t> writeIndex{0};  // Atomic index pro z치pis (thread-safe)
        std::atomic<uint8_t> count{0};  // Po캜et prvk콢 v queue (atomic pro bezpe캜n칳 p콏칤stup)
        uint8_t readIndex{0};  // Index pro 캜ten칤 (chr치n캩n mutexem)
        mutable std::mutex mutex;  // Mutex pro synchronizaci p콏칤stupu

        void reset();  // Resetuje queue na v칳choz칤 stav
    };

    // Queue pro note-on a note-off pro ka쬯칳 kan치l
    std::array<NoteQueue, MIDI_CHANNELS> noteOnQueues_;
    std::array<NoteQueue, MIDI_CHANNELS> noteOffQueues_;

    // Pole pro aktivn칤 noty a velocity
    std::array<std::atomic<bool>, MIDI_NOTES> activeNotes_;  // Atomic pro thread-safety
    std::array<std::array<uint8_t, MIDI_NOTES>, MIDI_CHANNELS> velocities_;  // Velocity pro ka쬯칳 kan치l a notu
    std::array<std::array<uint8_t, 128>, MIDI_CHANNELS> controllerValues_;  // Controller hodnoty

    // Intern칤 helper metody
    void pushToQueue(NoteQueue& queue, uint8_t note);  // P콏id치 do queue s automatick칳m p콏ete캜en칤m
    uint8_t popFromQueue(NoteQueue& queue);  // Vyt치hne z queue, vrac칤 255 p콏i pr치zdn칠
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    DBG("Editor constructor started...");  // P콏idan칳 debug pro konzoli
    juce::ignoreUnused (processorRef);
    
    // Logov치n칤 vytv치콏en칤 editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytv치콏eni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lep코칤 캜itelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmav캩 코ed칠 pozad칤
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelen칳 text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmav칳 okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tla캜칤tka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vy캜i코t캩n칤 display p콏i vypnut칤
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // P콏id치n칤 tla캜칤tka pro vy캜i코t캩n칤 log콢
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastaven칤 reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Roz코칤콏en치 velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKON캛ENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logov치n칤 p콏ed destrukc칤
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstran캩n칤 reference p콏i destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
    DBG("Editor destructor called.");  // P콏idan칳 debug pro konzoli
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    DBG("Painting editor...");  // P콏idan칳 debug pro vykreslen칤
    // Logov치n칤 pouze p콏i prvn칤m vykreslen칤
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozad칤
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horn칤 sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Odd캩lovac칤 캜치ra
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    DBG("Resizing editor...");  // P콏idan칳 debug pro zm캩nu velikosti
    // Logov치n칤 zm캩ny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozlo쬰n칤 komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zab칤r치 v캩t코inu m칤sta
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tla캜칤tka ve spodn칤 캜치sti
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    DBG("Updating log display...");  // P콏idan칳 debug pro aktualizaci display
    // Z칤sk치n칤 bufferu z Loggeru p콏es getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestaven칤 textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastaven칤 textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledov치n칤 nov칳ch ud치lost칤
    logDisplay->moveCaretToEnd();
    
    // Jednoduch칳 scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logov치n칤 a ovl치d치n칤
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

/**
 * @brief Konstruktor AudioPluginAudioProcessor.
 * Inicializuje komponenty a stav.
 */
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true))
    , logger_(Logger::getInstance())
    , voiceManager_(sampleLibrary_)  // VoiceManager vy쬬duje SampleLibrary
{
    logger_.log("PluginProcessor/constructor", "info", "=== STARTING PROCESSOR INITIALIZATION ===");
    
    try {
        // Inicializace s bezpe캜n칳mi v칳choz칤mi hodnotami
        sampleRate_ = 44100.0;
        synthState_.store(SynthState::Uninitialized);
        processingEnabled_.store(false);
        
        logger_.log("PluginProcessor/constructor", "info", "Basic components initialized");
        logger_.log("PluginProcessor/constructor", "info", "Default sample rate: " + juce::String(sampleRate_));
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/constructor", "error", "Error in constructor: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    } catch (...) {
        logger_.log("PluginProcessor/constructor", "error", "Unknown error in constructor");
        synthState_.store(SynthState::Error);
    }
    
    logger_.log("PluginProcessor/constructor", "info", "=== PROCESSOR CONSTRUCTOR COMPLETED ===");
    DBG("Processor constructor completed with state: " + getStateDescription());
}

/**
 * @brief Destruktor - NYU opravdu vyma쬰me samples
 */
AudioPluginAudioProcessor::~AudioPluginAudioProcessor() 
{
    logger_.log("PluginProcessor/destructor", "info", "=== STARTING PROCESSOR DESTRUCTION ===");
    
    try {
        // Okam쬴t칠 zastaven칤 zpracov치n칤
        processingEnabled_.store(false);
        synthState_.store(SynthState::Uninitialized);
        
        logger_.log("PluginProcessor/destructor", "info", "Audio processing stopped");
        
        // NYU opravdu uvoln칤me vzorky p콏i destruktoru
        sampleLibrary_.clear();
        logger_.log("PluginProcessor/destructor", "info", "Sample library cleared");
        
        // Kr치tk칠 캜ek치n칤 pro dokon캜en칤 p콏칤padn칳ch audio vl치ken
        juce::Thread::sleep(10);
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/destructor", "error", "Error in destructor: " + juce::String(e.what()));
    } catch (...) {
        logger_.log("PluginProcessor/destructor", "error", "Unknown error in destructor");
    }
    
    logger_.log("PluginProcessor/destructor", "info", "=== PROCESSOR DESTRUCTION COMPLETED ===");
    DBG("Processor destructor completed");
}

void AudioPluginAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    logger_.log("PluginProcessor/prepareToPlay", "info", "=== PREPARE TO PLAY START ===");
    logger_.log("PluginProcessor/prepareToPlay", "info", 
                "Parameters - SampleRate: " + juce::String(sampleRate) + 
                ", BufferSize: " + juce::String(samplesPerBlock));
    
    try {
        // Validace vstupn칤ch parametr콢
        if (sampleRate <= 0.0 || sampleRate > 192000.0) {
            logger_.log("PluginProcessor/prepareToPlay", "error", "Invalid sample rate: " + juce::String(sampleRate));
            throw std::invalid_argument(("Invalid sample rate: " + juce::String(sampleRate)).toStdString());
        }
        
        if (samplesPerBlock <= 0 || samplesPerBlock > 8192) {
            logger_.log("PluginProcessor/prepareToPlay", "error", "Invalid buffer size: " + juce::String(samplesPerBlock));
            throw std::invalid_argument(("Invalid buffer size: " + juce::String(samplesPerBlock)).toStdString());
        }
        
        // Ulo쬰n칤 star칳ch hodnot pro porovn치n칤
        double oldSampleRate = sampleRate_;
        int oldBufferSize = samplesPerBlock_;
        SynthState oldState = synthState_.load();
        
        // Ulo쬰n칤 nov칳ch parametr콢
        sampleRate_ = sampleRate;
        samplesPerBlock_ = samplesPerBlock;
        
        // OPRAVA: Detekce zm캩n (po ulo쬰n칤 nov칳ch hodnot) - odstran캩n칤 unused isFirstInit
        bool sampleRateChanged = (std::abs(sampleRate - oldSampleRate) > 1.0);
        bool bufferSizeChanged = (samplesPerBlock != oldBufferSize);
        bool hasError = (oldState == SynthState::Error);
        
        // KL칈캛OV츼 OPRAVA: Rozli코it "prvn칤 init po startu" vs "reinit po releaseResources"
        bool isInitAfterRelease = (oldState == SynthState::Uninitialized && oldSampleRate > 0);
        bool isTrueFirstInit = (oldState == SynthState::Uninitialized && oldSampleRate == 0);
        
        logger_.log("PluginProcessor/prepareToPlay", "info", 
                   "Changes - SampleRate: " + juce::String(sampleRateChanged ? "YES" : "NO") + 
                   " (" + juce::String(oldSampleRate) + " -> " + juce::String(sampleRate) + ")" +
                   ", BufferSize: " + juce::String(bufferSizeChanged ? "YES" : "NO") + 
                   " (" + juce::String(oldBufferSize) + " -> " + juce::String(samplesPerBlock) + ")" +
                   ", TrueFirstInit: " + juce::String(isTrueFirstInit ? "YES" : "NO") + 
                   ", InitAfterRelease: " + juce::String(isInitAfterRelease ? "YES" : "NO") +
                   ", HasError: " + juce::String(hasError ? "YES" : "NO"));
        
        // KRITICK츼 OPRAVA: Reinicializace pouze kdy je skute캜n캩 pot콏eba
        bool needsFullReinit = isTrueFirstInit || hasError || sampleRateChanged;
        
        if (needsFullReinit) {
            logger_.log("PluginProcessor/prepareToPlay", "info", 
                       "Performing FULL reinitialization - reason: " + 
                       juce::String(isTrueFirstInit ? "true first init" : 
                                   hasError ? "error state" : 
                                   sampleRateChanged ? "sample rate change" : "unknown"));
            
            // Do캜asn칠 zastaven칤 zpracov치n칤
            processingEnabled_.store(false);
            synthState_.store(SynthState::Initializing);
            
            // Pln치 reinicializace (vzorky, voice manager, atd.)
            initializeSynth();
            
        } else if (isInitAfterRelease && !sampleRateChanged) {
            logger_.log("PluginProcessor/prepareToPlay", "info", 
                       "OPTIMIZED reinitialization after releaseResources - same sample rate " + 
                       juce::String(sampleRate) + ", only restoring state");
            
            // OPTIMALIZACE: Po releaseResources se stejn칳m sample rate nemus칤me regenerovat samples!
            // Samples jsou ji na disku, jen obnov칤me stav
            synthState_.store(SynthState::Initializing);
            processingEnabled_.store(false);
            
            // Rychl치 reinicializace bez generov치n칤 samples
            initializeSynthFast();
            
        } else if (bufferSizeChanged) {
            logger_.log("PluginProcessor/prepareToPlay", "info", 
                       "Buffer size change ONLY from " + juce::String(oldBufferSize) + 
                       " to " + juce::String(samplesPerBlock) + 
                       " - NO sample reinitialization needed");
            
            // OPRAVA: Pro zm캩nu buffer size nepot콏ebujeme reinicializovat samples!
            // Audio engine JUCE si s치m spravuje buffery
            
        } else {
            logger_.log("PluginProcessor/prepareToPlay", "info", 
                       "No changes require action - state remains: " + getStateDescription());
        }
        
        // Povolen칤 zpracov치n칤 pouze pokud je v코e v po콏치dku
        if (synthState_.load() == SynthState::Ready) {
            processingEnabled_.store(true);
            logger_.log("PluginProcessor/prepareToPlay", "info", "Audio processing enabled");
        } else if (!needsFullReinit && !isInitAfterRelease) {
            logger_.log("PluginProcessor/prepareToPlay", "warn", 
                       "Unexpected state after buffer change: " + getStateDescription());
        }
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/prepareToPlay", "error", "Error in prepareToPlay: " + juce::String(e.what()));
        handleSynthError("Error in prepareToPlay: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
        processingEnabled_.store(false);
    } catch (...) {
        logger_.log("PluginProcessor/prepareToPlay", "error", "Unknown error in prepareToPlay");
        handleSynthError("Unknown error in prepareToPlay");
        synthState_.store(SynthState::Error);
        processingEnabled_.store(false);
    }
    
    logger_.log("PluginProcessor/prepareToPlay", "info", 
               "=== PREPARE TO PLAY COMPLETED - State: " + getStateDescription() + 
               ", SampleRate: " + juce::String(sampleRate_) + 
               ", BufferSize: " + juce::String(samplesPerBlock_) + " ===");
    DBG("prepareToPlay completed with state: " + getStateDescription());
}

/**
 * @brief Uvoln칤 zdroje - OPTIMALIZACE: nemazat samples z pam캩ti
 */
void AudioPluginAudioProcessor::releaseResources()
{
    logger_.log("PluginProcessor/releaseResources", "info", "=== STARTING RELEASE RESOURCES ===");
    
    try {
        // Okam쬴t칠 zastaven칤 zpracov치n칤
        processingEnabled_.store(false);
        
        // OPTIMALIZACE: NEMAZAT samples z pam캩ti
        // Samples z콢st치vaj칤 v RAM pro rychlou reinicializaci
        // sampleLibrary_.clear();  // <-- ZAKOMENTOV츼NO
        
        logger_.log("PluginProcessor/releaseResources", "info", "Sample library kept in memory for fast restart");
        
        // Reset pouze stavu, ne dat
        synthState_.store(SynthState::Uninitialized);
        
        logger_.log("PluginProcessor/releaseResources", "info", "All resources released (samples preserved)");
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/releaseResources", "error", "Error during release: " + juce::String(e.what()));
    } catch (...) {
        logger_.log("PluginProcessor/releaseResources", "error", "Unknown error during release");
    }
    
    logger_.log("PluginProcessor/releaseResources", "info", "=== RELEASE RESOURCES COMPLETED ===");
    DBG("Resources released (samples preserved in memory)");
}

/**
 * @brief Inicializuje syntetiz칠r s robustn칤m error handlingem.
 */
void AudioPluginAudioProcessor::initializeSynth()
{
    if (synthState_.load() != SynthState::Initializing) {
        logger_.log("PluginProcessor/initializeSynth", "warn", "Initialization skipped - wrong state: " + getStateDescription());
        return;
    }

    logger_.log("PluginProcessor/initializeSynth", "info", "Starting synth initialization");
    
    try {
        if (sampleRate_ <= 0.0) {
            throw std::runtime_error("Sample rate not set");
        }
        
        logger_.log("PluginProcessor/initializeSynth", "info", "Initializing sample library...");
        sampleLibrary_.initialize(sampleRate_);
        
        // Kontrola, zda byla inicializace 칰sp캩코n치
        bool hasValidSamples = false;
        for (uint8_t note = SampleLibrary::MIN_NOTE; note <= SampleLibrary::MAX_NOTE; ++note) {
            for (uint8_t level = 0; level < 8; ++level) {
                if (sampleLibrary_.isNoteAvailable(note, level)) {
                    hasValidSamples = true;
                    break;
                }
            }
            if (hasValidSamples) break;
        }
        
        if (!hasValidSamples) {
            throw std::runtime_error("No samples were generated");
        }
        
        synthState_.store(SynthState::Ready);
        logger_.log("PluginProcessor/initializeSynth", "info", "Synth successfully initialized");
        
    } catch (const std::exception& e) {
        handleSynthError("Initialization failed: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    } catch (...) {
        handleSynthError("Unknown error during initialization");
        synthState_.store(SynthState::Error);
    }
}

/**
 * @brief Skute캜n캩 rychl치 reinicializace - samples u jsou v pam캩ti
 */
void AudioPluginAudioProcessor::initializeSynthFast()
{
    if (synthState_.load() != SynthState::Initializing) {
        logger_.log("PluginProcessor/initializeSynthFast", "warn", "Fast init skipped - wrong state: " + getStateDescription());
        return;
    }

    logger_.log("PluginProcessor/initializeSynthFast", "info", "Starting FAST synth reinitialization");
    
    try {
        if (sampleRate_ <= 0.0) {
            throw std::runtime_error("Sample rate not set");
        }
        
        // Kontrola, zda m치me u samples v pam캩ti
        bool hasValidSamples = false;
        for (uint8_t note = SampleLibrary::MIN_NOTE; note <= SampleLibrary::MAX_NOTE; ++note) {
            for (uint8_t level = 0; level < 8; ++level) {
                if (sampleLibrary_.isNoteAvailable(note, level)) {
                    hasValidSamples = true;
                    break;
                }
            }
            if (hasValidSamples) break;
        }
        
        if (hasValidSamples) {
            // INSTANT: Samples u jsou v pam캩ti!
            logger_.log("PluginProcessor/initializeSynthFast", "info", 
                       "Samples already in memory - INSTANT reinitialization (0ms)");
            
            synthState_.store(SynthState::Ready);
            
        } else {
            // Fallback: Mus칤me na캜칤st z disku
            logger_.log("PluginProcessor/initializeSynthFast", "info", 
                       "No samples in memory - loading from disk...");
            
            auto progressCallback = [this](int current, int total, const juce::String& /*status*/) {
                if (current % 100 == 0 || current == total) {
                    logger_.log("PluginProcessor/initializeSynthFast", "debug", 
                               "Loading progress: " + juce::String(current) + "/" + juce::String(total));
                }
            };
            
            sampleLibrary_.initialize(sampleRate_, progressCallback);
            
            // Kontrola 칰sp캩코nosti
            hasValidSamples = false;
            for (uint8_t note = SampleLibrary::MIN_NOTE; note <= SampleLibrary::MAX_NOTE; ++note) {
                for (uint8_t level = 0; level < 8; ++level) {
                    if (sampleLibrary_.isNoteAvailable(note, level)) {
                        hasValidSamples = true;
                        break;
                    }
                }
                if (hasValidSamples) break;
            }
            
            if (!hasValidSamples) {
                throw std::runtime_error("No samples available after loading");
            }
            
            synthState_.store(SynthState::Ready);
        }
        
        logger_.log("PluginProcessor/initializeSynthFast", "info", "Fast synth reinitialization completed successfully");
        
    } catch (const std::exception& e) {
        handleSynthError("Fast initialization failed: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    } catch (...) {
        handleSynthError("Unknown error during fast initialization");
        synthState_.store(SynthState::Error);
    }
}

/**
 * @brief Centr치ln칤 handling chyb s detailn칤m logov치n칤m.
 * @param errorMessage Zpr치va o chyb캩
 */
void AudioPluginAudioProcessor::handleSynthError(const juce::String& errorMessage)
{
    logger_.log("PluginProcessor/handleSynthError", "error", errorMessage);
    
    // Zastaven칤 zpracov치n칤 p콏i chyb캩
    processingEnabled_.store(false);
    
    // Mo쬹칠 roz코칤콏en칤 o recovery mechanismy
    DBG("Synth error: " + errorMessage);
}

/**
 * @brief Vr치t칤 popis stavu s dodate캜n칳mi informacemi.
 * @return String popis
 */
juce::String AudioPluginAudioProcessor::getStateDescription() const
{
    juce::String base;
    switch (synthState_.load()) {
        case SynthState::Uninitialized: base = "Uninitialized"; break;
        case SynthState::Initializing: base = "Initializing"; break;
        case SynthState::Ready: base = "Ready"; break;
        case SynthState::Error: base = "Error"; break;
        default: base = "Unknown state"; break;
    }
    
    base += " (Processing: " + juce::String(processingEnabled_.load() ? "ON" : "OFF") + ")";
    return base;
}

/**
 * @brief Zpracuje audio blok s kompletn칤m error handlingem a validac칤.
 * @param buffer Audio buffer
 * @param midiMessages MIDI buffer
 */
void AudioPluginAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    static int blockCounter = 0;
    blockCounter++;
    
    // Periodick칠 logging ka쬯칳ch 1000 blok콢 pro sn칤쬰n칤 z치t캩쬰
    bool shouldLog = (blockCounter % 1000 == 1) || (blockCounter <= 10);
    
    try {
        if (shouldLog) {
            logger_.log("PluginProcessor/processBlock", "debug", 
                       "Block #" + juce::String(blockCounter) + " - State: " + getStateDescription() + 
                       ", Size: " + juce::String(buffer.getNumSamples()) + 
                       ", Channels: " + juce::String(buffer.getNumChannels()));
        }
        
        // Z치kladn칤 validace
        if (!processingEnabled_.load() || synthState_.load() != SynthState::Ready) {
            buffer.clear();
            if (shouldLog) {
                logger_.log("PluginProcessor/processBlock", "debug", "Block skipped - processing disabled or wrong state");
            }
            return;
        }
        
        // Validace bufferu
        if (buffer.getNumSamples() <= 0 || buffer.getNumChannels() <= 0) {
            logger_.log("PluginProcessor/processBlock", "error", "Invalid buffer - samples: " + 
                       juce::String(buffer.getNumSamples()) + ", channels: " + juce::String(buffer.getNumChannels()));
            return;
        }
        
        // Zpracov치n칤 MIDI zpr치v s error handlingem
        int midiEventCount = 0;
        try {
            for (const auto metadata : midiMessages) {
                auto msg = metadata.getMessage();
                midiEventCount++;
                
                if (msg.isNoteOn()) {
                    // OPRAVA: Explicitn칤 cast pro odstran캩n칤 warning C4244
                    midiState_.pushNoteOn(static_cast<uint8_t>(msg.getChannel() - 1), 
                                         static_cast<uint8_t>(msg.getNoteNumber()), 
                                         static_cast<uint8_t>(msg.getVelocity()));
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "NoteOn: note " + juce::String(msg.getNoteNumber()) + 
                                   ", velocity " + juce::String(msg.getVelocity()) + 
                                   ", channel " + juce::String(msg.getChannel()));
                    }
                } else if (msg.isNoteOff()) {
                    // OPRAVA: Explicitn칤 cast pro odstran캩n칤 warning C4244
                    midiState_.pushNoteOff(static_cast<uint8_t>(msg.getChannel() - 1), 
                                          static_cast<uint8_t>(msg.getNoteNumber()));
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "NoteOff: note " + juce::String(msg.getNoteNumber()) + 
                                   ", channel " + juce::String(msg.getChannel()));
                    }
                } else if (msg.isController()) {
                    // OPRAVA: Explicitn칤 cast pro odstran캩n칤 warning C4244
                    midiState_.setControllerValue(static_cast<uint8_t>(msg.getChannel() - 1), 
                                                 static_cast<uint8_t>(msg.getControllerNumber()), 
                                                 static_cast<uint8_t>(msg.getControllerValue()));
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "Controller: #" + juce::String(msg.getControllerNumber()) + 
                                   " = " + juce::String(msg.getControllerValue()));
                    }
                }
            }
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Error processing MIDI: " + juce::String(e.what()));
            // Pokra캜ujeme bez MIDI dat
        }
        
        if (shouldLog && midiEventCount > 0) {
            logger_.log("PluginProcessor/processBlock", "debug", "MIDI messages processed: " + juce::String(midiEventCount));
        }

        // Zpracov치n칤 hlas콢 s error handlingem
        try {
            voiceManager_.processMidiEvents(midiState_);
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Error processing voices: " + juce::String(e.what()));
            buffer.clear();
            return;
        }

        // Generace audio s bezpe캜nostn칤mi kontrolami
        buffer.clear();
        
        // OPRAVA: Z칤sk치n칤 float* pointeru z AudioBuffer
        float* channelData = buffer.getWritePointer(0);
        if (channelData == nullptr) {
            logger_.log("PluginProcessor/processBlock", "error", "Null pointer for audio buffer channel 0");
            return;
        }
        
        try {
            // OPRAVA: P콏ed치n칤 float* m칤sto AudioBuffer
            voiceManager_.generateAudio(channelData, buffer.getNumSamples());
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Error generating audio: " + juce::String(e.what()));
            buffer.clear();
            return;
        }

        // Bezpe캜n치 konverze na stereo
        if (buffer.getNumChannels() >= 2) {
            try {
                buffer.copyFrom(1, 0, buffer, 0, 0, buffer.getNumSamples());
                if (shouldLog) {
                    logger_.log("PluginProcessor/processBlock", "debug", "Stereo conversion completed");
                }
            } catch (const std::exception& e) {
                logger_.log("PluginProcessor/processBlock", "error", "Error in stereo conversion: " + juce::String(e.what()));
                // Nech치me mono, nen칤 to kritick치 chyba
            }
        }

        // Refresh voice manageru
        voiceManager_.refresh();

        if (shouldLog) {
            int activeVoices = voiceManager_.getActiveVoiceCount();
            logger_.log("PluginProcessor/processBlock", "debug", 
                       "Block completed - Active voices: " + juce::String(activeVoices));
        }
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/processBlock", "error", "Exception in processBlock: " + juce::String(e.what()));
        buffer.clear(); // Zajist칤me tich칳 v칳stup p콏i chyb캩
        processingEnabled_.store(false); // Zastav칤me zpracov치n칤 p콏i kritick칠 chyb캩
    } catch (...) {
        logger_.log("PluginProcessor/processBlock", "error", "Unknown exception in processBlock");
        buffer.clear();
        processingEnabled_.store(false);
    }
}

/**
 * @brief Vytvo콏칤 editor s error handlingem.
 */
juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    logger_.log("PluginProcessor/createEditor", "info", "=== CREATING EDITOR ===");
    
    try {
        auto* editor = new AudioPluginAudioProcessorEditor(*this);
        logger_.log("PluginProcessor/createEditor", "info", "Editor successfully created");
        return editor;
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/createEditor", "error", "Error creating editor: " + juce::String(e.what()));
        return nullptr;
    } catch (...) {
        logger_.log("PluginProcessor/createEditor", "error", "Unknown error creating editor");
        return nullptr;
    }
}

/**
 * @brief Exportovan치 funkce pro JUCE plugin s error handlingem.
 */
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    try {
        return new AudioPluginAudioProcessor();
    } catch (const std::exception& e) {
        DBG("Error creating plugin: " + juce::String(e.what()));
        return nullptr;
    } catch (...) {
        DBG("Unknown error creating plugin");
        return nullptr;
    }
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include "SampleLibrary.h"
#include "VoiceManager.h"
#include "MidiStateManager.h"
#include "Logger.h"

// Enum pro stavy syntetiz칠ru s roz코칤콏enou funkcionalitou
enum class SynthState {
    Uninitialized,  // Po캜치te캜n칤 stav - nic nen칤 inicializov치no
    Initializing,   // Prob칤h치 inicializace
    Ready,          // P콏ipraveno k audio zpracov치n칤
    Error           // Kritick치 chyba - vy쬬duje restart
};

/**
 * @class AudioPluginAudioProcessor
 * @brief Hlavn칤 audio procesor pluginu (JUCE-based) s robustn칤m error handlingem.
 * 
 * Spravuje inicializaci, zpracov치n칤 audio/MIDI, stav syntetiz칠ru a error recovery.
 * Nov캩 p콏id치ny atomic safety mechanismy a detailn칤 logging pro debugging.
 * 
 * Thread Safety:
 * - synthState_ a processingEnabled_ jsou atomic pro bezpe캜n칳 p콏칤stup z v칤ce vl치ken
 * - V코echny kritick칠 operace jsou chr치n캩ny try-catch bloky
 * - Error handling s automatic recovery kde je to mo쬹칠
 * 
 * Memory Management:
 * - Automatick칠 cleanup v destruktoru
 * - Safe resource deallocation p콏i chyb치ch
 * - Kontrola validity pointer콢 p콏ed pou쬴t칤m
 */
class AudioPluginAudioProcessor : public juce::AudioProcessor
{
public:
    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    // === JUCE Audio Processor Interface ===
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    // === Editor Management ===
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    // === Plugin Metadata ===
    const juce::String getName() const override { return JucePlugin_Name; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    // === Program Management (Basic Implementation) ===
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&) override {}

    // === State Persistence (Placeholder) ===
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

    // === Public Status Methods ===
    /**
     * @brief Vr치t칤 lidsky 캜iteln칳 popis aktu치ln칤ho stavu.
     * @return String s popisem stavu v캜etn캩 processing status
     */
    juce::String getStateDescription() const;

    /**
     * @brief Kontroluje, zda je procesor p콏ipraven k audio zpracov치n칤.
     * @return true pokud je ready a processing enabled
     */
    bool isReadyForProcessing() const { 
        return synthState_.load() == SynthState::Ready && processingEnabled_.load(); 
    }

    /**
     * @brief Vr치t칤 aktu치ln칤 sample rate.
     * @return Sample rate nebo 0 pokud nen칤 nastaven
     */
    double getCurrentSampleRate() const { return sampleRate_; }

    /**
     * @brief Vr치t칤 velikost audio bufferu.
     * @return Velikost bufferu nebo 0 pokud nen칤 nastaven
     */
    int getCurrentBufferSize() const { return samplesPerBlock_; }

private:
    // === Core Components ===
    Logger& logger_;  // Reference na singleton logger
    SampleLibrary sampleLibrary_;  // Knihovna audio vzork콢
    VoiceManager voiceManager_;  // Manager polyphonic hlas콢
    MidiStateManager midiState_;  // Manager MIDI stavu a ud치lost칤

    // === State Management (Thread-Safe) ===
    std::atomic<SynthState> synthState_{SynthState::Uninitialized};  // Stav syntetiz칠ru
    std::atomic<bool> processingEnabled_{false};  // Povolen칤 audio zpracov치n칤
    
    // === Audio Configuration ===
    double sampleRate_{44100.0};  // Aktu치ln칤 sample rate
    int samplesPerBlock_{512};     // Velikost audio bufferu

    // === Private Methods ===

    /**
     * @brief Inicializuje syntetiz칠r (vzorky, voices atd.) s error handlingem.
     * Vol치 se z prepareToPlay po validaci parametr콢.
     * 
     * Process:
     * 1. Kontrola p콏echod콢 stav콢
     * 2. Inicializace SampleLibrary
     * 3. Validace vygenerovan칳ch vzork콢
     * 4. Nastaven칤 Ready stavu
     * 
     * @throws std::runtime_error p콏i kritick칳ch chyb치ch
     */
    void initializeSynth();

    /**
     * @brief Rychl치 reinicializace syntetiz칠ru bez regenerov치n칤 samples
     * Vol치 se po releaseResources() se stejn칳m sample rate pro optimalizaci.
     * 
     * Process:
     * 1. Rychl칠 na캜ten칤 existuj칤c칤ch samples z disku
     * 2. Validace dostupnosti vzork콢
     * 3. Nastaven칤 Ready stavu
     * 
     * @throws std::runtime_error p콏i kritick칳ch chyb치ch
     */
    void initializeSynthFast();

    /**
     * @brief Centr치ln칤 metoda pro handling chyb s automatick칳m recovery.
     * 
     * Akce p콏i chyb캩:
     * - Logov치n칤 s detailn칤m popisem
     * - Zastaven칤 audio zpracov치n칤
     * - Mo쬹칠 future recovery mechanismy
     * 
     * @param errorMessage Zpr치va o chyb캩 pro logging
     */
    void handleSynthError(const juce::String& errorMessage);

    // === JUCE Macro for Memory Leak Detection ===
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioPluginAudioProcessor)
};

// === Global Plugin Factory Function ===
/**
 * @brief Factory funkce pro vytv치콏en칤 plugin instance.
 * Vy쬬dov치na JUCE frameworkem pro VST3, AU a dal코칤 form치ty.
 * 
 * @return Novou instanci AudioPluginAudioProcessor nebo nullptr p콏i chyb캩
 */
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter();


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe  
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib  
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3  
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe  

## Cesta na aplikacni data

WIN+R: %APPDATA%\IthacaPlayer  

C:\Users\[u쬴vatel]\AppData\Roaming\IthacaPlayer  

Zde se ukl치daj칤 generovan칠 WAV soubory pro samples (v podslo쬮e "instrument"), logy (IthacaPlayer.log) a dal코칤 data.

## Tail aplikacniho logu

```
Get-Content -Path C:\Users\nemej992\AppData\Roaming\IthacaPlayer\IthacaPlayer.log -Tail 10 -Wait
```


## MIDI tools

### VMPK

Virtu치ln칤 MIDI kl치vesnice pro testov치n칤. Pou쬴jte po캜칤ta캜ovou kl치vesnici nebo my코 k hran칤 not a spojte s IthacaPlayer p콏es virtual MIDI porty.  

https://vmpk.sourceforge.io/#Download  
https://sourceforge.net/projects/vmpk/  

### loopMIDI

N치stroj pro vytv치콏en칤 virtu치ln칤ch MIDI port콢 na Windows pro propojen칤 aplikac칤 (nap콏. VMPK s IthacaPlayer).  

https://www.tobias-erichsen.de/software/loopmidi.html  

## Nastaven칤 v칳vojov칠ho prost콏ed칤

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) prove캞te n치sleduj칤c칤 kroky. P콏edpokl치d치 se instalace Visual Studio Build Tools (s MSVC kompil치torem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.  

### Po쬬davky  
- Visual Studio Build Tools (MSVC kompil치tor).  
- CMake nainstalovan칳 a p콏id치n do PATH (nap콏. C:\Program Files\CMake\bin).  
- VS Code.  

### Kroky nastaven칤  
1. **Instalace roz코칤콏en칤 ve VS Code**:  
   - Otev콏ete Extensions (Ctrl+Shift+X).  
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a lad캩n칤) a CMake Tools (od Microsoftu pro integraci CMake).  
   - Restartujte VS Code.  

2. **Otev콏en칤 projektu**:  
   - P콏ejd캩te na File > Open Folder a vyberte slo쬶u s CMakeLists.txt.  

3. **V칳b캩r kompil치toru (kit)**:  
   - V Command Palette (Ctrl+Shift+P) napi코te "CMake: Select a Kit".  
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle pot콏eby (nap콏. x64 pro modern칤 syst칠my).  

4. **Konfigurace projektu**:  
   - V Command Palette napi코te "CMake: Configure". To vygeneruje build soubory (obvykle ve slo쬮e "build").  

5. **Build projektu**:  
   - V Command Palette napi코te "CMake: Build" nebo pou쬴jte Shift+Ctrl+B (nyn칤 nab칤dne CMake 칰lohy).  

6. **Debugov치n칤 (voliteln캩)**:  
   - Nastavte breakpointy a spus콘te "CMake: Debug" v Command Palette.  

---  

# IthacaPlayer - Software Synthesizer  

Audio plugin synthesizer implementovan칳 v JUCE frameworku, inspirovan칳 hardwarov칳mi syntez치tory s modul치rn칤 architekturou. Podporuje MIDI vstup, generov치n칤 audio sampl콢 (fallback na sine vlny), dynamic levels (0-7) pro velocity mapping a stereo samples.  

## Architektura Syst칠mu  

### P콏ehled Komponent  

```
AudioPluginAudioProcessor (Main Controller)
較럭較 SampleLibrary (Pre-computed Audio Storage)
較   較덕較 SampleLoader (Loading/Generating/Resampling WAV)
較럭較 MidiStateManager (MIDI Event Processing)
較럭較 VoiceManager (Voice Allocation & Control)
較럭較 Logger (Debug & Monitoring with Circular Buffer)
較덕較 PluginEditor (GUI Interface with Logging)
```


## Core Komponenty  

### 1. SampleLibrary  
**칔캜el:** Spr치va pre-computed audio sampl콢 pro MIDI noty (21-108) s podporou 8 dynamic levels.  
**Kl칤캜ov칠 vlastnosti:**  
- Automatick칠 generov치n칤 sine vln jako fallback.  
- Ukl치d치n칤/resampling WAV soubor콢 do %APPDATA%\IthacaPlayer\instrument\ (podpora 44.1kHz a 48kHz).  
- Velocity mapping na dynamic levels (0-7).  
- Podpora mono/stereo sampl콢.  

### 2. SampleLoader  
**칔캜el:** Na캜칤t치n칤/generov치n칤 sampl콢 s resamplingem.  
**Kl칤캜ov칠 vlastnosti:**  
- Naming convention: m[nota]-vel[level]-[sr].wav (nap콏. m060-vel3-44.wav).  
- Fallback: Pokud soubor chyb칤, generuje sine pro 44.1kHz, resampluje na 48kHz a ukl치d치.  
- Statistiky loadingu (na캜ten칠/generovan칠 soubory, pam캩콘).  

### 3. MidiStateManager  
**칔캜el:** Spr치va MIDI stavu (noty, velocity, controllery).  
**Kl칤캜ov칠 vlastnosti:**  
- Kruhov칠 fronty pro note-on/off (thread-safe s mutex a atomic).  
- Inicializace default controller hodnot (nap콏. volume=100).  
- Podpora 16 kan치l콢.  

### 4. VoiceManager  
**칔캜el:** Alokace a kontrola hlas콢 (polyfonie).  
**Kl칤캜ov칠 vlastnosti:**  
- A 16 hlas콢 s dynamic level selection.  
- Enhanced voice stealing (nejstar코칤 hlas s nejvy코코칤m progressem).  
- Stereo rendering (mix/duplicate kan치l콢).  
- Statistiky: Aktivn칤 hlasy, podle levels, pr콢m캩rn칳 progress, stolen voices.  

### 5. Logger  
**칔캜el:** Logov치n칤 s kruhov칳m bufferem a GUI display.  
**Kl칤캜ov칠 vlastnosti:**  
- Kruhov칳 buffer (100 vstup콢) pro efektivn칤 pam캩콘.  
- Z치pis do souboru (IthacaPlayer.log v %APPDATA%).  
- Podpora 칰rovn칤 (info/debug/error/warn).  
- Thread-safe s mutex.  
- Integrace s GUI pro real-time display.  

### 6. PluginProcessor  
**칔캜el:** Hlavn칤 audio procesor (JUCE-based).  
**Kl칤캜ov칠 vlastnosti:**  
- Robustn칤 error handling s try-catch a recovery.  
- Inicializace jen p콏i zm캩n캩 sample rate/bufferu.  
- Podpora VST3/AU/Standalone.  

### 7. PluginEditor  
**칔캜el:** GUI rozhran칤 pro debugging a monitoring.  
**Kl칤캜ov칠 vlastnosti:**  
- Real-time log display s matrix theme (zelen칳 text na tmav칠m pozad칤, monospace font).  
- Toggle tla캜칤tko pro zapnut칤/vypnut칤 logov치n칤.  
- Tla캜칤tko pro vy캜i코t캩n칤 log콢.  
- Gradient pozad칤 a nadpis pro lep코칤 vizu치l.  
- Velikost okna: 1024x600 pro pohodln칠 캜ten칤 log콢.  

## Zm캩ny a Opravy  
- Odstran캩ny warningy C4244 (explicitn칤 casts pro MIDI hodnoty).  
- Nahrazeno ScopedPointer unique_ptr (modern칤 C++).  
- P콏id치na thread-safety (atomic, mutex pro fronty a stavy).  
- Optimalizace: Kruhov칠 buffery, fallback na ni쮄뫆/vy코코칤 dynamic levels.  
- GUI vylep코en칤: Matrix styl, toggle/clear funkce, roz코칤콏en칠 logov치n칤 p콏i resize/paint.  
- Zn치m칠 limity: Generovan칠 samples jsou mono/sine (bez ADSR envelope), max polyfonie 16, 쮂멳n치 re치ln치 modulace (pouze sine).  

## Pl치novan칠 Roz코칤콏en칤  
- ADSR envelope pro voices.  


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include <cmath>

/**
 * @brief SampleLibrary constructor
 */
SampleLibrary::SampleLibrary()
    : logger_(Logger::getInstance())
{
    logger_.log("SampleLibrary/constructor", "info", "SampleLibrary initialized with dynamic levels");
}

/**
 * @brief Initializes sample library with hybrid loading system
 */
void SampleLibrary::initialize(double sampleRate, 
                              std::function<void(int, int, const juce::String&)> progressCallback)
{
    if (sampleRate <= 0.0) {
        logger_.log("SampleLibrary/initialize", "error", "Invalid sampleRate: " + juce::String(sampleRate));
        throw std::invalid_argument("Invalid sampleRate");
    }

    auto startTime = juce::Time::getMillisecondCounterHiRes();
    
    sampleRate_ = sampleRate;
    clear();

    logger_.log("SampleLibrary/initialize", "info",
                "Starting initialization with sample rate=" + juce::String(sampleRate_) + 
                " using dynamic levels");

    // Reset statistics
    loadingStats_ = SampleLibraryStats();

    try {
        // Create SampleLoader
        SampleLoader loader(sampleRate);
        juce::File instrumentDir = SampleLoader::getDefaultInstrumentDirectory();
        
        // Ensure directory exists
        if (!instrumentDir.exists()) {
            if (!instrumentDir.createDirectory()) {
                throw std::runtime_error("Cannot create instrument directory: " + 
                                       instrumentDir.getFullPathName().toStdString());
            }
            logger_.log("SampleLibrary/initialize", "info", 
                       "Created instrument directory: " + instrumentDir.getFullPathName());
        }

        // Progress callback wrapper s redukovan칳m loggingem
        auto progressWrapper = [this, progressCallback](int current, int total, const juce::String& status) {
            if (progressCallback) {
                progressCallback(current, total, status);
            }
            // Log pouze ka쬯칳 100. sample pro sn칤쬰n칤 noise
            if (current % 100 == 0 || current == total) {
                logger_.log("SampleLibrary/initialize", "debug", 
                           "Progress: " + juce::String(current) + "/" + juce::String(total) + 
                           " - " + status);
            }
        };

        // Load all samples
        std::vector<LoadedSample> loadedSamples = loader.loadInstrument(instrumentDir, progressWrapper);
        
        // Store samples in internal structure
        for (const auto& sample : loadedSamples) {
            try {
                storeSampleRam(sample);
                loadingStats_.totalSamples++;
                
                if (sample.isGenerated) {
                    loadingStats_.generatedSines++;
                } else {
                    loadingStats_.loadedFromFiles++;
                }
                
            } catch (const std::exception& e) {
                logger_.log("SampleLibrary/initialize", "error",
                           "Error storing sample for note " + juce::String((int)sample.midiNote) + 
                           " level " + juce::String((int)sample.dynamicLevel) + 
                           ": " + juce::String(e.what()));
            }
        }
        
        // Adopt statistics from SampleLoader
        const auto& loaderStats = loader.getLoadingStats();
        loadingStats_.savedToFiles = loaderStats.filesSaved;
        loadingStats_.totalMemoryUsed = getTotalMemoryUsage();
        loadingStats_.loadingTimeSeconds = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;

        logger_.log("SampleLibrary/initialize", "info",
                   "Initialization completed: " + loadingStats_.getDescription());
        
        // Check if we have any samples
        if (loadingStats_.totalSamples == 0) {
            throw std::runtime_error("No samples were loaded!");
        }
        
        // Check availability of basic notes for debugging
        AvailabilityInfo availInfo = getAvailabilityInfo();
        logger_.log("SampleLibrary/initialize", "info",
                   "Available notes: " + juce::String(availInfo.notesWithAnyLevel) + "/" + 
                   juce::String(MAX_NOTE - MIN_NOTE + 1) + 
                   " (mono: " + juce::String(availInfo.monoSamples) + 
                   ", stereo: " + juce::String(availInfo.stereoSamples) + ")");
        
        // Log dynamic level distribution
        juce::String levelDistribution = "Dynamic levels: ";
        for (int i = 0; i < NUM_DYNAMIC_LEVELS; ++i) {
            levelDistribution += "L" + juce::String(i) + ":" + juce::String(availInfo.levelCounts[i]) + " ";
        }
        logger_.log("SampleLibrary/initialize", "info", levelDistribution);
        
    } catch (const std::exception& e) {
        logger_.log("SampleLibrary/initialize", "error",
                   "Fatal error during initialization: " + juce::String(e.what()));
        throw;
    } catch (...) {
        logger_.log("SampleLibrary/initialize", "error",
                   "Unknown fatal error during initialization");
        throw std::runtime_error("Unknown error during initialization");
    }
}

/**
 * @brief Clears all samples from memory
 */
void SampleLibrary::clear()
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    logger_.log("SampleLibrary/clear", "info", "Starting SampleLibrary clear operation");
    
    size_t totalFreed = 0;
    int segmentsCleared = 0;
    
    for (auto& segment : sampleSegments_) {
        if (segment.midiNote != 0) { // Segment has data
            totalFreed += segment.getMemoryUsage();
            segment.reset();
            segmentsCleared++;
        }
    }

    // Reset statistics
    loadingStats_ = SampleLibraryStats();

    logger_.log("SampleLibrary/clear", "info", 
               "SampleLibrary cleared - freed " + juce::String(segmentsCleared) + 
               " segments, " + juce::String(totalFreed / (1024*1024)) + "MB");
}

/**
 * @brief Returns sample data for specific note and dynamic level
 */
const float* SampleLibrary::getSampleData(uint8_t midiNote, uint8_t dynamicLevel) const
{
    if (!isValidNote(midiNote) || !isValidDynamicLevel(dynamicLevel)) {
        return nullptr;
    }
    
    std::lock_guard<std::mutex> lock(accessMutex_);
    return sampleSegments_[midiNote].getLayerData(dynamicLevel);
}

/**
 * @brief Returns sample length for specific note and dynamic level
 */
uint32_t SampleLibrary::getSampleLength(uint8_t midiNote, uint8_t dynamicLevel) const
{
    if (!isValidNote(midiNote) || !isValidDynamicLevel(dynamicLevel)) {
        return 0;
    }
    
    std::lock_guard<std::mutex> lock(accessMutex_);
    return sampleSegments_[midiNote].getLayerLength(dynamicLevel);
}

/**
 * @brief Checks availability of specific dynamic level
 */
bool SampleLibrary::isNoteAvailable(uint8_t midiNote, uint8_t dynamicLevel) const
{
    if (!isValidNote(midiNote) || !isValidDynamicLevel(dynamicLevel)) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(accessMutex_);
    return sampleSegments_[midiNote].isLayerAvailable(dynamicLevel);
}

/**
 * @brief Checks if sample is stereo
 */
bool SampleLibrary::isSampleStereo(uint8_t midiNote, uint8_t dynamicLevel) const
{
    if (!isValidNote(midiNote) || !isValidDynamicLevel(dynamicLevel)) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(accessMutex_);
    return sampleSegments_[midiNote].isLayerStereo(dynamicLevel);
}

/**
 * @brief Stores loaded sample into RAM-based internal structure s redukovan칳m loggingem
 */
void SampleLibrary::storeSampleRam(const LoadedSample& sample)
{
    if (!isValidNote(sample.midiNote) || !isValidDynamicLevel(sample.dynamicLevel)) {
        throw std::invalid_argument("Invalid MIDI note or dynamic level");
    }
    
    if (!sample.audioData || sample.lengthSamples == 0) {
        throw std::invalid_argument("Invalid sample data");
    }

    std::lock_guard<std::mutex> lock(accessMutex_);
    
    SampleSegment& segment = sampleSegments_[sample.midiNote];
    segment.midiNote = sample.midiNote;
    
    // Copy data (necessary due to unique_ptr)
    size_t totalSamples = static_cast<size_t>(sample.lengthSamples) * sample.numChannels;
    auto dataCopy = std::make_unique<float[]>(totalSamples);
    std::copy(sample.audioData.get(), 
              sample.audioData.get() + totalSamples, 
              dataCopy.get());
    
    bool isStereo = (sample.numChannels == 2);
    segment.storeLayer(sample.dynamicLevel, std::move(dataCopy), sample.lengthSamples, isStereo);
    
    // OPRAVA: Drasticky redukovan칠 logging - pouze ka쬯칳ch 200 samples
    static int storeCounter = 0;
    if (++storeCounter % 200 == 0) {
        logger_.log("SampleLibrary/storeSampleRam", "debug",
                   "Batch stored " + juce::String(storeCounter) + " samples in RAM " +
                   "(latest: note " + juce::String((int)sample.midiNote) + 
                   " level " + juce::String((int)sample.dynamicLevel) + 
                   ", " + juce::String(sample.lengthSamples) + " samples, " +
                   juce::String(isStereo ? "stereo" : "mono") + ")");
    }
}

/**
 * @brief Maps MIDI velocity to dynamic level
 */
uint8_t SampleLibrary::velocityToDynamicLevel(uint8_t velocity)
{
    return SampleLoader::velocityToDynamicLevel(velocity);
}

/**
 * @brief Returns total memory usage in bytes
 */
size_t SampleLibrary::getTotalMemoryUsage() const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    size_t total = 0;
    for (const auto& segment : sampleSegments_) {
        total += segment.getMemoryUsage();
    }
    
    return total;
}

/**
 * @brief Returns count of available notes
 */
int SampleLibrary::getAvailableNoteCount() const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    int count = 0;
    for (uint8_t note = MIN_NOTE; note <= MAX_NOTE; ++note) {
        // Count note as available if it has at least one dynamic level
        bool hasAnyLevel = false;
        for (uint8_t level = 0; level < NUM_DYNAMIC_LEVELS; ++level) {
            if (sampleSegments_[note].isLayerAvailable(level)) {
                hasAnyLevel = true;
                break;
            }
        }
        if (hasAnyLevel) {
            count++;
        }
    }
    
    return count;
}

/**
 * @brief Returns detailed information about available dynamic levels
 */
SampleLibrary::AvailabilityInfo SampleLibrary::getAvailabilityInfo() const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    AvailabilityInfo info;
    info.totalNotes = MAX_NOTE - MIN_NOTE + 1;
    
    for (uint8_t note = MIN_NOTE; note <= MAX_NOTE; ++note) {
        bool hasAnyLevel = false;
        
        for (uint8_t level = 0; level < NUM_DYNAMIC_LEVELS; ++level) {
            if (sampleSegments_[note].isLayerAvailable(level)) {
                hasAnyLevel = true;
                info.levelCounts[level]++;
                
                if (sampleSegments_[note].isLayerStereo(level)) {
                    info.stereoSamples++;
                } else {
                    info.monoSamples++;
                }
            }
        }
        
        if (hasAnyLevel) {
            info.notesWithAnyLevel++;
        }
    }
    
    return info;
}


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <memory>
#include <array>
#include <mutex>
#include "Logger.h"
#include "SampleLoader.h"

/**
 * @struct SampleSegment
 * @brief Container for 8 dynamic levels of a single MIDI note with stereo support
 * 
 * Each MIDI note has 8 dynamic levels (vel0-vel7) with different amplitudes.
 * Each level can have different length and can be mono or stereo.
 */
struct SampleSegment
{
    std::array<std::unique_ptr<float[]>, 8> dynamicLayers;      // 8 dynamic levels
    std::array<uint32_t, 8> layerLengthSamples;                // Length of each level
    std::array<bool, 8> layerAllocated;                        // Whether level is allocated
    std::array<bool, 8> layerIsStereo;                         // Whether level is stereo
    uint8_t midiNote;                                           // MIDI note of this segment
    
    SampleSegment() : layerLengthSamples{}, layerAllocated{}, layerIsStereo{}, midiNote(0) {}
    
    /**
     * @brief Returns length of specific dynamic level
     */
    uint32_t getLayerLength(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8) ? layerLengthSamples[dynamicLevel] : 0;
    }
    
    /**
     * @brief Returns data of specific dynamic level
     */
    const float* getLayerData(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8 && layerAllocated[dynamicLevel]) 
               ? dynamicLayers[dynamicLevel].get() : nullptr;
    }
    
    /**
     * @brief Checks if dynamic level is available
     */
    bool isLayerAvailable(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8) && layerAllocated[dynamicLevel];
    }
    
    /**
     * @brief Checks if dynamic level is stereo
     */
    bool isLayerStereo(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8) && layerIsStereo[dynamicLevel];
    }
    
    /**
     * @brief Stores sample into specific dynamic level
     */
    void storeLayer(uint8_t dynamicLevel, std::unique_ptr<float[]> data, uint32_t length, bool isStereo) {
        if (dynamicLevel < 8) {
            dynamicLayers[dynamicLevel] = std::move(data);
            layerLengthSamples[dynamicLevel] = length;
            layerAllocated[dynamicLevel] = true;
            layerIsStereo[dynamicLevel] = isStereo;
        }
    }
    
    /**
     * @brief Resets all dynamic levels
     */
    void reset() {
        for (int i = 0; i < 8; ++i) {
            dynamicLayers[i].reset();
            layerLengthSamples[i] = 0;
            layerAllocated[i] = false;
            layerIsStereo[i] = false;
        }
        midiNote = 0;
    }
    
    /**
     * @brief Calculates total memory usage of this segment
     */
    size_t getMemoryUsage() const {
        size_t total = 0;
        for (int i = 0; i < 8; ++i) {
            if (layerAllocated[i]) {
                total += layerLengthSamples[i] * sizeof(float) * (layerIsStereo[i] ? 2 : 1);
            }
        }
        return total;
    }
};

/**
 * @struct LoadingStats
 * @brief Extended loading process statistics for SampleLibrary
 */
struct SampleLibraryStats
{
    int totalSamples;           // Total number of loaded samples
    int loadedFromFiles;        // Number loaded from WAV files
    int generatedSines;         // Number of generated sine waves
    int savedToFiles;           // Number of saved generated files
    size_t totalMemoryUsed;     // Total memory usage in bytes
    double loadingTimeSeconds;  // Total loading time
    
    SampleLibraryStats() : totalSamples(0), loadedFromFiles(0), generatedSines(0), 
                          savedToFiles(0), totalMemoryUsed(0), loadingTimeSeconds(0.0) {}
    
    /**
     * @brief Returns human-readable description of statistics
     */
    juce::String getDescription() const {
        return "Samples: " + juce::String(totalSamples) + 
               " (WAV: " + juce::String(loadedFromFiles) + 
               ", Generated: " + juce::String(generatedSines) + 
               ", Saved: " + juce::String(savedToFiles) + ")" +
               ", Memory: " + juce::String(totalMemoryUsed / (1024*1024)) + "MB" +
               ", Time: " + juce::String(loadingTimeSeconds, 2) + "s";
    }
};

/**
 * @class SampleLibrary
 * @brief Refactored sample library with dynamic levels support and hybrid loading
 * 
 * Key features:
 * - 8 dynamic levels per MIDI note (vel0-vel7)
 * - Hybrid loading: WAV files + fallback sine generation
 * - Variable length samples (each level can have different length)
 * - Stereo/mono support with automatic conversion
 * - Automatic saving of generated samples
 * - Thread-safe access with mutex
 * - Detailed loading statistics
 */
class SampleLibrary
{
public:
    SampleLibrary();
    ~SampleLibrary() = default;

    // === Main Interface ===
    
    /**
     * @brief Initializes sample library with hybrid loading system
     * @param sampleRate Target sample rate
     * @param progressCallback Callback for progress reporting
     */
    void initialize(double sampleRate, 
                   std::function<void(int, int, const juce::String&)> progressCallback = nullptr);

    /**
     * @brief Clears all samples (frees memory)
     */
    void clear();

    // === Extended API for dynamic levels with stereo support ===
    
    /**
     * @brief Returns sample data for specific note and dynamic level
     * @param midiNote MIDI note (21-108)
     * @param dynamicLevel Dynamic level (0-7)
     * @return Pointer to audio data or nullptr
     */
    const float* getSampleData(uint8_t midiNote, uint8_t dynamicLevel) const;
    
    /**
     * @brief Returns sample length for specific note and dynamic level
     * @param midiNote MIDI note
     * @param dynamicLevel Dynamic level
     * @return Length in samples or 0
     */
    uint32_t getSampleLength(uint8_t midiNote, uint8_t dynamicLevel) const;
    
    /**
     * @brief Checks availability of specific dynamic level
     * @param midiNote MIDI note
     * @param dynamicLevel Dynamic level
     * @return true if available
     */
    bool isNoteAvailable(uint8_t midiNote, uint8_t dynamicLevel) const;
    
    /**
     * @brief Checks if sample is stereo
     * @param midiNote MIDI note
     * @param dynamicLevel Dynamic level
     * @return true if stereo
     */
    bool isSampleStereo(uint8_t midiNote, uint8_t dynamicLevel) const;

    // === Backward compatibility (uses dynamic level 0) ===
    
    const float* getSampleData(uint8_t midiNote) const {
        return getSampleData(midiNote, 0);
    }
    
    uint32_t getSampleLength(uint8_t midiNote) const {
        return getSampleLength(midiNote, 0);
    }
    
    bool isNoteAvailable(uint8_t midiNote) const {
        return isNoteAvailable(midiNote, 0);
    }

    // === Utility methods ===
    
    /**
     * @brief Maps MIDI velocity to dynamic level
     * @param velocity MIDI velocity (0-127)
     * @return Dynamic level (0-7)
     */
    static uint8_t velocityToDynamicLevel(uint8_t velocity);
    
    /**
     * @brief Returns loading statistics
     */
    const SampleLibraryStats& getLoadingStats() const { return loadingStats_; }
    
    /**
     * @brief Returns total memory usage
     */
    size_t getTotalMemoryUsage() const;
    
    /**
     * @brief Returns count of available notes
     */
    int getAvailableNoteCount() const;
    
    /**
     * @brief Returns detailed information about available dynamic levels
     */
    struct AvailabilityInfo {
        int totalNotes;
        int notesWithAnyLevel;
        std::array<int, 8> levelCounts;  // Count of notes for each level
        int monoSamples;
        int stereoSamples;
        
        AvailabilityInfo() : totalNotes(0), notesWithAnyLevel(0), levelCounts{}, 
                            monoSamples(0), stereoSamples(0) {}
    };
    
    AvailabilityInfo getAvailabilityInfo() const;

    // === Constants ===
    
    static constexpr uint8_t MIN_NOTE = 21;        // A0
    static constexpr uint8_t MAX_NOTE = 108;       // C8
    static constexpr uint8_t NUM_DYNAMIC_LEVELS = 8;
    static constexpr double SAMPLE_SECONDS = 12.0; // Length of generated samples

private:
    // === Private members ===
    
    mutable std::mutex accessMutex_;                        // Thread safety
    std::array<SampleSegment, 128> sampleSegments_;        // Storage for all MIDI notes
    double sampleRate_{44100.0};                           // Current sample rate
    Logger& logger_;                                        // Reference to logger
    SampleLibraryStats loadingStats_;                      // Loading statistics
    
    // === Private methods ===
    
    /**
     * @brief Stores loaded sample into RAM-based internal structure
     * 
     * This method copies audio data from LoadedSample into the internal
     * RAM-based storage structure (sampleSegments_). It does NOT save
     * to disk - that's handled by SampleLoader.
     * 
     * @param sample Loaded sample to store in RAM
     */
    void storeSampleRam(const LoadedSample& sample);
    
    /**
     * @brief Validates MIDI note and dynamic level
     */
    bool isValidNote(uint8_t midiNote) const {
        return midiNote >= MIN_NOTE && midiNote <= MAX_NOTE;
    }
    
    bool isValidDynamicLevel(uint8_t dynamicLevel) const {
        return dynamicLevel < NUM_DYNAMIC_LEVELS;
    }
};


===== File: SampleLoader.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLoader.cpp
=====
#include "SampleLoader.h"
#include <cmath>  // Pro std::sin, std::pow atd.

// Definice konstant
const float SampleLoader::DYNAMIC_AMPLITUDES[8] = {0.05f, 0.1f, 0.2f, 0.3f, 0.4f, 0.6f, 0.8f, 1.0f};

/**
 * @brief Konstruktor SampleLoader.
 * Inicializuje format manager a logger.
 */
SampleLoader::SampleLoader(double sampleRate)
    : sampleRate_(sampleRate), logger_(Logger::getInstance())
{
    formatManager_.registerBasicFormats();  // Registrace WAV atd.
}

/**
 * @brief Na캜te kompletn칤 instrument s optimalizovan칳m loading procesem.
 * Iteruje p콏es noty a levels s batch processing pro rychlost.
 */
std::vector<LoadedSample> SampleLoader::loadInstrument(
    const juce::File& instrumentDirectory,
    ProgressCallback progressCallback
) {
    std::vector<LoadedSample> loadedSamples;
    loadingStats_ = LoadingStats{};  // Reset statistik
    
    double startTime = juce::Time::getMillisecondCounterHiRes();
    loadingStats_.totalExpected = (MAX_NOTE - MIN_NOTE + 1) * NUM_DYNAMIC_LEVELS;
    
    // OPTIMALIZACE: P콏edalokace vektoru pro eliminaci realokac칤
    loadedSamples.reserve(loadingStats_.totalExpected);
    
    // Vytvo콏en칤 directory pokud neexistuje
    if (!instrumentDirectory.exists()) {
        if (!instrumentDirectory.createDirectory()) {
            logger_.log("SampleLoader/loadInstrument", "error", 
                       "Cannot create instrument directory: " + instrumentDirectory.getFullPathName());
            return loadedSamples;
        }
        logger_.log("SampleLoader/loadInstrument", "info", 
                   "Created instrument directory");
    }
    
    int processed = 0;
    int batchLogCounter = 0;
    
    // Na캜ten칤 v코ech kombinac칤 nota 칑 dynamic level s optimalizovan칳m reportingem
    for (uint8_t note = MIN_NOTE; note <= MAX_NOTE; ++note) {
        for (uint8_t level = 0; level < NUM_DYNAMIC_LEVELS; ++level) {
            try {
                // Progress callback optimalizace - pouze ka쬯칳ch 50 samples nebo prvn칤/posledn칤
                if (progressCallback && (processed % 50 == 0 || processed < 10 || processed == loadingStats_.totalExpected - 1)) {
                    juce::String status = "Loading note " + juce::String((int)note) + 
                                        " level " + juce::String((int)level) + 
                                        " (" + juce::String(processed + 1) + "/" + juce::String(loadingStats_.totalExpected) + ")";
                    progressCallback(processed, loadingStats_.totalExpected, status);
                }
                
                LoadedSample sample = loadSingleSample(instrumentDirectory, note, level);
                loadedSamples.emplace_back(std::move(sample));  // Pou쬴j move pro p콏esun
                
                // Update statistik
                loadingStats_.totalMemoryUsed += loadedSamples.back().getDataSize();
                if (loadedSamples.back().isGenerated) {
                    loadingStats_.filesGenerated++;
                } else {
                    loadingStats_.filesLoaded++;
                }
                
                ++processed;
                
                // Batch logging ka쬯칳ch 100 samples pro sn칤쬰n칤 noise
                if (++batchLogCounter >= 100) {
                    logger_.log("SampleLoader/loadInstrument", "debug", 
                               "Batch progress: " + juce::String(processed) + "/" + juce::String(loadingStats_.totalExpected) + 
                               " samples processed");
                    batchLogCounter = 0;
                }
                
            } catch (const std::exception& e) {
                logger_.log("SampleLoader/loadInstrument", "error",
                           "Error loading note " + juce::String((int)note) + 
                           " level " + juce::String((int)level) + ": " + juce::String(e.what()));
                ++processed; // Pokra캜ujeme i p콏i chyb캩
            }
        }
    }
    
    // Fin치ln칤 statistiky
    loadingStats_.loadingTimeSeconds = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;
    double samplesPerSecond = (loadingStats_.loadingTimeSeconds > 0) ? (processed / loadingStats_.loadingTimeSeconds) : 0;
    
    logger_.log("SampleLoader/loadInstrument", "info",
               "Loading completed: " + juce::String(loadingStats_.filesLoaded) + " loaded, " +
               juce::String(loadingStats_.filesGenerated) + " generated, " +
               juce::String(loadingStats_.filesSaved) + " saved, " +
               juce::String(loadingStats_.totalMemoryUsed / (1024*1024)) + "MB, " +
               juce::String(loadingStats_.loadingTimeSeconds, 2) + "s" +
               " (avg: " + juce::String(samplesPerSecond, 1) + " samples/sec)");
    
    return loadedSamples;
}

/**
 * @brief Na캜te jeden konkr칠tn칤 sample s optimalizovanou fallback logikou.
 * Pokus칤 se na캜칤st pro target SR, fallback na base SR s resamplingem a ukl치d치n칤m.
 */
LoadedSample SampleLoader::loadSingleSample(
    const juce::File& instrumentDirectory,
    uint8_t midiNote, 
    uint8_t dynamicLevel
) {
    double baseSR = 44100.0;
    double otherSR = (std::abs(sampleRate_ - 44100.0) < 1.0) ? 48000.0 : 44100.0;
    
    // 1. Zkus target SR
    juce::String targetFilename = generateFilename(midiNote, dynamicLevel, sampleRate_);
    juce::File targetFile = instrumentDirectory.getChildFile(targetFilename);
    if (targetFile.exists()) {
        LoadedSample sample = loadWavFile(targetFile, midiNote, dynamicLevel);
        
        // Redukovan칠 logging - pouze ka쬯칳 200. 칰sp캩코n칳 load
        static int successCounter = 0;
        if (++successCounter % 200 == 0) {
            logger_.log("SampleLoader/loadSingleSample", "debug",
                       "Batch: loaded " + juce::String(successCounter) + " files from disk");
        }
        
        return sample;
    }
    
    // 2. Zkus other SR a resampluj
    juce::String otherFilename = generateFilename(midiNote, dynamicLevel, otherSR);
    juce::File otherFile = instrumentDirectory.getChildFile(otherFilename);
    if (otherFile.exists()) {
        LoadedSample otherSample = loadWavFile(otherFile, midiNote, dynamicLevel);  // Na캜ti a resampluj intern캩
        saveGeneratedSample(otherSample, targetFile);  // Ulo resamplovanou verzi pro target
        loadingStats_.filesSaved++;
        
        logger_.log("SampleLoader/loadSingleSample", "info",
                   "Fallback resampling: " + otherFilename + " -> " + targetFilename);
        return otherSample;
    }
    
    // 3. Generuj pro base (44100)
    LoadedSample baseSample = generateSineWave(midiNote, dynamicLevel);  // Generuj pro baseSR
    baseSample.originalSampleRate = baseSR;
    juce::String baseFilename = generateFilename(midiNote, dynamicLevel, baseSR);
    juce::File baseFile = instrumentDirectory.getChildFile(baseFilename);
    saveGeneratedSample(baseSample, baseFile);  // Ulo base
    loadingStats_.filesSaved++;
    
    // 4. Resampluj na 48000 a ulo
    uint32_t resampledLength;
    auto resampledData = resampleIfNeeded(baseSample.audioData.get(), baseSample.lengthSamples, baseSR, resampledLength);
    LoadedSample resampledSample(std::move(baseSample));  // Pou쬴j move konstruktor
    resampledSample.audioData = std::move(resampledData);
    resampledSample.lengthSamples = resampledLength;
    resampledSample.originalSampleRate = 48000.0;
    juce::String resampledFilename = generateFilename(midiNote, dynamicLevel, 48000.0);
    juce::File resampledFile = instrumentDirectory.getChildFile(resampledFilename);
    saveGeneratedSample(resampledSample, resampledFile);
    loadingStats_.filesSaved++;
    
    // Logging pouze pro generovan칠 samples
    static int generateCounter = 0;
    if (++generateCounter % 50 == 0) {
        logger_.log("SampleLoader/loadSingleSample", "info",
                   "Generated " + juce::String(generateCounter) + " sine wave samples");
    }
    
    // Vr치t칤me verzi pro target SR
    return (std::abs(sampleRate_ - baseSR) < 1.0) ? std::move(baseSample) : std::move(resampledSample);
}

/**
 * @brief Na캜te WAV soubor s optimalizovan칳m resampling procesem.
 */
LoadedSample SampleLoader::loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel) {
    FileAnalysis analysis = analyzeWavFile(file);
    if (!analysis.isValid) {
        throw std::runtime_error("Invalid WAV file: " + analysis.errorMessage.toStdString());
    }
    
    LoadedSample result;
    result.midiNote = midiNote;
    result.dynamicLevel = dynamicLevel;
    result.isGenerated = false;
    result.sourcePath = file.getFullPathName();
    result.originalSampleRate = analysis.originalSampleRate;
    result.lengthSamples = analysis.targetLengthSamples;
    
    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    if (!reader) {
        throw std::runtime_error("Cannot create reader for: " + file.getFullPathName().toStdString());
    }
    
    result.numChannels = static_cast<uint8_t>(std::min(2, static_cast<int>(reader->numChannels)));
    
    // OPTIMALIZACE: Jednor치zov치 alokace pro cel칳 v칳sledn칳 buffer
    size_t totalSamples = static_cast<size_t>(analysis.targetLengthSamples) * result.numChannels;
    result.audioData = std::make_unique<float[]>(totalSamples);
    
    if (analysis.needsResampling) {
        // Resampling path s optimalizovan칳m temp bufferem
        juce::AudioBuffer<float> tempBuffer(static_cast<int>(reader->numChannels), 
                                           static_cast<int>(analysis.originalLengthSamples));
        if (!reader->read(tempBuffer.getArrayOfWritePointers(), 
                         static_cast<int>(reader->numChannels), 
                         0, 
                         static_cast<int>(analysis.originalLengthSamples))) {
            throw std::runtime_error("Error reading audio data for resampling");
        }
        
        // OPTIMALIZACE: P콏칤m칳 resampling bez extra alokac칤
        for (int ch = 0; ch < result.numChannels; ++ch) {
            int sourceChannel = std::min(ch, static_cast<int>(reader->numChannels) - 1);
            const float* sourceData = tempBuffer.getReadPointer(sourceChannel);
            
            uint32_t outputLength;
            auto resampledChannel = resampleIfNeeded(
                sourceData, 
                analysis.originalLengthSamples, 
                analysis.originalSampleRate, 
                outputLength
            );
            
            // Kop칤rov치n칤 do interleaved bufferu
            for (uint32_t i = 0; i < outputLength; ++i) {
                result.audioData[i * result.numChannels + ch] = resampledChannel[i];
            }
        }
    } else {
        // Direct loading path bez resamplingu
        juce::AudioBuffer<float> tempBuffer(static_cast<int>(reader->numChannels), 
                                           static_cast<int>(analysis.originalLengthSamples));
        if (!reader->read(tempBuffer.getArrayOfWritePointers(), 
                         static_cast<int>(reader->numChannels), 
                         0, 
                         static_cast<int>(analysis.originalLengthSamples))) {
            throw std::runtime_error("Error reading audio data");
        }
        
        // OPTIMALIZACE: P콏칤m칠 kop칤rov치n칤 do interleaved bufferu
        for (uint32_t i = 0; i < analysis.originalLengthSamples; ++i) {
            for (int ch = 0; ch < result.numChannels; ++ch) {
                int sourceChannel = std::min(ch, static_cast<int>(reader->numChannels) - 1);
                result.audioData[i * result.numChannels + ch] = tempBuffer.getSample(sourceChannel, static_cast<int>(i));
            }
        }
    }
    
    return result;
}

/**
 * @brief Vygeneruje sine wave pro danou notu a dynamic level (pro base SR 44100).
 */
LoadedSample SampleLoader::generateSineWave(uint8_t midiNote, uint8_t dynamicLevel) {
    LoadedSample result;
    result.midiNote = midiNote;
    result.dynamicLevel = dynamicLevel;
    result.isGenerated = true;
    result.originalSampleRate = 44100.0;  // V쬯y pro base SR
    result.lengthSamples = static_cast<uint32_t>(result.originalSampleRate * SAMPLE_SECONDS);
    result.numChannels = 1; // Generovan칠 samples jsou mono
    result.sourcePath = "Generated sine wave";
    
    result.audioData = std::make_unique<float[]>(result.lengthSamples);
    
    double frequency = getFrequencyForNote(midiNote);
    float amplitude = getDynamicAmplitude(dynamicLevel);
    
    const double twoPi = 2.0 * juce::MathConstants<double>::pi;
    const double phaseInc = twoPi * frequency / result.originalSampleRate;
    
    // OPTIMALIZACE: Rychl칠 generov치n칤 bez logging per sample
    for (uint32_t i = 0; i < result.lengthSamples; ++i) {
        double phase = phaseInc * static_cast<double>(i);
        result.audioData[i] = amplitude * static_cast<float>(std::sin(phase));
    }
    
    return result;
}

/**
 * @brief Ulo쮂 vygenerovan칳 sample do .wav souboru s optimalizovan칳m error handlingem.
 */
bool SampleLoader::saveGeneratedSample(const LoadedSample& sample, const juce::File& targetFile) {
    try {
        juce::WavAudioFormat wavFormat;
        std::unique_ptr<juce::FileOutputStream> outputStream(targetFile.createOutputStream());
        
        if (!outputStream) {
            // Redukovan칠 error logging - pouze kdy se opakuje
            static int saveErrorCounter = 0;
            if (++saveErrorCounter % 10 == 1) {  // Log ka쬯ou 10. chybu
                logger_.log("SampleLoader/saveGeneratedSample", "error",
                           "Cannot create output stream (error #" + juce::String(saveErrorCounter) + ")");
            }
            return false;
        }
        
        std::unique_ptr<juce::AudioFormatWriter> writer(
            wavFormat.createWriterFor(
                outputStream.get(),
                sample.originalSampleRate,
                sample.numChannels,   
                16,                   
                {},                   
                0                     
            )
        );
        
        if (!writer) {
            logger_.log("SampleLoader/saveGeneratedSample", "error", "Cannot create WAV writer");
            return false;
        }
        
        outputStream.release(); 
        
        // OPTIMALIZACE: Streamlined channel handling
        if (sample.numChannels == 1) {
            const float* channelData = sample.audioData.get();
            writer->writeFromFloatArrays(&channelData, 1, sample.lengthSamples);
        } else {
            // Rychl칠 de-interleaving pro stereo
            auto leftChannel = std::make_unique<float[]>(sample.lengthSamples);
            auto rightChannel = std::make_unique<float[]>(sample.lengthSamples);
            
            for (uint32_t i = 0; i < sample.lengthSamples; ++i) {
                leftChannel[i] = sample.audioData[i * 2];
                rightChannel[i] = sample.audioData[i * 2 + 1];
            }
            
            const float* channels[] = { leftChannel.get(), rightChannel.get() };
            writer->writeFromFloatArrays(channels, 2, sample.lengthSamples);
        }
        
        writer->flush();
        
        // Redukovan칠 success logging
        static int saveSuccessCounter = 0;
        if (++saveSuccessCounter % 100 == 0) {
            logger_.log("SampleLoader/saveGeneratedSample", "debug",
                       "Batch: saved " + juce::String(saveSuccessCounter) + " generated files");
        }
        
        return true;
        
    } catch (const std::exception& e) {
        logger_.log("SampleLoader/saveGeneratedSample", "error",
                   "Exception while saving: " + juce::String(e.what()));
        return false;
    } catch (...) {
        logger_.log("SampleLoader/saveGeneratedSample", "error", "Unknown exception while saving");
        return false;
    }
}

/**
 * @brief Analyzuje WAV soubor bez na캜ten칤 dat (pro memory planning).
 */
FileAnalysis SampleLoader::analyzeWavFile(const juce::File& file) {
    FileAnalysis analysis;
    
    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    if (!reader) {
        analysis.errorMessage = "Cannot create reader";
        return analysis;
    }
    
    analysis.originalLengthSamples = static_cast<uint32_t>(reader->lengthInSamples);
    analysis.originalSampleRate = reader->sampleRate;
    analysis.needsResampling = (std::abs(analysis.originalSampleRate - sampleRate_) > 1.0);
    
    if (analysis.needsResampling) {
        analysis.targetLengthSamples = static_cast<uint32_t>(
            analysis.originalLengthSamples * (sampleRate_ / analysis.originalSampleRate)
        );
    } else {
        analysis.targetLengthSamples = analysis.originalLengthSamples;
    }
    
    int channels = std::min(2, static_cast<int>(reader->numChannels));
    analysis.memoryRequired = analysis.targetLengthSamples * channels * sizeof(float);
    analysis.isValid = validateFileAnalysis(analysis);
    
    return analysis;
}

/**
 * @brief Validuje v칳sledky file anal칳zy.
 */
bool SampleLoader::validateFileAnalysis(const FileAnalysis& analysis) {
    if (analysis.originalLengthSamples == 0) {
        return false;
    }
    
    if (analysis.originalSampleRate <= 0.0 || analysis.originalSampleRate > 192000.0) {
        return false;
    }
    
    if (analysis.memoryRequired > 1024 * 1024 * 1024) { // Max 1GB per sample
        return false;
    }
    
    return true;
}

/**
 * @brief Provede resampling pokud je pot콏eba s optimalizovanou interpolac칤.
 */
std::unique_ptr<float[]> SampleLoader::resampleIfNeeded(
    const float* sourceData, 
    uint32_t sourceLength, 
    double sourceSampleRate,
    uint32_t& outputLength
) {
    double ratio = sampleRate_ / sourceSampleRate;
    outputLength = static_cast<uint32_t>(sourceLength * ratio);
    
    auto outputData = std::make_unique<float[]>(outputLength);
    
    // OPTIMALIZACE: Rychl치 line치rn칤 interpolace
    for (uint32_t i = 0; i < outputLength; ++i) {
        double sourceIndex = static_cast<double>(i) / ratio;
        uint32_t index1 = static_cast<uint32_t>(sourceIndex);
        uint32_t index2 = std::min(index1 + 1, sourceLength - 1);
        
        double fraction = sourceIndex - static_cast<double>(index1);
        outputData[i] = static_cast<float>(
            sourceData[index1] * (1.0 - fraction) + sourceData[index2] * fraction
        );
    }
    
    return outputData;
}

/**
 * @brief Vr치t칤 default instrument directory.
 */
juce::File SampleLoader::getDefaultInstrumentDirectory() {
    juce::File appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
    juce::File ithacaDir = appDataDir.getChildFile("IthacaPlayer");
    juce::File instrumentDir = ithacaDir.getChildFile("instrument");
    
    return instrumentDir;
}

/**
 * @brief Vygeneruje n치zev souboru podle naming convention.
 */
juce::String SampleLoader::generateFilename(uint8_t midiNote, uint8_t dynamicLevel, double sr) {
    juce::String srSuffix = (std::abs(sr - 44100.0) < 1.0) ? "44" : "48";
    juce::String filename = "m" + juce::String(midiNote).paddedLeft('0', 3) + 
                           "-vel" + juce::String(dynamicLevel) + 
                           "-" + srSuffix + ".wav";
    return filename;
}

/**
 * @brief Parsuje n치zev souboru a extrahuje parametry.
 */
bool SampleLoader::parseFilename(const juce::String& filename, uint8_t& midiNote, uint8_t& dynamicLevel, double& sr) {
    if (!filename.startsWith("m") || !filename.endsWith(".wav")) {
        return false;
    }
    
    juce::StringArray parts = juce::StringArray::fromTokens(filename.upToLastOccurrenceOf(".wav", false, false), "-", "");
    if (parts.size() != 3) {
        return false;
    }
    
    juce::String noteStr = parts[0].substring(1);
    juce::String levelStr = parts[1].substring(3);
    juce::String srStr = parts[2];
    
    int note = noteStr.getIntValue();
    int level = levelStr.getIntValue();
    sr = (srStr == "44") ? 44100.0 : (srStr == "48" ? 48000.0 : 0.0);
    
    if (note < MIN_NOTE || note > MAX_NOTE || level < 0 || level >= NUM_DYNAMIC_LEVELS || sr == 0.0) {
        return false;
    }
    
    midiNote = static_cast<uint8_t>(note);
    dynamicLevel = static_cast<uint8_t>(level);
    
    return true;
}

/**
 * @brief Mapuje velocity na dynamic level.
 */
uint8_t SampleLoader::velocityToDynamicLevel(uint8_t velocity) {
    if (velocity == 0) return 0;
    return std::min(static_cast<uint8_t>(7), static_cast<uint8_t>((velocity - 1) / 16));
}

/**
 * @brief Vr치t칤 amplitude pro dynamic level.
 */
float SampleLoader::getDynamicAmplitude(uint8_t dynamicLevel) {
    if (dynamicLevel >= NUM_DYNAMIC_LEVELS) {
        return DYNAMIC_AMPLITUDES[NUM_DYNAMIC_LEVELS - 1];
    }
    return DYNAMIC_AMPLITUDES[dynamicLevel];
}

/**
 * @brief Vr치t칤 frekvenci pro MIDI notu.
 */
double SampleLoader::getFrequencyForNote(uint8_t midiNote) const {
    return 440.0 * std::pow(2.0, (static_cast<int>(midiNote) - 69) / 12.0);
}


===== File: SampleLoader.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLoader.h
=====
#pragma once

#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_core/juce_core.h>
#include <memory>
#include <functional>
#include <vector>
#include "Logger.h"

/**
 * @struct LoadedSample
 * @brief Kontejner pro jeden na캜ten칳 nebo vygenerovan칳 sample s metadata.
 * Obsahuje audio data, metadata o not캩, dynamic levelu a sample rate.
 */
struct LoadedSample {
    std::unique_ptr<float[]> audioData;    // Audio data (interleaved pro stereo)
    uint32_t lengthSamples;                // D칠lka v samples (per channel)
    uint8_t midiNote;                      // MIDI nota (21-108)
    uint8_t dynamicLevel;                  // Dynamic level (0-7)
    uint8_t numChannels;                   // Po캜et kan치l콢 (1=mono, 2=stereo)
    bool isGenerated;                      // true = vygenerovan칳 sine, false = na캜ten칳 z WAV
    juce::String sourcePath;               // Cesta k source souboru
    double originalSampleRate;             // P콢vodn칤 sample rate (pro debug)
    
    /**
     * @brief V칳choz칤 konstruktor.
     */
    LoadedSample() : lengthSamples(0), midiNote(0), dynamicLevel(0), numChannels(1),
                     isGenerated(false), originalSampleRate(0.0) {}
    
    /**
     * @brief Move konstruktor pro p콏esun vlastnictv칤.
     * @param other Zdrojov칳 objekt pro p콏esun.
     */
    LoadedSample(LoadedSample&& other) noexcept
        : audioData(std::move(other.audioData)),
          lengthSamples(other.lengthSamples),
          midiNote(other.midiNote),
          dynamicLevel(other.dynamicLevel),
          numChannels(other.numChannels),
          isGenerated(other.isGenerated),
          sourcePath(std::move(other.sourcePath)),
          originalSampleRate(other.originalSampleRate) {
        // Reset zdroje po p콏esunu
        other.lengthSamples = 0;
        other.midiNote = 0;
        other.dynamicLevel = 0;
        other.numChannels = 1;
        other.isGenerated = false;
        other.originalSampleRate = 0.0;
    }
    
    /**
     * @brief Move assignment operator pro p콏esun vlastnictv칤.
     * @param other Zdrojov칳 objekt pro p콏esun.
     * @return Reference na tento objekt.
     */
    LoadedSample& operator=(LoadedSample&& other) noexcept {
        if (this != &other) {
            audioData = std::move(other.audioData);
            lengthSamples = other.lengthSamples;
            midiNote = other.midiNote;
            dynamicLevel = other.dynamicLevel;
            numChannels = other.numChannels;
            isGenerated = other.isGenerated;
            sourcePath = std::move(other.sourcePath);
            originalSampleRate = other.originalSampleRate;
            
            // Reset zdroje
            other.lengthSamples = 0;
            other.midiNote = 0;
            other.dynamicLevel = 0;
            other.numChannels = 1;
            other.isGenerated = false;
            other.originalSampleRate = 0.0;
        }
        return *this;
    }
    
    // Kop칤rovac칤 konstruktor a assignment z콢st치vaj칤 smazan칠 (implicitn캩 kv콢li unique_ptr)
    LoadedSample(const LoadedSample&) = delete;
    LoadedSample& operator=(const LoadedSample&) = delete;
    
    /**
     * @brief Vr치t칤 celkovou velikost dat v bytes.
     * @return Velikost v bytes.
     */
    size_t getDataSize() const {
        return lengthSamples * numChannels * sizeof(float);
    }
    
    /**
     * @brief Zkontroluje zda je sample stereo.
     * @return True pokud stereo.
     */
    bool isStereo() const {
        return numChannels == 2;
    }
};

/**
 * @struct FileAnalysis
 * @brief Anal칳za WAV souboru p콏ed na캜ten칤m (pro optimalizaci pam캩ti).
 */
struct FileAnalysis {
    uint32_t originalLengthSamples;
    uint32_t targetLengthSamples;
    double originalSampleRate;
    bool needsResampling;
    size_t memoryRequired;
    bool isValid;
    juce::String errorMessage;
    
    FileAnalysis() : originalLengthSamples(0), targetLengthSamples(0), 
                     originalSampleRate(0.0), needsResampling(false), 
                     memoryRequired(0), isValid(false) {}
};

/**
 * @struct LoadingStats
 * @brief Statistiky loading procesu.
 */
struct LoadingStats {
    int totalExpected;          // O캜ek치van칳 po캜et soubor콢 (88 not 칑 8 level콢)
    int filesLoaded;            // Po캜et na캜ten칳ch WAV soubor콢
    int filesGenerated;         // Po캜et vygenerovan칳ch sine waves
    int filesSaved;             // Po캜et ulo쬰n칳ch generovan칳ch soubor콢
    size_t totalMemoryUsed;     // Celkov치 spot콏eba pam캩ti
    double loadingTimeSeconds;  // Celkov칳 캜as loading
    
    LoadingStats() : totalExpected(0), filesLoaded(0), filesGenerated(0), 
                     filesSaved(0), totalMemoryUsed(0), loadingTimeSeconds(0.0) {}
};

/**
 * @class SampleLoader
 * @brief Spr치vce na캜칤t치n칤/ukl치d치n칤 audio samples s support pro dynamic levels a sample rate verze.
 * 
 * Implementuje hybridn칤 syst칠m:
 * 1. Pokus칤 se na캜칤st WAV soubor z %APPDATA%/IthacaPlayer/instrument/ s SR v n치zvu (nap콏. m060-vel3-44.wav).
 * 2. Pokud neexistuje pro target SR, na캜te z base SR (44100), resampluje a ulo쮂 pro target.
 * 3. Pokud nic neexistuje, vygeneruje sine pro base SR, ulo쮂, resampluje pro 48000 a ulo쮂.
 * 4. Podporuje 8 dynamic levels (vel0-vel7) pro ka쬯ou MIDI notu.
 * 5. Automatick칠 resampling na target sample rate.
 * 6. Zachov치n칤 stereo form치tu pokud existuje.
 */
class SampleLoader
{
public:
    using ProgressCallback = std::function<void(int current, int total, const juce::String& status)>;
    
    /**
     * @brief Konstruktor s target sample rate.
     * @param sampleRate C칤lov칳 sample rate pro v코echny samples.
     */
    explicit SampleLoader(double sampleRate);
    
    /**
     * @brief Na캜te kompletn칤 instrument (v코echny noty 칑 v코echny dynamic levels).
     * @param instrumentDirectory Directory s .wav soubory.
     * @param progressCallback Callback pro progress reporting.
     * @return Vektor na캜ten칳ch samples.
     */
    std::vector<LoadedSample> loadInstrument(
        const juce::File& instrumentDirectory,
        ProgressCallback progressCallback = nullptr
    );
    
    /**
     * @brief Na캜te jeden konkr칠tn칤 sample (bu캞 z souboru nebo vygeneruje).
     * @param instrumentDirectory Directory s .wav soubory.
     * @param midiNote MIDI nota (21-108).
     * @param dynamicLevel Dynamic level (0-7).
     * @return Na캜ten칳 sample.
     */
    LoadedSample loadSingleSample(
        const juce::File& instrumentDirectory,
        uint8_t midiNote, 
        uint8_t dynamicLevel
    );
    
    // === Utility Methods ===
    
    /**
     * @brief Vr치t칤 default instrument directory (%APPDATA%/IthacaPlayer/instrument/).
     * @return Defaultn칤 directory.
     */
    static juce::File getDefaultInstrumentDirectory();
    
    /**
     * @brief Vygeneruje n치zev souboru podle naming convention v캜etn캩 SR.
     * @param midiNote MIDI nota.
     * @param dynamicLevel Dynamic level.
     * @param sr Sample rate (44100 nebo 48000).
     * @return N치zev souboru (nap콏. "m060-vel3-44.wav").
     */
    static juce::String generateFilename(uint8_t midiNote, uint8_t dynamicLevel, double sr);
    
    /**
     * @brief Parsuje n치zev souboru a extrahuje MIDI notu, dynamic level a SR.
     * @param filename N치zev souboru.
     * @param midiNote [out] Extrahovan치 MIDI nota.
     * @param dynamicLevel [out] Extrahovan칳 dynamic level.
     * @param sr [out] Extrahovan칳 sample rate.
     * @return true pokud parsing 칰sp캩코n칳.
     */
    static bool parseFilename(const juce::String& filename, uint8_t& midiNote, uint8_t& dynamicLevel, double& sr);
    
    /**
     * @brief Mapuje velocity (0-127) na dynamic level (0-7).
     * @param velocity MIDI velocity.
     * @return Dynamic level.
     */
    static uint8_t velocityToDynamicLevel(uint8_t velocity);
    
    /**
     * @brief Vr치t칤 amplitude pro dan칳 dynamic level.
     * @param dynamicLevel Dynamic level (0-7).
     * @return Amplitude (0.05f - 1.0f).
     */
    static float getDynamicAmplitude(uint8_t dynamicLevel);
    
    /**
     * @brief Vr치t칤 loading statistiky.
     * @return Reference na statistiky.
     */
    const LoadingStats& getLoadingStats() const { return loadingStats_; }

private:
    double sampleRate_;                           // Target sample rate
    juce::AudioFormatManager formatManager_;     // JUCE audio format manager
    Logger& logger_;                             // Reference na logger
    LoadingStats loadingStats_;                  // Loading statistiky
    
    // === Private Methods ===
    
    /**
     * @brief Analyzuje WAV soubor bez na캜ten칤 dat (pro memory planning).
     * @param file Soubor k anal칳ze.
     * @return Anal칳za souboru.
     */
    FileAnalysis analyzeWavFile(const juce::File& file);
    
    /**
     * @brief Validuje v칳sledky file anal칳zy.
     * @param analysis Anal칳za k validaci.
     * @return True pokud validn칤.
     */
    bool validateFileAnalysis(const FileAnalysis& analysis);
    
    /**
     * @brief Na캜te WAV soubor s optional resampling.
     * @param file Soubor k na캜ten칤.
     * @param midiNote MIDI nota.
     * @param dynamicLevel Dynamic level.
     * @return Na캜ten칳 sample.
     */
    LoadedSample loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel);
    
    /**
     * @brief Vygeneruje sine wave pro danou notu a dynamic level (pro base SR 44100).
     * @param midiNote MIDI nota.
     * @param dynamicLevel Dynamic level.
     * @return Vygenerovan칳 sample.
     */
    LoadedSample generateSineWave(uint8_t midiNote, uint8_t dynamicLevel);
    
    /**
     * @brief Ulo쮂 vygenerovan칳 sample do .wav souboru.
     * @param sample Sample k ulo쬰n칤.
     * @param targetFile C칤lov칳 soubor.
     * @return True pokud 칰sp캩코n칠.
     */
    bool saveGeneratedSample(const LoadedSample& sample, const juce::File& targetFile);
    
    /**
     * @brief Provede resampling pokud je pot콏eba.
     * @param sourceData Zdrojov치 data.
     * @param sourceLength D칠lka zdroje.
     * @param sourceSampleRate Zdrojov칳 SR.
     * @param outputLength [out] D칠lka v칳stupu.
     * @return Resamplovan치 data.
     */
    std::unique_ptr<float[]> resampleIfNeeded(
        const float* sourceData, 
        uint32_t sourceLength, 
        double sourceSampleRate,
        uint32_t& outputLength
    );
    
    /**
     * @brief Vr치t칤 frekvenci pro MIDI notu.
     * @param midiNote MIDI nota.
     * @return Frekvence v Hz.
     */
    double getFrequencyForNote(uint8_t midiNote) const;
    
    // === Constants ===
    
    static constexpr uint8_t MIN_NOTE = 21;        // A0
    static constexpr uint8_t MAX_NOTE = 108;       // C8
    static constexpr uint8_t NUM_DYNAMIC_LEVELS = 8;
    static constexpr double SAMPLE_SECONDS = 12.0; // D칠lka generovan칳ch samples
    
    // Dynamic amplitudes pro jednotliv칠 칰rovn캩
    static const float DYNAMIC_AMPLITUDES[8];
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"
#include "Logger.h"

/**
 * @brief Konstruktor SynthVoice
 */
SynthVoice::SynthVoice()
    : logger_(Logger::getInstance())
{
    reset();
}

/**
 * @brief Spust칤 hlas s automatick칳m v칳b캩rem dynamic levelu
 */
void SynthVoice::start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library)
{
    reset();

    midiNote_ = midiNote;
    velocity_ = velocity;

    // Mapov치n칤 velocity na dynamic level
    uint8_t preferredLevel = library.velocityToDynamicLevel(velocity);
    
    // Najdeme nejlep코칤 dostupn칳 level
    uint8_t bestLevel = findBestAvailableLevel(library, midiNote, preferredLevel);
    
    if (bestLevel == 255) {
        logger_.log("SynthVoice/start", "error", 
                   "콯치dn칳 dostupn칳 dynamic level pro notu " + juce::String((int)midiNote));
        isActive_ = false;
        return;
    }

    currentDynamicLevel_ = bestLevel;
    sampleData_ = library.getSampleData(midiNote, currentDynamicLevel_);
    currentSampleLength_ = library.getSampleLength(midiNote, currentDynamicLevel_);
    
    // Zjist칤me zda je sample stereo
    currentSampleIsStereo_ = library.isSampleStereo(midiNote, currentDynamicLevel_);

    if (!sampleData_ || currentSampleLength_ == 0) {
        logger_.log("SynthVoice/start", "error", 
                   "Neplatn칳 sample pro notu " + juce::String((int)midiNote) + 
                   " level " + juce::String((int)currentDynamicLevel_));
        isActive_ = false;
        return;
    }

    position_ = 0;
    isActive_ = true;

    logger_.log("SynthVoice/start", "debug", 
               "Spu코t캩na nota " + juce::String((int)midiNote) + 
               " velocity=" + juce::String((int)velocity) +
               " level=" + juce::String((int)currentDynamicLevel_) +
               " d칠lka=" + juce::String(currentSampleLength_) +
               " stereo=" + juce::String(currentSampleIsStereo_ ? "ano" : "ne"));
}

void SynthVoice::stop()
{
    isActive_ = false;
    logger_.log("SynthVoice/stop", "debug", 
               "Zastaven voice nota " + juce::String((int)midiNote_));
}

void SynthVoice::reset()
{
    midiNote_ = 0;
    velocity_ = 0;
    currentDynamicLevel_ = 0;
    isActive_ = false;
    sampleData_ = nullptr;
    currentSampleLength_ = 0;
    position_ = 0;
    queue_ = 0;
    currentSampleIsStereo_ = false;
}

/**
 * @brief Renderuje audio bez real-time gain (pre-computed v samples)
 */
void SynthVoice::render(float* outputBuffer, int numSamples, bool isStereo)
{
    if (!isActive_ || sampleData_ == nullptr || currentSampleLength_ == 0)
        return;

    if (currentSampleIsStereo_ && isStereo) {
        // Stereo sample  stereo output
        for (int i = 0; i < numSamples; ++i) {
            if (position_ >= currentSampleLength_) {
                stop();
                break;
            }
            
            // Interleaved stereo data
            outputBuffer[i * 2] += sampleData_[position_ * 2];     // Left
            outputBuffer[i * 2 + 1] += sampleData_[position_ * 2 + 1]; // Right
            ++position_;
        }
    } else if (!currentSampleIsStereo_ && isStereo) {
        // Mono sample  stereo output (duplicate na oba kan치ly)
        for (int i = 0; i < numSamples; ++i) {
            if (position_ >= currentSampleLength_) {
                stop();
                break;
            }
            
            float sample = sampleData_[position_];
            outputBuffer[i * 2] += sample;     // Left
            outputBuffer[i * 2 + 1] += sample; // Right
            ++position_;
        }
    } else {
        // Mono sample  mono output NEBO stereo뇴ono (mix)
        for (int i = 0; i < numSamples; ++i) {
            if (position_ >= currentSampleLength_) {
                stop();
                break;
            }
            
            if (currentSampleIsStereo_) {
                // Stereo sample  mono output (mix L+R)
                float left = sampleData_[position_ * 2];
                float right = sampleData_[position_ * 2 + 1];
                outputBuffer[i] += (left + right) * 0.5f;
            } else {
                // Mono sample  mono output
                outputBuffer[i] += sampleData_[position_];
            }
            ++position_;
        }
    }
}

/**
 * @brief Najde nejlep코칤 dostupn칳 dynamic level
 */
uint8_t SynthVoice::findBestAvailableLevel(const SampleLibrary& library, uint8_t midiNote, uint8_t preferredLevel)
{
    // 1. Zkus preferovan칳 level
    if (library.isNoteAvailable(midiNote, preferredLevel)) {
        return preferredLevel;
    }

    // 2. Zkus bl칤zk칠 levely (sm캩rem dol콢 i nahoru)
    for (int offset = 1; offset < 8; ++offset) {
        // Zkus ni쮄뫆 level
        if (preferredLevel >= offset) {
            // Explicitn칤 cast pro odstran캩n칤 warning C4244
            uint8_t lowerLevel = static_cast<uint8_t>(preferredLevel - offset);
            if (library.isNoteAvailable(midiNote, lowerLevel)) {
                logger_.log("SynthVoice/findBestAvailableLevel", "debug",
                           "Fallback na ni쮄뫆 level " + juce::String((int)lowerLevel) + 
                           " m칤sto " + juce::String((int)preferredLevel));
                return lowerLevel;
            }
        }
        
        // Zkus vy코코칤 level
        // Explicitn칤 cast pro odstran캩n칤 warning C4244
        uint8_t higherLevel = static_cast<uint8_t>(preferredLevel + offset);
        if (higherLevel < 8 && library.isNoteAvailable(midiNote, higherLevel)) {
            logger_.log("SynthVoice/findBestAvailableLevel", "debug",
                       "Fallback na vy코코칤 level " + juce::String((int)higherLevel) + 
                       " m칤sto " + juce::String((int)preferredLevel));
            return higherLevel;
        }
    }

    // 3. 콯치dn칳 level nen칤 dostupn칳
    return 255;
}

// ======================== VoiceManager =========================

/**
 * @brief Konstruktor VoiceManager
 */
VoiceManager::VoiceManager(const SampleLibrary& library, int numVoices)
    : logger_(Logger::getInstance()), sampleLibrary_(library)
{
    voices_.reserve(numVoices);
    for (int i = 0; i < numVoices; ++i) {
        voices_.emplace_back(std::make_unique<SynthVoice>());
        voices_.back()->setQueue(0);
    }

    logger_.log("VoiceManager/constructor", "info", 
               "VoiceManager vytvo콏en s " + juce::String(numVoices) + " hlasy pro dynamic levels");
}

/**
 * @brief Zpracuje MIDI ud치losti z MidiStateManager
 */
void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // Zpracov치n칤 NOTE ON
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOn(static_cast<uint8_t>(ch));
            if (raw == 255) break;
            
            uint8_t note = raw;
            uint8_t vel = midiState.getVelocity(static_cast<uint8_t>(ch), note);
            startVoice(note, vel);
        }
    }

    // Zpracov치n칤 NOTE OFF
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOff(static_cast<uint8_t>(ch));
            if (raw == 255) break;
            
            uint8_t note = raw;
            stopVoice(note);
        }
    }
}

/**
 * @brief Generuje audio mixem hlas콢 s stereo support
 */
void VoiceManager::generateAudio(float* buffer, int numSamples)
{
    if (buffer == nullptr || numSamples <= 0) return;

    // Detekujeme zda buffer vypad치 jako stereo (heuristika)
    // V re치ln칠 implementaci by to m캩l b칳t parametr
    bool isStereoOutput = true; // P콏edpokl치d치me stereo output
    
    // Mix v코ech aktivn칤ch hlas콢
    for (auto& v : voices_) {
        if (v->isActive()) {
            v->render(buffer, numSamples, isStereoOutput);
        }
    }
}

/**
 * @brief Housekeeping a statistiky
 */
void VoiceManager::refresh()
{
    ++refreshCounter_;
    
    // Reset voice stealing counter
    voicesStolenSinceLastRefresh_ = 0;
    
    // Aktualizace statistik
    updateStatistics();
    
    // Periodick칠 logov치n칤
    if (refreshCounter_ % PERIODIC_LOG_INTERVAL == 0) {
        logPeriodicStatus();
    }
}

/**
 * @brief Spust칤 hlas s enhanced voice stealing
 */
void VoiceManager::startVoice(uint8_t midiNote, uint8_t velocity)
{
    // Nejprve hledej existuj칤c칤 voice pro tuto notu
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->start(midiNote, velocity, sampleLibrary_);
            mixleQueue(v->getQueue());
            v->setQueue(static_cast<uint8_t>(voices_.size() - 1));
            return;
        }
    }

    // Hledej volnou voice s nejvy코코칤m queue
    SynthVoice* candidate = nullptr;
    uint8_t maxQueue = 0;
    for (auto& v : voices_) {
        if (!v->isActive() && v->getQueue() >= maxQueue) {
            candidate = v.get();
            maxQueue = v->getQueue();
        }
    }

    // Pokud nen칤 voln치, pou쬴j voice stealing
    if (!candidate) {
        candidate = findVoiceStealingCandidate();
        if (candidate) {
            voicesStolenSinceLastRefresh_++;
            logger_.log("VoiceManager/startVoice", "debug", 
                       "Voice stealing pro notu " + juce::String((int)midiNote) + 
                       " (ukradena nota " + juce::String((int)candidate->getNote()) + ")");
        }
    }

    if (candidate) {
        mixleQueue(candidate->getQueue());
        candidate->start(midiNote, velocity, sampleLibrary_);
        candidate->setQueue(static_cast<uint8_t>(voices_.size() - 1));
    } else {
        logger_.log("VoiceManager/startVoice", "warn", 
                   "Nelze naj칤t voice pro notu " + juce::String((int)midiNote));
    }
}

/**
 * @brief Zastav칤 hlas pro danou notu
 */
void VoiceManager::stopVoice(uint8_t midiNote)
{
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->stop();
            mixleQueue(v->getQueue());
            v->setQueue(0);
            return;
        }
    }
}

/**
 * @brief Enhanced voice stealing algorithm
 */
SynthVoice* VoiceManager::findVoiceStealingCandidate()
{
    SynthVoice* candidate = nullptr;
    uint8_t maxQueue = 0;
    float maxProgress = 0.0f;
    
    // Najdi voice s nejvy코코칤m queue (nejstar코칤) a nejvy코코칤m progress
    for (auto& v : voices_) {
        if (v->isActive()) {
            if (v->getQueue() > maxQueue || 
                (v->getQueue() == maxQueue && v->getProgress() > maxProgress)) {
                candidate = v.get();
                maxQueue = v->getQueue();
                maxProgress = v->getProgress();
            }
        }
    }
    
    return candidate;
}

/**
 * @brief P콏euspo콏치d치 queue priorit
 */
void VoiceManager::mixleQueue(uint8_t queueNumber) 
{
    for (auto& v : voices_) {
        if (v->getQueue() == queueNumber) {
            v->setQueue(0);  // Posun na dno
        } else if (v->getQueue() > queueNumber) {
            v->setQueue(v->getQueue() - 1);  // Posun dol콢
        } else {
            v->setQueue(v->getQueue() + 1);  // Posun nahoru
        }
    }
}

/**
 * @brief Vr치t칤 po캜et aktivn칤ch hlas콢
 */
int VoiceManager::getActiveVoiceCount() const
{
    int count = 0;
    for (const auto& voice : voices_) {
        if (voice->isActive()) ++count;
    }
    return count;
}

/**
 * @brief Vr치t칤 po캜et hlas콢 podle dynamic level콢
 */
std::array<int, 8> VoiceManager::getVoiceCountByDynamicLevel() const
{
    std::array<int, 8> counts{};
    
    for (const auto& voice : voices_) {
        if (voice->isActive()) {
            uint8_t level = voice->getDynamicLevel();
            if (level < 8) {
                counts[level]++;
            }
        }
    }
    
    return counts;
}

/**
 * @brief Vr치t칤 detailn칤 statistiky
 */
VoiceManager::VoiceStats VoiceManager::getVoiceStats() const
{
    return lastStats_;
}

/**
 * @brief Aktualizuje statistiky
 */
void VoiceManager::updateStatistics() const
{
    lastStats_.totalVoices = static_cast<int>(voices_.size());
    lastStats_.activeVoices = getActiveVoiceCount();
    lastStats_.inactiveVoices = lastStats_.totalVoices - lastStats_.activeVoices;
    lastStats_.dynamicLevelCount = getVoiceCountByDynamicLevel();
    lastStats_.voicesStolenThisRefresh = voicesStolenSinceLastRefresh_;
    
    // Pr콢m캩rn칳 progress
    float totalProgress = 0.0f;
    int activeCount = 0;
    for (const auto& voice : voices_) {
        if (voice->isActive()) {
            totalProgress += voice->getProgress();
            activeCount++;
        }
    }
    lastStats_.averageProgress = (activeCount > 0) ? (totalProgress / activeCount) : 0.0f;
}

/**
 * @brief Loguje periodick칳 status
 */
void VoiceManager::logPeriodicStatus()
{
    const auto& stats = lastStats_;
    
    juce::String dynamicLevelInfo;
    for (int i = 0; i < 8; ++i) {
        if (stats.dynamicLevelCount[i] > 0) {
            dynamicLevelInfo += "L" + juce::String(i) + ":" + juce::String(stats.dynamicLevelCount[i]) + " ";
        }
    }
    
    logger_.log("VoiceManager/periodicStatus", "info",
               "Voices: " + juce::String(stats.activeVoices) + "/" + juce::String(stats.totalVoices) + 
               " active, avg progress: " + juce::String(stats.averageProgress * 100.0f, 1) + "%" +
               " dynamic levels: " + dynamicLevelInfo);
}


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <cstdint>
#include <memory>
#include <vector>
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "Logger.h"

/**
 * @class SynthVoice
 * @brief Roz코칤콏en칳 voice renderer s podporou dynamic levels
 * 
 * Nov칠 vlastnosti:
 * - Dynamic level selection based on velocity
 * - Variable sample lengths per dynamic level
 * - No real-time gain calculation (pre-computed in samples)
 * - Improved voice lifecycle management
 */
class SynthVoice
{
public:
    SynthVoice();

    /**
     * @brief Spust칤 hlas s automatick칳m v칳b캩rem dynamic levelu
     * @param midiNote MIDI nota
     * @param velocity Velocity (automaticky mapov치no na dynamic level)
     * @param library Reference na SampleLibrary
     */
    void start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library);

    /**
     * @brief Zastav칤 hlas (deaktivuje ho)
     */
    void stop();

    /**
     * @brief Resetuje hlas do v칳choz칤ho stavu
     */
    void reset();

    /**
     * @brief Renderuje audio bez real-time gain (pre-computed v samples)
     * @param outputBuffer Ukazatel na buffer
     * @param numSamples Po캜et sampl콢 k renderov치n칤
     * @param isStereo Zda je output buffer stereo (pro stereo rendering)
     */
    void render(float* outputBuffer, int numSamples, bool isStereo = false);

    // === Gettery ===
    
    bool isActive() const { return isActive_; }
    uint8_t getNote() const { return midiNote_; }
    uint8_t getVelocity() const { return velocity_; }
    uint8_t getDynamicLevel() const { return currentDynamicLevel_; }
    uint8_t getQueue() const { return queue_; }
    uint32_t getPosition() const { return position_; }
    uint32_t getSampleLength() const { return currentSampleLength_; }
    
    void setQueue(uint8_t queue) { queue_ = queue; }

    /**
     * @brief Vr치t칤 progress jako procenta (0.0-1.0)
     */
    float getProgress() const {
        return (currentSampleLength_ > 0) ? 
               static_cast<float>(position_) / static_cast<float>(currentSampleLength_) : 0.0f;
    }

private:
    Logger& logger_;                    // Reference na logger

    // === Voice State ===
    uint8_t midiNote_{0};              // Aktu치ln칤 MIDI nota
    uint8_t velocity_{0};              // Velocity
    uint8_t currentDynamicLevel_{0};   // Aktu치ln칤 dynamic level (0-7)
    bool isActive_{false};             // Stav aktivity

    // === Sample Data ===
    const float* sampleData_{nullptr}; // Ukazatel na data vzorku
    uint32_t currentSampleLength_{0};  // D칠lka aktu치ln칤ho sample (variable per dynamic level)
    uint32_t position_{0};             // Aktu치ln칤 pozice v vzorku
    bool currentSampleIsStereo_{false}; // Zda je aktu치ln칤 sample stereo

    // === Voice Management ===
    uint8_t queue_{0};                 // Prioritn칤 queue pro stealing (0 = dno, vy코코칤 = top)
    
    /**
     * @brief Najde nejlep코칤 dostupn칳 dynamic level pro danou notu
     * @param library Reference na SampleLibrary
     * @param midiNote MIDI nota
     * @param preferredLevel Preferovan칳 level
     * @return Nejlep코칤 dostupn칳 level nebo 255 pokud 쮂멳n칳
     */
    uint8_t findBestAvailableLevel(const SampleLibrary& library, uint8_t midiNote, uint8_t preferredLevel);
};

/**
 * @class VoiceManager
 * @brief Roz코칤콏en칳 voice manager s podporou dynamic levels a lep코칤 diagnostikou
 * 
 * Nov칠 vlastnosti:
 * - Automatic dynamic level selection
 * - Enhanced voice stealing algorithm
 * - Real-time voice statistics
 * - Fallback mechanism pro missing dynamic levels
 */
class VoiceManager
{
public:
    /**
     * @brief Konstruktor s referenc칤 na SampleLibrary
     * @param library Reference na SampleLibrary
     * @param numVoices Po캜et hlas콢 (v칳choz칤 16)
     */
    VoiceManager(const SampleLibrary& library, int numVoices = 16);

    ~VoiceManager() = default;

    /**
     * @brief Zpracuje MIDI ud치losti z MidiStateManager (note-on/off)
     * @param midiState Reference na MidiStateManager
     */
    void processMidiEvents(MidiStateManager& midiState);

    /**
     * @brief Generuje audio mixem v코ech aktivn칤ch hlas콢
     * @param buffer Ukazatel na audio buffer
     * @param numSamples Po캜et sampl콢
     */
    void generateAudio(float* buffer, int numSamples);

    /**
     * @brief Housekeeping a statistiky
     */
    void refresh();

    // === Statistics & Diagnostics ===
    
    /**
     * @brief Vr치t칤 po캜et aktivn칤ch hlas콢
     */
    int getActiveVoiceCount() const;
    
    /**
     * @brief Vr치t칤 po캜et hlas콢 podle dynamic level콢
     */
    std::array<int, 8> getVoiceCountByDynamicLevel() const;
    
    /**
     * @brief Vr치t칤 statistiky voice usage
     */
    struct VoiceStats {
        int totalVoices;
        int activeVoices;
        int inactiveVoices;
        std::array<int, 8> dynamicLevelCount;
        float averageProgress;
        int voicesStolenThisRefresh;
        
        VoiceStats() : totalVoices(0), activeVoices(0), inactiveVoices(0), 
                       dynamicLevelCount{}, averageProgress(0.0f), voicesStolenThisRefresh(0) {}
    };
    
    VoiceStats getVoiceStats() const;

private:
    Logger& logger_;                                        // Reference na logger
    const SampleLibrary& sampleLibrary_;                   // Povinn치 reference na vzorky
    std::vector<std::unique_ptr<SynthVoice>> voices_;      // Kolekce hlas콢
    
    // === Statistics ===
    mutable VoiceStats lastStats_;                         // Cache posledn칤ch statistik
    int voicesStolenSinceLastRefresh_{0};                  // Po캜칤tadlo voice stealing
    
    /**
     * @brief Spust칤 hlas pro danou notu s automatic dynamic level selection
     * @param midiNote MIDI nota
     * @param velocity Velocity
     */
    void startVoice(uint8_t midiNote, uint8_t velocity);

    /**
     * @brief Zastav칤 hlas pro danou notu
     * @param midiNote MIDI nota
     */
    void stopVoice(uint8_t midiNote);

    /**
     * @brief P콏euspo콏치d치 queue priorit (Enhanced version)
     * @param queueNumber 캛칤slo queue k mixlov치n칤
     */
    void mixleQueue(uint8_t queueNumber);
    
    /**
     * @brief Najde nejlep코칤 kandid치t pro voice stealing
     * @return Ukazatel na voice nebo nullptr
     */
    SynthVoice* findVoiceStealingCandidate();
    
    /**
     * @brief Aktualizuje statistiky (volan칠 z refresh())
     */
    void updateStatistics() const;
    
    /**
     * @brief Loguje periodic voice status (ka쬯칳ch N refresh cykl콢)
     */
    void logPeriodicStatus();
    
    // === Constants ===
    static constexpr int PERIODIC_LOG_INTERVAL = 1000;    // Log ka쬯칳ch 1000 refresh cykl콢
    mutable int refreshCounter_{0};                        // Po캜칤tadlo refresh cykl콢
};



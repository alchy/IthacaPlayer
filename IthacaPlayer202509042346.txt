===== File: CMakeLists.txt =====
Path: C:\Users\jindr\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        SampleLoader.h   # P콏idan칳 header pro SampleLoader
        SampleLoader.cpp # P콏idan칳 source pro SampleLoader
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\jindr\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\jindr\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"
#include <sstream>

std::atomic<bool> Logger::loggingEnabled{true};

/**
 * @brief Konstruktor Logger.
 * Inicializuje singleton a p콏id치v치 file logger.
 * Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer.
 */
Logger::Logger() {
    // Oprava: Inicializace file loggeru (um칤st캩n칤 v default app log slo쬮e)
    fileLogger_ = std::unique_ptr<juce::FileLogger>(
        juce::FileLogger::createDefaultAppLogger("IthacaPlayer", "IthacaPlayer.log", "Start IthacaPlayer logu", 0)
    );
    DBG("Logger initialized.");  // P콏idan칳 debug pro konzoli
}

/**
 * @brief Vr치t칤 singleton instanci Logger.
 * @return Reference na instanci
 */
Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

/**
 * @brief Loguje zpr치vu s 캜asov칳m raz칤tkem, komponentou a z치va쬹ost칤.
 * @param component Komponenta (nap콏. t콏칤da/metoda)
 * @param severity Z치va쬹ost (info, debug, error, warn)
 * @param message Zpr치va
 * Oprava: P콏id치n z치pis do fileLogger, pokud existuje.
 */
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled.load(std::memory_order_relaxed))
        return;

    try {
        auto now = juce::Time::getCurrentTime();
        juce::String timestamp = now.formatted("%Y-%m-%d %H:%M:%S");
        juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

        pushToLogQueue(logEntry);
        scheduleGUIUpdate();

        // Oprava: Z치pis do souboru, pokud fileLogger existuje
        if (fileLogger_ != nullptr) {
            fileLogger_->logMessage(logEntry);
        }
    } catch (...) {
        // Bezpe캜n칳 fallback p콏i chyb캩
        DBG("Logger error in log method.");  // P콏idan칳 debug pro chyby
    }
}

void Logger::pushToLogQueue(const juce::String& logEntry)
{
    std::lock_guard<std::mutex> lock(logMutex_);

    uint8_t writeIndex = logQueue_.writeIndex.load();
    uint8_t currentCount = logQueue_.count.load();

    logQueue_.logs[writeIndex] = logEntry;
    logQueue_.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));

    if (currentCount < 256) {
        logQueue_.count.store(currentCount + 1);
    } else {
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + 1);
    }

    if (logQueue_.count.load() > MAX_LOG_ENTRIES) {
        uint8_t excess = logQueue_.count.load() - MAX_LOG_ENTRIES;
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + excess);
        logQueue_.count.store(MAX_LOG_ENTRIES);
    }
}

void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    std::lock_guard<std::mutex> lock(editorMutex_);
    editorPtr_ = ed;
    DBG("Editor set in Logger.");  // P콏idan칳 debug pro nastaven칤 editoru
}

void Logger::scheduleGUIUpdate()
{
    juce::MessageManager::callAsync([this]() {
        std::lock_guard<std::mutex> lock(editorMutex_);
        if (editorPtr_ != nullptr) {
            editorPtr_->updateLogDisplay();
        }
    });
}

juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}

juce::StringArray Logger::getCurrentLogs() const
{
    std::lock_guard<std::mutex> lock(logMutex_);

    juce::StringArray result;
    uint8_t currentCount = logQueue_.count.load();
    uint8_t readIndex = logQueue_.readIndex;

    for (uint8_t i = 0; i < currentCount; ++i) {
        uint8_t index = static_cast<uint8_t>(readIndex + i);
        result.add(logQueue_.logs[index]);
    }
    return result;
}

void Logger::clearLogs()
{
    std::lock_guard<std::mutex> lock(logMutex_);
    logQueue_.writeIndex.store(0);
    logQueue_.count.store(0);
    logQueue_.readIndex = 0;
    for (auto& log : logQueue_.logs) {
        log = juce::String();
    }
    DBG("Logs cleared.");  // P콏idan칳 debug pro 캜i코t캩n칤 log콢
}

size_t Logger::getLogCount() const
{
    return logQueue_.count.load(std::memory_order_relaxed);
}


===== File: Logger.h =====
Path: C:\Users\jindr\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>
#include <mutex>
#include <array>
#include <memory>

#define MAX_LOG_ENTRIES 100

class AudioPluginAudioProcessorEditor;

class Logger
{
public:
    static Logger& getInstance();

    void log(const juce::String& component, const juce::String& severity, const juce::String& message);
    static std::atomic<bool> loggingEnabled;

    void setEditor(AudioPluginAudioProcessorEditor* ed);

    juce::StringArray getLogBuffer() const;
    void clearLogs();
    size_t getLogCount() const;

private:
    Logger();
    ~Logger() = default;

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    struct LogQueue {
        std::array<juce::String, 256> logs;
        std::atomic<uint8_t> writeIndex{0};
        std::atomic<uint8_t> count{0};
        uint8_t readIndex{0};
    };

    LogQueue logQueue_;

    mutable std::mutex logMutex_;
    mutable std::mutex editorMutex_;

    // Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer
    AudioPluginAudioProcessorEditor* editorPtr_{nullptr};

    void pushToLogQueue(const juce::String& logEntry);
    juce::StringArray getCurrentLogs() const;
    void scheduleGUIUpdate();

    // Oprava: Pou쬴t unique_ptr m칤sto deprecated ScopedPointer
    std::unique_ptr<juce::FileLogger> fileLogger_;
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\jindr\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"
#include <algorithm>
#include <cassert>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244)  // Varov치n칤 konverze pro MIDI hodnoty
#endif

/**
 * @brief Konstruktor MidiStateManager.
 * Inicializuje logger, resetuje queue a nastav칤 v칳choz칤 hodnoty controller콢 podle MIDI standardu.
 */
MidiStateManager::MidiStateManager()
    : logger_(Logger::getInstance())
{
    logger_.log("MidiStateManager/constructor", "info", "=== INICIALIZACE MIDI STATE MANAGER ===");
    
    // Inicializace aktivn칤ch not
    for (auto& note : activeNotes_) {
        note.store(false);  // V코echny noty neaktivn칤
    }
    
    // Inicializace MIDI controller hodnot
    for (int channel = 0; channel < MIDI_CHANNELS; ++channel) {
        for (int controller = 0; controller < 128; ++controller) {
            controllerValues_[channel][controller] = 0;  // V칳choz칤 0
        }
        
        // V칳choz칤 hodnoty pro standardn칤 controllery
        controllerValues_[channel][7] = 100;   // Volume (v칳choz칤 vysok치)
        controllerValues_[channel][10] = 64;   // Pan (st콏ed)
        controllerValues_[channel][11] = 127;  // Expression (max)
        controllerValues_[channel][64] = 0;    // Sustain pedal (vypnut칳)
        controllerValues_[channel][91] = 0;    // Reverb (vypnut칳)
        controllerValues_[channel][93] = 0;    // Chorus (vypnut칳)
    }
    
    // Reset v코ech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    logger_.log("MidiStateManager/constructor", "info", "Inicializace dokon캜ena.");
    DBG("MidiStateManager initialized.");  // P콏idan칳 debug pro konzoli
}

/**
 * @brief Resetuje NoteQueue na v칳choz칤 stav.
 * Nastav칤 indexy a po캜et na 0, nemus칤 캜istit array (p콏eps치no p콏i pou쬴t칤).
 */
void MidiStateManager::NoteQueue::reset() {
    writeIndex.store(0);
    count.store(0);
    readIndex = 0;
}

/**
 * @brief P콏id치 note-on do queue a aktualizuje stav aktivn칤 noty a velocity.
 * @param channel MIDI kan치l (0-15)
 * @param note MIDI nota (0-127)
 * @param velocity Velocity (0-127)
 */
void MidiStateManager::pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;  // Bezpe캜nostn칤 kontrola
    
    pushToQueue(noteOnQueues_[channel], note);
    activeNotes_[note].store(true);
    velocities_[channel][note] = velocity;
    
    logger_.log("MidiStateManager/pushNoteOn", "debug", "NoteOn kan치l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief P콏id치 note-off do queue a deaktivuje notu.
 * @param channel MIDI kan치l (0-15)
 * @param note MIDI nota (0-127)
 */
void MidiStateManager::pushNoteOff(uint8_t channel, uint8_t note) {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return;
    
    pushToQueue(noteOffQueues_[channel], note);
    activeNotes_[note].store(false);
    
    logger_.log("MidiStateManager/pushNoteOff", "debug", "NoteOff kan치l " + juce::String(channel) + ", nota " + juce::String(note));
}

/**
 * @brief Vyt치hne note-on z queue pro dan칳 kan치l.
 * @param channel MIDI kan치l
 * @return Nota (0-127) nebo 255 pokud pr치zdn치 queue (游댢 Zm캩na: Pro odstran캩n칤 warningu C4244)
 */
uint8_t MidiStateManager::popNoteOn(uint8_t channel) {  // 游댢 Zm캩na: Zm캩n캩no na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOnQueues_[channel]);
}

/**
 * @brief Vyt치hne note-off z queue pro dan칳 kan치l.
 * @param channel MIDI kan치l
 * @return Nota (0-127) nebo 255 pokud pr치zdn치 queue (游댢 Zm캩na: Pro odstran캩n칤 warningu C4244)
 */
uint8_t MidiStateManager::popNoteOff(uint8_t channel) {  // 游댢 Zm캩na: Zm캩n캩no na uint8_t
    if (channel >= MIDI_CHANNELS) return 255;
    return popFromQueue(noteOffQueues_[channel]);
}

/**
 * @brief Zkontroluje, zda je nota aktivn칤.
 * @param channel MIDI kan치l
 * @param note MIDI nota
 * @return True pokud aktivn칤
 */
bool MidiStateManager::isNoteActive(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return false;
    return activeNotes_[note].load();
}

/**
 * @brief Vr치t칤 velocity aktivn칤 noty.
 * @param channel MIDI kan치l
 * @param note MIDI nota
 * @return Velocity (0-127)
 */
uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t note) const {
    if (channel >= MIDI_CHANNELS || note >= MIDI_NOTES) return 0;
    return velocities_[channel][note];
}

/**
 * @brief Nastav칤 hodnotu MIDI controlleru.
 * @param channel MIDI kan치l
 * @param controller 캛칤slo controlleru (0-127)
 * @param value Hodnota (0-127)
 */
void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value) {
    if (channel >= MIDI_CHANNELS || controller > 127) return;
    controllerValues_[channel][controller] = value;
}

/**
 * @brief Vr치t칤 hodnotu MIDI controlleru.
 * @param channel MIDI kan치l
 * @param controller 캛칤slo controlleru
 * @return Hodnota (0-127)
 */
uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const {
    if (channel >= MIDI_CHANNELS || controller > 127) return 0;
    return controllerValues_[channel][controller];
}

/**
 * @brief P콏id치 prvek do circular queue s automatick칳m p콏ete캜en칤m.
 * @param queue Reference na queue
 * @param note Hodnota k p콏id치n칤
 * Zjednodu코eno: Pou쮂셨치 modulo pro index, atomic operace pro count.
 */
void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() >= 256) {
        logger_.log("MidiStateManager/pushToQueue", "warn", "Queue pln치 - zpr치va ztracena");
        return;  // Zachov치no varov치n칤 p콏i pln칠 queue
    }

    uint8_t index = queue.writeIndex.load();
    queue.notes[index] = note;
    queue.writeIndex.store((index + 1) % 256);  // Automatick칠 p콏ete캜en칤 modulo 256
    queue.count.fetch_add(1);  // Atomic inkrement po캜tu
}

/**
 * @brief Vyt치hne prvek z circular queue.
 * @param queue Reference na queue
 * @return Hodnota nebo 255 p콏i pr치zdn칠 queue (游댢 Zm캩na: Pro konzistenci s uint8_t)
 */
uint8_t MidiStateManager::popFromQueue(NoteQueue& queue) {
    std::lock_guard<std::mutex> lock(queue.mutex);

    if (queue.count.load() == 0) {
        return 255;  // 游댢 Zm캩na: 255 m칤sto 0xff pro uint8_t (pr치zdn치 queue)
    }

    uint8_t note = queue.notes[queue.readIndex];
    queue.readIndex = (queue.readIndex + 1) % 256;  // Modulo pro p콏ete캜en칤
    queue.count.fetch_sub(1);  // Atomic dekrement po캜tu
    return note;
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\jindr\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <array>
#include <atomic>
#include <mutex>
#include "Logger.h"

// Konstanty pro MIDI rozsahy
constexpr uint8_t MIDI_NOTES = 128;  // Standardn칤 po캜et MIDI not (0-127)
constexpr uint8_t MIDI_CHANNELS = 16;  // Standardn칤 po캜et MIDI kan치l콢

/**
 * @class MidiStateManager
 * @brief Spravuje stav MIDI zpr치v, v캜etn캩 aktivn칤ch not, velocity, controller콢 a queue pro note-on/off.
 * 
 * Tato t콏칤da je thread-safe d칤ky mutex콢m a atomic prom캩nn칳m. Poskytuje metody pro push/pop MIDI ud치lost칤,
 * sledov치n칤 aktivn칤ch not a controller hodnot. Inicializuje v칳choz칤 hodnoty controller콢 podle MIDI standardu.
 */
class MidiStateManager
{
public:
    MidiStateManager();

    // Metody pro note-on/off
    void pushNoteOn(uint8_t channel, uint8_t note, uint8_t velocity);  // P콏id치 note-on do queue a aktualizuje stav
    void pushNoteOff(uint8_t channel, uint8_t note);  // P콏id치 note-off do queue a aktualizuje stav
    uint8_t popNoteOn(uint8_t channel);  // 游댢 Zm캩na: Zm캩n캩no na uint8_t, vrac칤 255 pokud pr치zdn치 (pro odstran캩n칤 warningu C4244)
    uint8_t popNoteOff(uint8_t channel);  // 游댢 Zm캩na: Zm캩n캩no na uint8_t, vrac칤 255 pokud pr치zdn치

    // Metody pro aktivn칤 noty
    bool isNoteActive(uint8_t channel, uint8_t note) const;  // Zkontroluje, zda je nota aktivn칤
    uint8_t getVelocity(uint8_t channel, uint8_t note) const;  // Vr치t칤 velocity aktivn칤 noty

    // Metody pro MIDI controllery
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);  // Nastav칤 hodnotu controlleru
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;  // Vr치t칤 hodnotu controlleru

private:
    Logger& logger_;  // Reference na logger pro logov치n칤 ud치lost칤

    // Struktura pro circular buffer queue (zachov치na pro efektivitu a thread-safety)
    struct NoteQueue {
        std::array<uint8_t, 256> notes;  // Circular buffer o velikosti 256 (magick칠 캜칤slo zachov치no)
        std::atomic<uint8_t> writeIndex{0};  // Atomic index pro z치pis (thread-safe)
        std::atomic<uint8_t> count{0};  // Po캜et prvk콢 v queue (atomic pro bezpe캜n칳 p콏칤stup)
        uint8_t readIndex{0};  // Index pro 캜ten칤 (chr치n캩n mutexem)
        mutable std::mutex mutex;  // Mutex pro synchronizaci p콏칤stupu

        void reset();  // Resetuje queue na v칳choz칤 stav
    };

    // Queue pro note-on a note-off pro ka쬯칳 kan치l
    std::array<NoteQueue, MIDI_CHANNELS> noteOnQueues_;
    std::array<NoteQueue, MIDI_CHANNELS> noteOffQueues_;

    // Pole pro aktivn칤 noty a velocity
    std::array<std::atomic<bool>, MIDI_NOTES> activeNotes_;  // Atomic pro thread-safety
    std::array<std::array<uint8_t, MIDI_NOTES>, MIDI_CHANNELS> velocities_;  // Velocity pro ka쬯칳 kan치l a notu
    std::array<std::array<uint8_t, 128>, MIDI_CHANNELS> controllerValues_;  // Controller hodnoty

    // Intern칤 helper metody
    void pushToQueue(NoteQueue& queue, uint8_t note);  // P콏id치 do queue s automatick칳m p콏ete캜en칤m
    uint8_t popFromQueue(NoteQueue& queue);  // Vyt치hne z queue, vrac칤 255 p콏i pr치zdn칠
};


===== File: PluginEditor.cpp =====
Path: C:\Users\jindr\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    DBG("Editor constructor started...");  // P콏idan칳 debug pro konzoli
    juce::ignoreUnused (processorRef);
    
    // Logov치n칤 vytv치콏en칤 editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytv치콏eni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lep코칤 캜itelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmav캩 코ed칠 pozad칤
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelen칳 text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmav칳 okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tla캜칤tka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vy캜i코t캩n칤 display p콏i vypnut칤
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // P콏id치n칤 tla캜칤tka pro vy캜i코t캩n칤 log콢
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastaven칤 reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Roz코칤콏en치 velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKON캛ENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logov치n칤 p콏ed destrukc칤
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstran캩n칤 reference p콏i destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
    DBG("Editor destructor called.");  // P콏idan칳 debug pro konzoli
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    DBG("Painting editor...");  // P콏idan칳 debug pro vykreslen칤
    // Logov치n칤 pouze p콏i prvn칤m vykreslen칤
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozad칤
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horn칤 sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Odd캩lovac칤 캜치ra
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    DBG("Resizing editor...");  // P콏idan칳 debug pro zm캩nu velikosti
    // Logov치n칤 zm캩ny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozlo쬰n칤 komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zab칤r치 v캩t코inu m칤sta
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tla캜칤tka ve spodn칤 캜치sti
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    DBG("Updating log display...");  // P콏idan칳 debug pro aktualizaci display
    // Z칤sk치n칤 bufferu z Loggeru p콏es getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestaven칤 textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastaven칤 textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledov치n칤 nov칳ch ud치lost칤
    logDisplay->moveCaretToEnd();
    
    // Jednoduch칳 scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\jindr\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logov치n칤 a ovl치d치n칤
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\jindr\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "SampleLibrary.h"

/**
 * @brief Konstruktor AudioPluginAudioProcessor.
 * Inicializuje komponenty a stav.
 */
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true))
    , logger_(Logger::getInstance())
    , voiceManager_(sampleLibrary_)  // VoiceManager vy쬬duje SampleLibrary
{
    logger_.log("PluginProcessor/constructor", "info", "=== ZAH츼JEN칈 INICIALIZACE PROCESSOR ===");
    
    try {
        // Inicializace s bezpe캜n칳mi v칳choz칤mi hodnotami
        sampleRate_ = 44100.0;
        synthState_.store(SynthState::Uninitialized);
        processingEnabled_.store(false);
        
        logger_.log("PluginProcessor/constructor", "info", "Z치kladn칤 komponenty inicializov치ny");
        logger_.log("PluginProcessor/constructor", "info", "V칳choz칤 sample rate: " + juce::String(sampleRate_));
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/constructor", "error", "Chyba v konstruktoru: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    } catch (...) {
        logger_.log("PluginProcessor/constructor", "error", "Nezn치m치 chyba v konstruktoru");
        synthState_.store(SynthState::Error);
    }
    
    logger_.log("PluginProcessor/constructor", "info", "=== PROCESSOR KONSTRUKTOR DOKON캛EN ===");
    DBG("Processor constructor completed with state: " + getStateDescription());
}

/**
 * @brief Destruktor s kompletn칤m cleanup a logov치n칤m.
 */
AudioPluginAudioProcessor::~AudioPluginAudioProcessor() 
{
    logger_.log("PluginProcessor/destructor", "info", "=== ZAH츼JEN칈 DESTRUKCE PROCESSOR ===");
    
    try {
        // Okam쬴t칠 zastaven칤 zpracov치n칤
        processingEnabled_.store(false);
        synthState_.store(SynthState::Uninitialized);
        
        logger_.log("PluginProcessor/destructor", "info", "Audio zpracov치n칤 zastaveno");
        
        // Uvoln캩n칤 zdroj콢 v spr치vn칠m po콏ad칤
        sampleLibrary_.clear();
        logger_.log("PluginProcessor/destructor", "info", "Sample library vy캜i코t캩na");
        
        // Kr치tk칠 캜ek치n칤 pro dokon캜en칤 p콏칤padn칳ch audio vl치ken
        juce::Thread::sleep(10);
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/destructor", "error", "Chyba v destruktoru: " + juce::String(e.what()));
    } catch (...) {
        logger_.log("PluginProcessor/destructor", "error", "Nezn치m치 chyba v destruktoru");
    }
    
    logger_.log("PluginProcessor/destructor", "info", "=== DESTRUKCE PROCESSOR DOKON캛ENA ===");
    DBG("Processor destructor completed");
}

/**
 * @brief P콏칤prava na p콏ehr치v치n칤 s kompletn칤m error handlingem.
 * @param sampleRate Sample rate
 * @param samplesPerBlock Blok velikost
 */
void AudioPluginAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    logger_.log("PluginProcessor/prepareToPlay", "info", "=== ZAH츼JEN칈 PREPARE TO PLAY ===");
    logger_.log("PluginProcessor/prepareToPlay", "info", 
                "Parametry - SampleRate: " + juce::String(sampleRate) + 
                ", BufferSize: " + juce::String(samplesPerBlock));
    
    try {
        // Validace vstupn칤ch parametr콢
        if (sampleRate <= 0.0 || sampleRate > 192000.0) {
            logger_.log("PluginProcessor/prepareToPlay", "error", "Neplatn칳 sample rate: " + juce::String(sampleRate));
            throw std::invalid_argument(("Neplatn칳 sample rate: " + juce::String(sampleRate)).toStdString());
        }
        
        if (samplesPerBlock <= 0 || samplesPerBlock > 8192) {
            logger_.log("PluginProcessor/prepareToPlay", "error", "Neplatn치 velikost bufferu: " + juce::String(samplesPerBlock));
            throw std::invalid_argument(("Neplatn치 velikost bufferu: " + juce::String(samplesPerBlock)).toStdString());
        }
        
        // Do캜asn칠 zastaven칤 zpracov치n칤 b캩hem inicializace
        processingEnabled_.store(false);
        synthState_.store(SynthState::Initializing);
        
        sampleRate_ = sampleRate;
        samplesPerBlock_ = samplesPerBlock;
        
        logger_.log("PluginProcessor/prepareToPlay", "info", "Parametry validov치ny a ulo쬰ny");
        
        // Inicializace syntez치toru
        initializeSynth();
        
        // Povolen칤 zpracov치n칤 pouze po 칰sp캩코n칠 inicializaci
        if (synthState_.load() == SynthState::Ready) {
            processingEnabled_.store(true);
            logger_.log("PluginProcessor/prepareToPlay", "info", "Audio zpracov치n칤 povoleno");
        }
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/prepareToPlay", "error", "Chyba v prepareToPlay: " + juce::String(e.what()));
        handleSynthError("Chyba v prepareToPlay: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
        processingEnabled_.store(false);
    } catch (...) {
        logger_.log("PluginProcessor/prepareToPlay", "error", "Nezn치m치 chyba v prepareToPlay");
        handleSynthError("Nezn치m치 chyba v prepareToPlay");
        synthState_.store(SynthState::Error);
        processingEnabled_.store(false);
    }
    
    logger_.log("PluginProcessor/prepareToPlay", "info", "=== PREPARE TO PLAY DOKON캛EN - Stav: " + getStateDescription() + " ===");
    DBG("prepareToPlay completed with state: " + getStateDescription());
}

/**
 * @brief Uvoln칤 zdroje s kompletn칤m logov치n칤m.
 */
void AudioPluginAudioProcessor::releaseResources()
{
    logger_.log("PluginProcessor/releaseResources", "info", "=== ZAH츼JEN칈 RELEASE RESOURCES ===");
    
    try {
        // Okam쬴t칠 zastaven칤 zpracov치n칤
        processingEnabled_.store(false);
        
        // Vy캜i코t캩n칤 vzork콢
        sampleLibrary_.clear();
        logger_.log("PluginProcessor/releaseResources", "info", "Sample library vy캜i코t캩na");
        
        // Reset stavu
        synthState_.store(SynthState::Uninitialized);
        
        logger_.log("PluginProcessor/releaseResources", "info", "V코echny zdroje uvoln캩ny");
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/releaseResources", "error", "Chyba p콏i uvol켿ov치n칤: " + juce::String(e.what()));
    } catch (...) {
        logger_.log("PluginProcessor/releaseResources", "error", "Nezn치m치 chyba p콏i uvol켿ov치n칤");
    }
    
    logger_.log("PluginProcessor/releaseResources", "info", "=== RELEASE RESOURCES DOKON캛EN ===");
    DBG("Resources released");
}

/**
 * @brief Inicializuje syntetiz칠r s robustn칤m error handlingem.
 */
void AudioPluginAudioProcessor::initializeSynth()
{
    if (synthState_.load() != SynthState::Initializing) {
        logger_.log("PluginProcessor/initializeSynth", "warn", "Inicializace p콏esko캜ena - nespr치vn칳 stav: " + getStateDescription());
        return;
    }

    logger_.log("PluginProcessor/initializeSynth", "info", "Zah치jen칤 inicializace syntez치toru");
    
    try {
        if (sampleRate_ <= 0.0) {
            throw std::runtime_error("Sample rate nen칤 nastaven");
        }
        
        logger_.log("PluginProcessor/initializeSynth", "info", "Inicializace sample library...");
        sampleLibrary_.initialize(sampleRate_);
        
        // Kontrola, zda byla inicializace 칰sp캩코n치
        bool hasValidSamples = false;
        for (uint8_t note = SampleLibrary::MIN_NOTE; note <= SampleLibrary::MAX_NOTE; ++note) {
            for (uint8_t level = 0; level < 8; ++level) {
                if (sampleLibrary_.isNoteAvailable(note, level)) {
                    hasValidSamples = true;
                    break;
                }
            }
            if (hasValidSamples) break;
        }
        
        if (!hasValidSamples) {
            throw std::runtime_error("콯치dn칠 vzorky nebyly vygenerov치ny");
        }
        
        synthState_.store(SynthState::Ready);
        logger_.log("PluginProcessor/initializeSynth", "info", "Syntez치t쮐 칰sp캩코n캩 inicializov치n");
        
    } catch (const std::exception& e) {
        handleSynthError("Inicializace selhala: " + juce::String(e.what()));
        synthState_.store(SynthState::Error);
    } catch (...) {
        handleSynthError("Nezn치m치 chyba p콏i inicializaci");
        synthState_.store(SynthState::Error);
    }
}

/**
 * @brief Centr치ln칤 handling chyb s detailn칤m logov치n칤m.
 * @param errorMessage Zpr치va o chyb캩
 */
void AudioPluginAudioProcessor::handleSynthError(const juce::String& errorMessage)
{
    logger_.log("PluginProcessor/handleSynthError", "error", errorMessage);
    
    // Zastaven칤 zpracov치n칤 p콏i chyb캩
    processingEnabled_.store(false);
    
    // Mo쬹칠 roz코칤콏en칤 o recovery mechanismy
    DBG("Synth error: " + errorMessage);
}

/**
 * @brief Vr치t칤 popis stavu s dodate캜n칳mi informacemi.
 * @return String popis
 */
juce::String AudioPluginAudioProcessor::getStateDescription() const
{
    juce::String base;
    switch (synthState_.load()) {
        case SynthState::Uninitialized: base = "Neinicializov치no"; break;
        case SynthState::Initializing: base = "Inicializace"; break;
        case SynthState::Ready: base = "P콏ipraveno"; break;
        case SynthState::Error: base = "Chyba"; break;
        default: base = "Nezn치m칳 stav"; break;
    }
    
    base += " (Processing: " + juce::String(processingEnabled_.load() ? "ON" : "OFF") + ")";
    logger_.log("PluginProcessor/getStateDescription", "debug", "Vr치cen popis stavu: " + base);
    return base;
}

/**
 * @brief Zpracuje audio blok s kompletn칤m error handlingem a validac칤.
 * @param buffer Audio buffer
 * @param midiMessages MIDI buffer
 */
void AudioPluginAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    static int blockCounter = 0;
    blockCounter++;
    
    // Periodicr logging ka쬯칳ch 1000 blok콢 pro sn칤쬰n칤 z치t캩쬰
    bool shouldLog = (blockCounter % 1000 == 1) || (blockCounter <= 10);
    
    if (shouldLog) {
        logger_.log("PluginProcessor/processBlock", "info", "Blok #" + juce::String(blockCounter) + " - Stav: " + getStateDescription() + 
                   ", Velikost: " + juce::String(buffer.getNumSamples()) + 
                   ", Kan치ly: " + juce::String(buffer.getNumChannels()));
    }
    
    try {
        // Z치kladn칤 validace
        if (!processingEnabled_.load() || synthState_.load() != SynthState::Ready) {
            buffer.clear();
            if (shouldLog) {
                logger_.log("PluginProcessor/processBlock", "debug", "Blok p콏esko캜en - zpracov치n칤 vypnuto nebo nespr치vn칳 stav");
            }
            return;
        }
        
        // Validace bufferu
        if (buffer.getNumSamples() <= 0 || buffer.getNumChannels() < 2) {  // Zm캩na: Vy쬬duje stereo
            logger_.log("PluginProcessor/processBlock", "error", "Neplatn칳 buffer - samples: " + 
                       juce::String(buffer.getNumSamples()) + ", channels: " + juce::String(buffer.getNumChannels()));
            return;
        }
        
        // Zpracov치n칤 MIDI zpr치v s error handlingem
        int midiEventCount = 0;
        try {
            for (const auto metadata : midiMessages) {
                auto msg = metadata.getMessage();
                midiEventCount++;
                
                if (msg.isNoteOn()) {
                    midiState_.pushNoteOn(msg.getChannel() - 1, msg.getNoteNumber(), msg.getVelocity());
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "NoteOn: nota " + juce::String(msg.getNoteNumber()) + 
                                   ", velocity " + juce::String(msg.getVelocity()) + 
                                   ", kan치l " + juce::String(msg.getChannel()));
                    }
                } else if (msg.isNoteOff()) {
                    midiState_.pushNoteOff(msg.getChannel() - 1, msg.getNoteNumber());
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "NoteOff: nota " + juce::String(msg.getNoteNumber()) + 
                                   ", kan치l " + juce::String(msg.getChannel()));
                    }
                } else if (msg.isController()) {
                    midiState_.setControllerValue(msg.getChannel() - 1, msg.getControllerNumber(), msg.getControllerValue());
                    if (shouldLog) {
                        logger_.log("PluginProcessor/processBlock", "debug", 
                                   "Controller: #" + juce::String(msg.getControllerNumber()) + 
                                   " = " + juce::String(msg.getControllerValue()));
                    }
                }
            }
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Chyba p콏i zpracov치n칤 MIDI: " + juce::String(e.what()));
            // Pokra캜ujeme bez MIDI dat
        }
        
        if (shouldLog && midiEventCount > 0) {
            logger_.log("PluginProcessor/processBlock", "debug", "MIDI zpr치vy zpracov치ny: " + juce::String(midiEventCount));
        }

        // Zpracov치n칤 hlas콢 s error handlingem
        try {
            voiceManager_.processMidiEvents(midiState_);
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Chyba p콏i zpracov치n칤 hlas콢: " + juce::String(e.what()));
            buffer.clear();
            return;
        }

        // Generace audio s bezpe캜nostn칤mi kontrolami
        buffer.clear();
        
        try {
            voiceManager_.generateAudio(buffer, buffer.getNumSamples());
        } catch (const std::exception& e) {
            logger_.log("PluginProcessor/processBlock", "error", "Chyba p콏i generaci audio: " + juce::String(e.what()));
            buffer.clear();
            return;
        }

        if (shouldLog) {
            int activeVoices = voiceManager_.getActiveVoiceCount();
            logger_.log("PluginProcessor/processBlock", "debug", 
                       "Blok dokon캜en - Aktivn칤 hlasy: " + juce::String(activeVoices));
        }
        
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/processBlock", "error", "V칳jimka v processBlock: " + juce::String(e.what()));
        buffer.clear(); // Zajist칤me tich칳 v칳stup p콏i chyb캩
        processingEnabled_.store(false); // Zastav칤me zpracov치n칤 p콏i kritick칠 chyb캩
    } catch (...) {
        logger_.log("PluginProcessor/processBlock", "error", "Nezn치m치 v칳jimka v processBlock");
        buffer.clear();
        processingEnabled_.store(false);
    }
}

/**
 * @brief Vytvo콏칤 editor s error handlingem.
 */
juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    logger_.log("PluginProcessor/createEditor", "info", "=== VYTV츼콎EN칈 EDITORU ===");
    
    try {
        auto* editor = new AudioPluginAudioProcessorEditor(*this);
        logger_.log("PluginProcessor/createEditor", "info", "Editor 칰sp캩코n캩 vytvo콏en");
        return editor;
    } catch (const std::exception& e) {
        logger_.log("PluginProcessor/createEditor", "error", "Chyba p콏i vytv치콏en칤 editoru: " + juce::String(e.what()));
        return nullptr;
    } catch (...) {
        logger_.log("PluginProcessor/createEditor", "error", "Nezn치m치 chyba p콏i vytv치콏en칤 editoru");
        return nullptr;
    }
}

/**
 * @brief Exportovan치 funkce pro JUCE plugin s error handlingem.
 */
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    try {
        return new AudioPluginAudioProcessor();
    } catch (const std::exception& e) {
        DBG("Error creating plugin: " + juce::String(e.what()));
        return nullptr;
    } catch (...) {
        DBG("Unknown error creating plugin");
        return nullptr;
    }
}


===== File: PluginProcessor.h =====
Path: C:\Users\jindr\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include "SampleLibrary.h"
#include "VoiceManager.h"
#include "MidiStateManager.h"
#include "Logger.h"

// Enum pro stavy syntetiz칠ru s roz코칤콏enou funkcionalitou
enum class SynthState {
    Uninitialized,  // Po캜치te캜n칤 stav - nic nen칤 inicializov치no
    Initializing,   // Prob칤h치 inicializace
    Ready,          // P콏ipraveno k audio zpracov치n칤
    Error           // Kritick치 chyba - vy쬬duje restart
};

/**
 * @class AudioPluginAudioProcessor
 * @brief Hlavn칤 audio procesor pluginu (JUCE-based) s robustn칤m error handlingem.
 * 
 * Spravuje inicializaci, zpracov치n칤 audio/MIDI, stav syntetiz칠ru a error recovery.
 * Nov캩 p콏id치ny atomic safety mechanismy a detailn칤 logging pro debugging.
 * 
 * Thread Safety:
 * - synthState_ a processingEnabled_ jsou atomic pro bezpe캜n칳 p콏칤stup z v칤ce vl치ken
 * - V코echny kritick칠 operace jsou chr치n캩ny try-catch bloky
 * - Error handling s automatic recovery kde je to mo쬹칠
 * 
 * Memory Management:
 * - Automatick칠 cleanup v destruktoru
 * - Safe resource deallocation p콏i chyb치ch
 * - Kontrola validity pointer콢 p콏ed pou쬴t칤m
 */
class AudioPluginAudioProcessor : public juce::AudioProcessor
{
public:
    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    // === JUCE Audio Processor Interface ===
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    // === Editor Management ===
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    // === Plugin Metadata ===
    const juce::String getName() const override { return JucePlugin_Name; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    // === Program Management (Basic Implementation) ===
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&) override {}

    // === State Persistence (Placeholder) ===
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

    // === Public Status Methods ===
    /**
     * @brief Vr치t칤 lidsky 캜iteln칳 popis aktu치ln칤ho stavu.
     * @return String s popisem stavu v캜etn캩 processing status
     */
    juce::String getStateDescription() const;

    /**
     * @brief Kontroluje, zda je procesor p콏ipraven k audio zpracov치n칤.
     * @return true pokud je ready a processing enabled
     */
    bool isReadyForProcessing() const { 
        return synthState_.load() == SynthState::Ready && processingEnabled_.load(); 
    }

    /**
     * @brief Vr치t칤 aktu치ln칤 sample rate.
     * @return Sample rate nebo 0 pokud nen칤 nastaven
     */
    double getCurrentSampleRate() const { return sampleRate_; }

    /**
     * @brief Vr치t칤 velikost audio bufferu.
     * @return Velikost bufferu nebo 0 pokud nen칤 nastaven
     */
    int getCurrentBufferSize() const { return samplesPerBlock_; }

private:
    // === Core Components ===
    Logger& logger_;  // Reference na singleton logger
    SampleLibrary sampleLibrary_;  // Knihovna audio vzork콢
    VoiceManager voiceManager_;  // Manager polyphonic hlas콢
    MidiStateManager midiState_;  // Manager MIDI stavu a ud치lost칤

    // === State Management (Thread-Safe) ===
    std::atomic<SynthState> synthState_{SynthState::Uninitialized};  // Stav syntetiz칠ru
    std::atomic<bool> processingEnabled_{false};  // Povolen칤 audio zpracov치n칤
    
    // === Audio Configuration ===
    double sampleRate_{44100.0};  // Aktu치ln칤 sample rate
    int samplesPerBlock_{512};     // Velikost audio bufferu

    // === Private Methods ===

    /**
     * @brief Inicializuje syntetiz칠r (vzorky, voices atd.) s error handlingem.
     * Vol치 se z prepareToPlay po validaci parametr콢.
     * 
     * Process:
     * 1. Kontrola p콏echod콢 stav콢
     * 2. Inicializace SampleLibrary
     * 3. Validace vygenerovan칳ch vzork콢
     * 4. Nastaven칤 Ready stavu
     * 
     * @throws std::runtime_error p콏i kritick칳ch chyb치ch
     */
    void initializeSynth();

    /**
     * @brief Centr치ln칤 metoda pro handling chyb s automatick칳m recovery.
     * 
     * Akce p콏i chyb캩:
     * - Logov치n칤 s detailn칤m popisem
     * - Zastaven칤 audio zpracov치n칤
     * - Mo쬹칠 future recovery mechanismy
     * 
     * @param errorMessage Zpr치va o chyb캩 pro logging
     */
    void handleSynthError(const juce::String& errorMessage);

    // === JUCE Macro for Memory Leak Detection ===
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AudioPluginAudioProcessor)
};

// === Global Plugin Factory Function ===
/**
 * @brief Factory funkce pro vytv치콏en칤 plugin instance.
 * Vy쬬dov치na JUCE frameworkem pro VST3, AU a dal코칤 form치ty.
 * 
 * @return Novou instanci AudioPluginAudioProcessor nebo nullptr p콏i chyb캩
 */
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter();


===== File: README.md =====
Path: C:\Users\jindr\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe

## Cesta na aplikacni data

WIN+R: %APPDATA%\IthacaPlayer

C:\Users\nemej992\AppData\Roaming\IthacaPlayer

## Nastaven칤 v칳vojov칠ho prost콏ed칤

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) prove캞te n치sleduj칤c칤 kroky. P콏edpokl치d치 se instalace Visual Studio Build Tools (s MSVC kompil치torem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Po쬬davky
- Visual Studio Build Tools (MSVC kompil치tor).
- CMake nainstalovan칳 a p콏id치n do PATH (nap콏. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastaven칤
1. **Instalace roz코칤콏en칤 ve VS Code**:
   - Otev콏ete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a lad캩n칤) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otev콏en칤 projektu**:
   - P콏ejd캩te na File > Open Folder a vyberte slo쬶u s CMakeLists.txt.
3. **V칳b캩r kompil치toru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napi코te "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle pot콏eby (nap콏. x64 pro modern칤 syst칠my).
4. **Konfigurace projektu**:
   - V Command Palette napi코te "CMake: Configure". To vygeneruje build soubory (obvykle ve slo쬮e "build").
5. **Build projektu**:
   - V Command Palette napi코te "CMake: Build" nebo pou쬴jte Shift+Ctrl+B (nyn칤 nab칤dne CMake 칰lohy).
6. **Debugov치n칤 (voliteln캩)**:
   - Nastavte breakpointy a spus콘te "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovan칳 v JUCE frameworku, inspirovan칳 hardwarov칳mi syntez치tory s modul치rn칤 architekturou.

## Architektura Syst칠mu

### P콏ehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
較럭較 SampleLibrary (Pre-computed Audio Storage)
較럭較 MidiStateManager (MIDI Event Processing)  
較럭較 VoiceManager (Voice Allocation & Control)
較덕較 Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**칔캜el:** Spr치va pre-computed audio sampel콢 pro jednotliv칠 MIDI noty

**Kl칤캜ov칠 vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not 칑 12 sekund 칑 sample rate
- **Pre-computed sine waves:** Generov치n칤 p콏i inicializaci m칤sto realtime synt칠zy
- **Memory management:** Per-nota allocation s bezpe캜n칳m uvol켿ov치n칤m
- **Roz코i콏itelnost:** P콏ipraveno pro na캜칤t치n칤 WAV soubor콢

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementa캜n칤 detaily:**
- Ka쬯칳 sample m치 pevnou d칠lku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe p콏칤stup k sample dat콢m

### 2. MidiStateManager
**칔캜el:** Centr치ln칤 spr치va MIDI stavu a ud치lost칤

**Inspirov치no:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracov치n칤
- Queue-based event distribution
- State tracking pro aktivn칤 noty a controllery

**Kl칤캜ov칠 struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Odd캩len칠 queues pro Note On/Off ud치losti
- Per-channel event routing (16 MIDI kan치l콢)
- Pop/push pattern podobn칳 hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**칔캜el:** Polyphonic voice allocation a audio generov치n칤

**Inspirov치no:** Hardware Performer class
- 16 polyphonic hlas콢
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hled치 existuj칤c칤 hlas s touto notou
    // 2. Hled치 neaktivn칤 hlas s nejvy코코칤 queue pozic칤  
    // 3. Krade aktivn칤 hlas s nejvy코코칤 queue pozic칤
}
```

**Queue Management (mixleQueue):**
Algoritmus p콏evzat칳 z HW implementace:
1. Vybran칳 hlas  queue pozice 0
2. Ostatn칤 hlasy  pozice++
3. Komprese queue pozic > p콢vodn칤 pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se p콏ehraje jednou)

### 4. Logger System
**칔캜el:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logov치n칤 z audio vl치kna
- Sliding window buffer (100 zpr치v)
- Kategorizace: info/debug/warn
- GUI integration p콏es MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
較럭較 Create SampleLibrary (dummy sample rate)
較럭較 Create MidiStateManager  
較덕較 Create VoiceManager (16 voices)

prepareToPlay:
較럭較 Reinit SampleLibrary (correct sample rate)
較럭較 Generate sine wave pro Middle C (nota 60)
較덕較 Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celkov치 alokace:** ~292MB pro kompletn칤 library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic p콏i destrukci

### Voice Memory
- **16 SynthVoice objekt콢:** Minim치ln칤 memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporovan칠 MIDI zpr치vy:
- **Note On/Off:** Kompletn칤 support v캜etn캩 Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 a +8191)
- **Control Change:** 128 controllers 칑 16 kan치l콢
- **Channel support:** 16 MIDI kan치l콢

### MIDI Routing:
- **Prototype:** Pouze kan치l 0 aktivn칤
- **Full version:** V코ech 16 kan치l콢 p콏ipraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
較럭較 PluginProcessor.h/cpp
較럭較 PluginEditor.h/cpp

Synth Engine:
較럭較 SampleLibrary.h/cpp
較럭較 MidiStateManager.h/cpp
較럭較 VoiceManager.h/cpp

Utilities:
較덕較 Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro v코ech 128 not
2. **WAV loading:** Implementace na캜칤t치n칤 extern칤ch sampel콢
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** V코e se loguje do GUI
- **MIDI monitoring:** Detailn칤 MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms p콏i 480 samples/48kHz)
- **Polyphony:** 16 hlas콢

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal d칤ky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB p콏i full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - v캩t코inou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - 쮂멳n칠 allokace v audio vl치kn캩
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**D콢vod:** Konzistentn칤 CPU usage, mo쬹ost komplexn칤ch waveforms
**Trade-off:** Vysok치 pam캩콘 vs stabiln칤 performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**D콢vod:** Zachov치n칤 hardware workflow, p콏edv칤dateln칠 chov치n칤
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centr치ln칤 state s queue distribution
**D콢vod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**D콢vod:** Complex debugging po쬬davky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\jindr\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include "SampleLoader.h"  // Nov칳 include
#include <cmath>

SampleLibrary::SampleLibrary() : logger_(Logger::getInstance()) {
    logger_.log("SampleLibrary/constructor", "info", "SampleLibrary inicializov치na");
}

void SampleLibrary::initialize(double sampleRate) {
    logger_.log("SampleLibrary/initialize", "info", "Za캜치tek inicializace se sample rate=" + juce::String(sampleRate));
    auto startTime = juce::Time::getMillisecondCounterHiRes();
    sampleRate_ = sampleRate;
    clear();

    SampleLoader loader(sampleRate_);
    juce::File instrumentDir = SampleLoader::getDefaultInstrumentDirectory();
    if (!instrumentDir.exists()) {
        instrumentDir.createDirectory();
        logger_.log("SampleLibrary/initialize", "info", "Vytvo콏en instrument directory: " + instrumentDir.getFullPathName());
    }

    auto progressCallback = [this](int current, int total, const juce::String& status) {
        logger_.log("SampleLibrary/initialize", "info", "Progress: " + juce::String(current) + "/" + juce::String(total) + " - " + status);
    };

    auto loadedSamples = loader.loadInstrument(instrumentDir, progressCallback);

    loadingStats_.totalSamples = static_cast<int>(loadedSamples.size());
    loadingStats_.totalMemoryUsed = 0;
    loadingStats_.loadedFromFiles = 0;
    loadingStats_.generatedSines = 0;

    {
        std::lock_guard<std::mutex> lock(accessMutex_);
        for (auto& sample : loadedSamples) {
            auto& seg = sampleSegments_[sample.midiNote];
            uint8_t level = sample.dynamicLevel;
            seg.dynamicLayers[level] = std::move(sample.audioData);
            seg.layerLengthSamples[level] = sample.lengthSamples;
            seg.layerAllocated[level] = true;
            seg.midiNote = sample.midiNote;

            if (sample.isGenerated) ++loadingStats_.generatedSines;
            else ++loadingStats_.loadedFromFiles;

            loadingStats_.totalMemoryUsed += sample.lengthSamples * 2 * sizeof(float);  // Stereo
        }
    }

    loadingStats_.loadingTimeSeconds = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;
    logger_.log("SampleLibrary/initialize", "info", "Na캜칤t치n칤 dokon캜eno: " + juce::String(loadingStats_.loadedFromFiles) + " z WAV, " +
                juce::String(loadingStats_.generatedSines) + " generovan칳ch, " + juce::String(loadingStats_.totalMemoryUsed / (1024*1024)) + " MB");
}

void SampleLibrary::clear() {
    logger_.log("SampleLibrary/clear", "info", "Za캜치tek 캜i코t캩n칤 SampleLibrary");
    std::lock_guard<std::mutex> lock(accessMutex_);
    for (auto& seg : sampleSegments_) {
        for (int i = 0; i < 8; ++i) {
            seg.dynamicLayers[i].reset();
            seg.layerLengthSamples[i] = 0;
            seg.layerAllocated[i] = false;
        }
        seg.midiNote = 0;
    }
    logger_.log("SampleLibrary/clear", "info", "SampleLibrary vy캜i코t캩na");
}

const float* SampleLibrary::getSampleData(uint8_t midiNote, uint8_t dynamicLevel) const {
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && dynamicLevel < 8 && sampleSegments_[midiNote].layerAllocated[dynamicLevel]) {
        logger_.log("SampleLibrary/getSampleData", "debug", "Vr치cena data pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
        return sampleSegments_[midiNote].dynamicLayers[dynamicLevel].get();
    }
    logger_.log("SampleLibrary/getSampleData", "warn", "콯치dn치 data pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    return nullptr;
}

uint32_t SampleLibrary::getSampleLength(uint8_t midiNote, uint8_t dynamicLevel) const {
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && dynamicLevel < 8 && sampleSegments_[midiNote].layerAllocated[dynamicLevel]) {
        logger_.log("SampleLibrary/getSampleLength", "debug", "Vr치cena d칠lka " + juce::String(sampleSegments_[midiNote].layerLengthSamples[dynamicLevel]) + " pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
        return sampleSegments_[midiNote].layerLengthSamples[dynamicLevel];
    }
    logger_.log("SampleLibrary/getSampleLength", "warn", "콯치dn치 d칠lka pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    return 0;
}

bool SampleLibrary::isNoteAvailable(uint8_t midiNote, uint8_t dynamicLevel) const {
    std::lock_guard<std::mutex> lock(accessMutex_);
    bool available = midiNote < sampleSegments_.size() && dynamicLevel < 8 && sampleSegments_[midiNote].layerAllocated[dynamicLevel];
    logger_.log("SampleLibrary/isNoteAvailable", "debug", "Nota " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel) + " je " + (available ? "dostupn치" : "nedostupn치"));
    return available;
}

uint8_t SampleLibrary::velocityToDynamicLevel(uint8_t velocity) const {
    uint8_t level = std::min<uint8_t>(7, velocity / 16);
    logger_.log("SampleLibrary/velocityToDynamicLevel", "debug", "Velocity " + juce::String(velocity) + " mapov치no na vrstvu " + juce::String(level));
    return level;
}


===== File: SampleLibrary.h =====
Path: C:\Users\jindr\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <memory>
#include <array>
#include "Logger.h"
#include "SampleLoader.h"  // P콏idan칳 include pro SampleLoader (pro konzistenci, i kdy nen칤 v .h nutn칳)

/**
 * @struct SampleSegment
 * @brief Struktura pro segment vzorku s dynamick칳mi vrstvami.
 * 
 * Dr쮂 data pro 8 dynamick칳ch vrstev (stereo interleaved), d칠lky a alokace.
 */
struct SampleSegment {
    std::array<std::unique_ptr<float[]>, 8> dynamicLayers;  // Interleaved stereo data
    std::array<uint32_t, 8> layerLengthSamples{};  // D칠lka pro jeden kan치l
    uint8_t midiNote{0};
    std::array<bool, 8> layerAllocated{false};

    /**
     * @brief Vr치t칤 d칠lku vrstvy.
     * @param dynamicLevel Vrstva (0-7)
     * @return D칠lka v samplech nebo 0 p콏i nevalidn칤 vrstv캩
     */
    uint32_t getLayerLength(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8) ? layerLengthSamples[dynamicLevel] : 0;
    }

    /**
     * @brief Vr치t칤 ukazatel na data vrstvy.
     * @param dynamicLevel Vrstva (0-7)
     * @return Ukazatel na data nebo nullptr p콏i nevalidn칤 vrstv캩
     */
    const float* getLayerData(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8 && layerAllocated[dynamicLevel]) ? dynamicLayers[dynamicLevel].get() : nullptr;
    }
};

/**
 * @class SampleLibrary
 * @brief Knihovna sampl콢 s podporou dynamick칳ch vrstev a stereo.
 * 
 * Inicializuje samply, poskytuje read-only p콏칤stup a mapuje velocity na vrstvy.
 */
class SampleLibrary {
public:
    SampleLibrary();
    ~SampleLibrary() = default;

    /**
     * @brief Inicializuje knihovnu (nutn칠 zavolat p콏ed pou쬴t칤m).
     * @param sampleRate Sample rate pro generov치n칤/na캜칤t치n칤
     */
    void initialize(double sampleRate);

    /**
     * @brief Vy캜ist칤 v코echny samply (uvoln칤 pam캩콘).
     */
    void clear();

    /**
     * @brief Vr치t칤 data samply pro notu a vrstvu.
     * @param midiNote MIDI nota
     * @param dynamicLevel Dynamick치 vrstva (0-7)
     * @return Ukazatel na stereo data nebo nullptr
     */
    const float* getSampleData(uint8_t midiNote, uint8_t dynamicLevel) const;

    /**
     * @brief Vr치t칤 d칠lku samply pro notu a vrstvu.
     * @param midiNote MIDI nota
     * @param dynamicLevel Dynamick치 vrstva (0-7)
     * @return D칠lka v samplech nebo 0
     */
    uint32_t getSampleLength(uint8_t midiNote, uint8_t dynamicLevel) const;

    /**
     * @brief Zkontroluje dostupnost samply.
     * @param midiNote MIDI nota
     * @param dynamicLevel Dynamick치 vrstva (0-7)
     * @return True pokud dostupn칳
     */
    bool isNoteAvailable(uint8_t midiNote, uint8_t dynamicLevel) const;

    /**
     * @brief Mapuje velocity na dynamickou vrstvu.
     * @param velocity Velocity (0-127)
     * @return Vrstva (0-7)
     */
    uint8_t velocityToDynamicLevel(uint8_t velocity) const;

    /**
     * @struct LoadingStats
     * @brief Statistiky na캜칤t치n칤 sampl콢.
     */
    struct LoadingStats {
        int totalSamples;
        int loadedFromFiles;
        int generatedSines;
        size_t totalMemoryUsed;
        double loadingTimeSeconds;
    };

    /**
     * @brief Vr치t칤 statistiky na캜칤t치n칤.
     * @return Struktura se statistikami
     */
    LoadingStats getLoadingStats() const { return loadingStats_; }

    static constexpr uint8_t MIN_NOTE = 21;   // A0 - minim치ln칤 MIDI nota
    static constexpr uint8_t MAX_NOTE = 108;  // C8 - maxim치ln칤 MIDI nota

private:
    mutable std::mutex accessMutex_;  // Chr치n칤 sampleSegments_
    std::array<SampleSegment, 128> sampleSegments_;  // 칔lo쬴코t캩 pro MIDI noty
    double sampleRate_{44100.0};  // Aktu치ln칤 sample rate
    Logger& logger_;  // Reference na logger
    LoadingStats loadingStats_;  // Statistiky

    static constexpr std::array<float, 8> DYNAMIC_AMPLITUDES = {
        0.05f, 0.12f, 0.22f, 0.35f, 0.50f, 0.68f, 0.85f, 1.00f
    };
};


===== File: SampleLoader.cpp =====
Path: C:\Users\jindr\IthacaPlayer\SampleLoader.cpp
=====
#include "SampleLoader.h"
#include <cmath>
#include "Logger.h"

SampleLoader::SampleLoader(double sampleRate) : sampleRate_(sampleRate) {
    formatManager_.registerBasicFormats();  // Podpora WAV, AIFF atd.
    Logger::getInstance().log("SampleLoader/constructor", "info", "SampleLoader inicializov치n se sample rate " + juce::String(sampleRate));
}

juce::File SampleLoader::getDefaultInstrumentDirectory() {
    juce::File dir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("IthacaPlayer/instrument");
    Logger::getInstance().log("SampleLoader/getDefaultInstrumentDirectory", "debug", "Vr치cen default directory: " + dir.getFullPathName());
    return dir;
}

juce::String SampleLoader::generateFilename(uint8_t midiNote, uint8_t dynamicLevel) {
    juce::String filename = "m" + juce::String::formatted("%03d", midiNote) + "-vel" + juce::String(dynamicLevel) + ".lau";
    Logger::getInstance().log("SampleLoader/generateFilename", "debug", "Vygenerov치n n치zev souboru: " + filename + " pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    return filename;
}

bool SampleLoader::parseFilename(const juce::String& filename, uint8_t& midiNote, uint8_t& dynamicLevel) {
    if (!filename.endsWith(".lau")) {
        Logger::getInstance().log("SampleLoader/parseFilename", "warn", "Neplatn치 extension souboru: " + filename);
        return false;
    }
    auto parts = juce::StringArray::fromTokens(filename.upToLastOccurrenceOf(".lau", false, false), "-", "");
    if (parts.size() != 2 || !parts[0].startsWith("m") || !parts[1].startsWith("vel")) {
        Logger::getInstance().log("SampleLoader/parseFilename", "warn", "Neplatn칳 form치t n치zvu souboru: " + filename);
        return false;
    }
    midiNote = static_cast<uint8_t>(parts[0].substring(1).getIntValue());
    dynamicLevel = static_cast<uint8_t>(parts[1].substring(3).getIntValue());
    bool valid = (midiNote >= 21 && midiNote <= 108 && dynamicLevel < 8);
    if (valid) {
        Logger::getInstance().log("SampleLoader/parseFilename", "debug", "Rozparsov치n soubor: " + filename + " -> nota " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    } else {
        Logger::getInstance().log("SampleLoader/parseFilename", "warn", "콯치dn칳 rozsah v souboru: " + filename);
    }
    return valid;
}

/**
 * @brief Analyzuje WAV soubor bez na캜칤t치n칤 dat.
 * @param file Soubor k anal칳ze
 * @return Struktura s anal칳zou
 */
FileAnalysis SampleLoader::analyzeWavFile(const juce::File& file) {
    Logger::getInstance().log("SampleLoader/analyzeWavFile", "info", "Za캜치tek anal칳zy souboru: " + file.getFullPathName());
    FileAnalysis analysis{};
    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    if (!reader) {
        // Roz코칤콏en칠 debug logov치n칤 pro chyby
        juce::String debugInfo = "Selhalo vytvo콏en칤 readeru pro soubor: " + file.getFullPathName() + 
                                 ". Soubor existuje: " + (file.existsAsFile() ? "ano" : "ne") + 
                                 ", velikost: " + juce::String(file.getSize()) + " bajt콢";
        Logger::getInstance().log("SampleLoader/analyzeWavFile", "error", debugInfo);
        analysis.isValid = false;
        return analysis;
    }
    analysis.originalLengthSamples = static_cast<uint32_t>(reader->lengthInSamples);
    analysis.originalSampleRate = reader->sampleRate;
    analysis.numChannels = reader->numChannels;
    analysis.needsResampling = (analysis.originalSampleRate != sampleRate_);
    analysis.targetLengthSamples = analysis.needsResampling ?
        static_cast<uint32_t>(analysis.originalLengthSamples * (sampleRate_ / analysis.originalSampleRate)) :
        analysis.originalLengthSamples;
    analysis.memoryRequired = analysis.targetLengthSamples * 2 * sizeof(float);  // V쬯y stereo
    analysis.isValid = validateFileAnalysis(analysis);
    Logger::getInstance().log("SampleLoader/analyzeWavFile", "info", "Anal칳za dokon캜ena pro soubor: " + file.getFullPathName() + 
                              ", sample rate: " + juce::String(analysis.originalSampleRate) + 
                              ", kan치ly: " + juce::String(analysis.numChannels) + 
                              ", pot콏ebuje resampl: " + (analysis.needsResampling ? "ano" : "ne"));
    return analysis;
}

bool SampleLoader::validateFileAnalysis(const FileAnalysis& analysis) {
    bool valid = analysis.originalLengthSamples > 0 && analysis.originalSampleRate > 0 &&
                 analysis.targetLengthSamples > 0 && analysis.memoryRequired < 1024 * 1024 * 1024 &&
                 analysis.numChannels >= 1 && analysis.numChannels <= 2;
    if (!valid) {
        Logger::getInstance().log("SampleLoader/validateFileAnalysis", "warn", "Neplatn치 anal칳za: samples=" + juce::String(analysis.originalLengthSamples) + 
                                  ", rate=" + juce::String(analysis.originalSampleRate) + ", kan치ly=" + juce::String(analysis.numChannels));
    } else {
        Logger::getInstance().log("SampleLoader/validateFileAnalysis", "debug", "Validace 칰sp캩코n치.");
    }
    return valid;
}

LoadedSample SampleLoader::loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel) {
    Logger::getInstance().log("SampleLoader/loadWavFile", "info", "Za캜치tek na캜칤t치n칤 souboru: " + file.getFullPathName() + " pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    LoadedSample result;
    FileAnalysis analysis = analyzeWavFile(file);
    if (!analysis.isValid) {
        Logger::getInstance().log("SampleLoader/loadWavFile", "error", "Neplatn치 anal칳za pro soubor: " + file.getFullPathName());
        throw std::runtime_error("Invalid WAV file: " + file.getFullPathName().toStdString());
    }
    result.audioData = std::make_unique<float[]>(analysis.targetLengthSamples * 2);  // Stereo interleaved
    result.lengthSamples = analysis.targetLengthSamples;
    result.midiNote = midiNote;
    result.dynamicLevel = dynamicLevel;
    result.isGenerated = false;
    result.sourcePath = file.getFullPathName();

    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    juce::AudioSampleBuffer tempBuffer(analysis.numChannels, analysis.originalLengthSamples);
    reader->read(&tempBuffer, 0, analysis.originalLengthSamples, 0, true, true);

    const float* srcL = tempBuffer.getReadPointer(0);
    const float* srcR = (analysis.numChannels == 2) ? tempBuffer.getReadPointer(1) : srcL;  // Pokud mono, duplikuj L

    if (analysis.needsResampling) {
        Logger::getInstance().log("SampleLoader/loadWavFile", "info", "Prov치d칤m resamplov치n칤 souboru: " + file.getFullPathName());
        uint32_t outLen = analysis.targetLengthSamples;
        auto resampledL = resampleIfNeeded(srcL, analysis.originalLengthSamples, analysis.originalSampleRate, outLen, 1);
        auto resampledR = resampleIfNeeded(srcR, analysis.originalLengthSamples, analysis.originalSampleRate, outLen, 1);
        for (uint32_t i = 0; i < outLen; ++i) {
            result.audioData[i * 2] = resampledL[i];
            result.audioData[i * 2 + 1] = resampledR[i];
        }
    } else {
        for (uint32_t i = 0; i < analysis.originalLengthSamples; ++i) {
            result.audioData[i * 2] = srcL[i];
            result.audioData[i * 2 + 1] = srcR[i];
        }
    }
    Logger::getInstance().log("SampleLoader/loadWavFile", "info", "Na캜칤t치n칤 souboru dokon캜eno: " + file.getFullPathName() + ", d칠lka=" + juce::String(result.lengthSamples));
    return result;
}

std::unique_ptr<float[]> SampleLoader::resampleIfNeeded(const float* sourceData, uint32_t sourceLength,
                                                        double sourceSampleRate, uint32_t& outputLength, int numChannels) {
    Logger::getInstance().log("SampleLoader/resampleIfNeeded", "debug", "Za캜치tek resamplov치n칤: source length=" + juce::String(sourceLength) + ", rate=" + juce::String(sourceSampleRate));
    
    double ratio = sampleRate_ / sourceSampleRate;
    
    auto resampled = std::make_unique<float[]>(outputLength * numChannels);
    
    for (uint32_t i = 0; i < outputLength; ++i) {
        double srcPos = i / ratio;
        int idx = static_cast<int>(srcPos);
        float frac = static_cast<float>(srcPos - idx);
        for (int ch = 0; ch < numChannels; ++ch) {
            if (idx + 1 < static_cast<int>(sourceLength)) {
                resampled[i * numChannels + ch] = sourceData[idx * numChannels + ch] * (1 - frac) + sourceData[(idx + 1) * numChannels + ch] * frac;
            } else {
                resampled[i * numChannels + ch] = sourceData[idx * numChannels + ch];
            }
        }
    }
    
    Logger::getInstance().log("SampleLoader/resampleIfNeeded", "debug", "Resamplov치n칤 dokon캜eno, v칳stupn칤 d칠lka=" + juce::String(outputLength));
    return resampled;
}

/**
 * @brief Generuje sine vlnu pro placeholder.
 * @param midiNote MIDI nota
 * @param dynamicLevel Vrstva (0-7)
 * @return LoadedSample s daty
 */
LoadedSample SampleLoader::generateSineWave(uint8_t midiNote, uint8_t dynamicLevel) {
    Logger::getInstance().log("SampleLoader/generateSineWave", "info", "Generov치n칤 sine vlny pro notu " + juce::String(midiNote) + ", vrstva " + juce::String(dynamicLevel));
    LoadedSample result;
    double freq = 440.0 * std::pow(2.0, (midiNote - 69) / 12.0);
    constexpr double fixedRate = 44100.0;  // Fixn칤 sample rate pro generov치n칤
    uint32_t length = static_cast<uint32_t>(fixedRate * 12.0);  // 12s fallback
    result.audioData = std::make_unique<float[]>(length * 2);  // Stereo interleaved
    result.lengthSamples = length;
    result.midiNote = midiNote;
    result.dynamicLevel = dynamicLevel;
    result.isGenerated = true;
    result.sourcePath = "Generated sine";

    constexpr std::array<float, 8> amplitudes = {0.05f, 0.12f, 0.22f, 0.35f, 0.50f, 0.68f, 0.85f, 1.00f};
    float amp = amplitudes[dynamicLevel];
    double phaseInc = 2.0 * juce::MathConstants<double>::pi * freq / fixedRate;
    for (uint32_t i = 0; i < length; ++i) {
        float val = amp * static_cast<float>(std::sin(phaseInc * i));
        result.audioData[i * 2] = val;      // Left
        result.audioData[i * 2 + 1] = val;  // Right (stejn칳)
    }
    Logger::getInstance().log("SampleLoader/generateSineWave", "info", "Sine vlna vygenerov치na, d칠lka=" + juce::String(length));
    return result;
}

bool SampleLoader::saveGeneratedSample(const juce::File& file, const float* data, uint32_t lengthSamples) {
    Logger::getInstance().log("SampleLoader/saveGeneratedSample", "info", "Za캜치tek ukl치d치n칤 generovan칠ho souboru: " + file.getFullPathName());
    if (file.existsAsFile()) {
        Logger::getInstance().log("SampleLoader/saveGeneratedSample", "debug", "Soubor ji existuje, p콏eskakuji: " + file.getFullPathName());
        return true;
    }

    std::unique_ptr<juce::FileOutputStream> stream(file.createOutputStream());
    if (!stream || stream->failedToOpen()) {
        Logger::getInstance().log("SampleLoader/saveGeneratedSample", "error", "Selhalo otev콏en칤 souboru pro z치pis: " + file.getFullPathName());
        return false;
    }

    juce::WavAudioFormat wavFormat;
    std::unique_ptr<juce::AudioFormatWriter> writer(
        wavFormat.createWriterFor(stream.get(), 44100.0, 2, 16, {}, 0)  // Fixn칤 44100 Hz pro ukl치d치n칤
    );
    if (!writer) {
        Logger::getInstance().log("SampleLoader/saveGeneratedSample", "error", "Selhalo vytvo콏en칤 WAV writeru pro: " + file.getFullPathName());
        return false;
    }

    // Rozd캩len칤 interleaved data na left a right kan치ly pro non-interleaved z치pis
    std::unique_ptr<float[]> left = std::make_unique<float[]>(lengthSamples);
    std::unique_ptr<float[]> right = std::make_unique<float[]>(lengthSamples);
    for (uint32_t i = 0; i < lengthSamples; ++i) {
        left[i] = data[i * 2];
        right[i] = data[i * 2 + 1];
    }

    // Pou쬴t칤 writeFromFloatArrays pro stereo z치pis
    const float* channels[2] = { left.get(), right.get() };
    if (!writer->writeFromFloatArrays(channels, 2, lengthSamples)) {
        Logger::getInstance().log("SampleLoader/saveGeneratedSample", "error", "Selhalo z치pis dat do souboru: " + file.getFullPathName());
        return false;
    }

    writer.reset();
    stream.reset();

    Logger::getInstance().log("SampleLoader/saveGeneratedSample", "info", "Placeholder soubor vygenerov치n a ulo쬰n: " + file.getFullPathName());
    return true;
}

std::vector<LoadedSample> SampleLoader::loadInstrument(const juce::File& instrumentDirectory, ProgressCallback progressCallback) {
    Logger::getInstance().log("SampleLoader/loadInstrument", "info", "Za캜치tek na캜칤t치n칤 instrumentu z directory: " + instrumentDirectory.getFullPathName());
    std::vector<LoadedSample> samples;
    auto files = instrumentDirectory.findChildFiles(juce::File::findFiles, false, "*.lau");
    int total = 8 * (108 - 21 + 1);
    int current = 0;

    for (uint8_t note = 21; note <= 108; ++note) {
        for (uint8_t level = 0; level < 8; ++level) {
            juce::String filename = generateFilename(note, level);
            juce::File file = instrumentDirectory.getChildFile(filename);
            LoadedSample sample;
            try {
                if (file.existsAsFile()) {
                    Logger::getInstance().log("SampleLoader/loadInstrument", "debug", "Soubor existuje, na캜칤t치m: " + filename);
                    sample = loadWavFile(file, note, level);
                } else {
                    Logger::getInstance().log("SampleLoader/loadInstrument", "warn", "Soubor neexistuje, generuji placeholder: " + filename);
                    sample = generateSineWave(note, level);
                    if (saveGeneratedSample(file, sample.audioData.get(), sample.lengthSamples)) {
                        sample = loadWavFile(file, note, level);
                    } else {
                        Logger::getInstance().log("SampleLoader/loadInstrument", "warn", "Pou쮂셨치m generovan치 data p콏칤mo (ukl치d치n칤 selhalo): " + filename);
                    }
                }
                samples.push_back(std::move(sample));
            } catch (const std::exception& e) {
                Logger::getInstance().log("SampleLoader/loadInstrument", "error", "Chyba p콏i na캜칤t치n칤 " + filename + ": " + juce::String(e.what()));
                if (progressCallback) progressCallback(current, total, "Error loading " + filename);
            }
            current++;
            if (progressCallback) progressCallback(current, total, "Loaded " + filename);
        }
    }
    Logger::getInstance().log("SampleLoader/loadInstrument", "info", "Na캜칤t치n칤 instrumentu dokon캜eno, celkem sampl콢: " + juce::String(samples.size()));
    return samples;
}


===== File: SampleLoader.h =====
Path: C:\Users\jindr\IthacaPlayer\SampleLoader.h
=====
#pragma once

#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_core/juce_core.h>
#include <memory>
#include <functional>

struct LoadedSample {
    std::unique_ptr<float[]> audioData;  // Interleaved stereo data (lengthSamples * 2 floats)
    uint32_t lengthSamples;  // D칠lka v samplech (pro jeden kan치l)
    uint8_t midiNote;
    uint8_t dynamicLevel;
    bool isGenerated;
    juce::String sourcePath;
};

struct FileAnalysis {
    uint32_t originalLengthSamples;
    uint32_t targetLengthSamples;
    double originalSampleRate;
    bool needsResampling;
    size_t memoryRequired;
    bool isValid;
    int numChannels;  // Po캜et kan치l콢 v souboru
};

class SampleLoader {
public:
    using ProgressCallback = std::function<void(int current, int total, const juce::String& status)>;

    SampleLoader(double sampleRate);

    std::vector<LoadedSample> loadInstrument(
        const juce::File& instrumentDirectory,
        ProgressCallback progressCallback = nullptr
    );

    static juce::File getDefaultInstrumentDirectory();
    static juce::String generateFilename(uint8_t midiNote, uint8_t dynamicLevel);
    static bool parseFilename(const juce::String& filename, uint8_t& midiNote, uint8_t& dynamicLevel);

private:
    double sampleRate_;
    juce::AudioFormatManager formatManager_;

    FileAnalysis analyzeWavFile(const juce::File& file);
    bool validateFileAnalysis(const FileAnalysis& analysis);

    LoadedSample loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel);
    LoadedSample generateSineWave(uint8_t midiNote, uint8_t dynamicLevel);

    // Ulo쮂 generovan치 data jako stereo WAV soubor (.lau extension)
    bool saveGeneratedSample(const juce::File& file, const float* data, uint32_t lengthSamples);

    std::unique_ptr<float[]> resampleIfNeeded(
        const float* sourceData,
        uint32_t sourceLength,
        double sourceSampleRate,
        uint32_t& outputLength,
        int numChannels  // Pro stereo resamplov치n칤
    );
};


===== File: SAMPLES.md =====
Path: C:\Users\jindr\IthacaPlayer\SAMPLES.md
=====
# Kompletn칤 Specifikace: Hybridn칤 Sample Loading Syst칠m s Dynamic Layers

## P콏ehled syst칠mu

Refaktoring IthacaPlayer pro podporu external WAV samples s 8 칰rovn캩mi dynamiky, fallback sine generace a variable sample length support.

## File System & Naming Convention

### Directory struktura
```
%APPDATA%\Roaming\IthacaPlayer\instrument\
較럭較 m021-vel0.lau    // A0, dynamic level 0
較럭較 m021-vel1.lau    // A0, dynamic level 1
較럭較 m060-vel0.lau    // Middle C, dynamic level 0
較럭較 m060-vel7.lau    // Middle C, dynamic level 7
較덕較 m108-vel7.lau    // C8, dynamic level 7
```

### Naming pattern
- **Format:** `mXXX-velY.lau`
- **XXX:** MIDI note (021-108, zero-padded)
- **Y:** Dynamic level (0-7)
- **Extension:** `.lau` (custom identifier)

## Core Architecture Changes

### 1. Nov칳 SampleLoader modul

**SampleLoader.h**
```cpp
#pragma once
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_core/juce_core.h>
#include <memory>
#include <functional>

struct LoadedSample {
    std::unique_ptr<float[]> audioData;
    uint32_t lengthSamples;
    uint8_t midiNote;
    uint8_t dynamicLevel;
    bool isGenerated;
    juce::String sourcePath;
};

struct FileAnalysis {
    uint32_t originalLengthSamples;
    uint32_t targetLengthSamples;
    double originalSampleRate;
    bool needsResampling;
    size_t memoryRequired;
    bool isValid;
};

class SampleLoader {
public:
    using ProgressCallback = std::function<void(int current, int total, const juce::String& status)>;
    
    SampleLoader(double sampleRate);
    
    // Main interface
    std::vector<LoadedSample> loadInstrument(
        const juce::File& instrumentDirectory,
        ProgressCallback progressCallback = nullptr
    );
    
    // Utility methods
    static juce::File getDefaultInstrumentDirectory();
    static juce::String generateFilename(uint8_t midiNote, uint8_t dynamicLevel);
    static bool parseFilename(const juce::String& filename, uint8_t& midiNote, uint8_t& dynamicLevel);
    
private:
    double sampleRate_;
    juce::AudioFormatManager formatManager_;
    
    // Analysis & validation
    FileAnalysis analyzeWavFile(const juce::File& file);
    bool validateFileAnalysis(const FileAnalysis& analysis);
    
    // Loading methods
    LoadedSample loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel);
    LoadedSample generateSineWave(uint8_t midiNote, uint8_t dynamicLevel);
    
    // Processing
    std::unique_ptr<float[]> resampleIfNeeded(
        const float* sourceData, 
        uint32_t sourceLength, 
        double sourceSampleRate,
        uint32_t& outputLength
    );
};
```

**SampleLoader.cpp kl칤캜ov칠 metody**
```cpp
FileAnalysis SampleLoader::analyzeWavFile(const juce::File& file) {
    FileAnalysis analysis{};
    
    // 1. Anal칳za BEZ na캜칤t치n칤 dat
    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    if (!reader) {
        analysis.isValid = false;
        return analysis;
    }
    
    // 2. Z칤sk치n칤 metadata
    analysis.originalLengthSamples = static_cast<uint32_t>(reader->lengthInSamples);
    analysis.originalSampleRate = reader->sampleRate;
    analysis.needsResampling = (analysis.originalSampleRate != sampleRate_);
    
    // 3. V칳po캜et target d칠lky
    if (analysis.needsResampling) {
        analysis.targetLengthSamples = static_cast<uint32_t>(
            analysis.originalLengthSamples * (sampleRate_ / analysis.originalSampleRate)
        );
    } else {
        analysis.targetLengthSamples = analysis.originalLengthSamples;
    }
    
    // 4. Memory requirement
    analysis.memoryRequired = analysis.targetLengthSamples * sizeof(float);
    analysis.isValid = validateFileAnalysis(analysis);
    
    return analysis;
}

LoadedSample SampleLoader::loadWavFile(const juce::File& file, uint8_t midiNote, uint8_t dynamicLevel) {
    LoadedSample result;
    
    // 1. Anal칳za prvn칤
    FileAnalysis analysis = analyzeWavFile(file);
    if (!analysis.isValid) {
        throw std::runtime_error("Invalid WAV file: " + file.getFullPathName().toStdString());
    }
    
    // 2. Alokace p콏esn칠 velikosti
    result.audioData = std::make_unique<float[]>(analysis.targetLengthSamples);
    result.lengthSamples = analysis.targetLengthSamples;
    result.midiNote = midiNote;
    result.dynamicLevel = dynamicLevel;
    result.isGenerated = false;
    result.sourcePath = file.getFullPathName();
    
    // 3. Na캜ten칤 dat
    std::unique_ptr<juce::AudioFormatReader> reader(formatManager_.createReaderFor(file));
    
    if (analysis.needsResampling) {
        // Resample data
        // ... resampling logic
    } else {
        // Direct load
        reader->read(result.audioData.get(), 1, 0, analysis.originalLengthSamples);
    }
    
    return result;
}
```

### 2. Roz코칤콏en칳 SampleLibrary

**SampleLibrary.h zm캩ny**
```cpp
struct SampleSegment {
    std::array<std::unique_ptr<float[]>, 8> dynamicLayers;
    std::array<uint32_t, 8> layerLengthSamples;  // Variable length per layer
    uint8_t midiNote;
    std::array<bool, 8> layerAllocated{false};
    
    uint32_t getLayerLength(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8) ? layerLengthSamples[dynamicLevel] : 0;
    }
    
    const float* getLayerData(uint8_t dynamicLevel) const {
        return (dynamicLevel < 8 && layerAllocated[dynamicLevel]) 
               ? dynamicLayers[dynamicLevel].get() : nullptr;
    }
};

class SampleLibrary {
public:
    // Roz코칤콏en칠 API
    const float* getSampleData(uint8_t midiNote, uint8_t dynamicLevel) const;
    uint32_t getSampleLength(uint8_t midiNote, uint8_t dynamicLevel) const;
    uint8_t velocityToDynamicLevel(uint8_t velocity) const;
    
    // Loading statistics
    struct LoadingStats {
        int totalSamples;
        int loadedFromFiles;
        int generatedSines;
        size_t totalMemoryUsed;
        double loadingTimeSeconds;
    };
    
    LoadingStats getLoadingStats() const { return loadingStats_; }
    
private:
    LoadingStats loadingStats_;
    void storeSample(const LoadedSample& sample);
    
    static constexpr std::array<float, 8> DYNAMIC_AMPLITUDES = {
        0.05f, 0.12f, 0.22f, 0.35f, 0.50f, 0.68f, 0.85f, 1.00f
    };
};
```

**SampleLibrary.cpp zm캩ny**
```cpp
void SampleLibrary::initialize(double sampleRate) {
    auto startTime = juce::Time::getMillisecondCounterHiRes();
    
    sampleRate_ = sampleRate;
    clear();
    
    // Use SampleLoader
    SampleLoader loader(sampleRate);
    juce::File instrumentDir = SampleLoader::getDefaultInstrumentDirectory();
    
    // Ensure directory exists
    if (!instrumentDir.exists()) {
        instrumentDir.createDirectory();
        logger_.log("SampleLibrary", "info", "Created instrument directory: " + instrumentDir.getFullPathName());
    }
    
    auto progressCallback = [this](int current, int total, const juce::String& status) {
        logger_.log("SampleLibrary", "info", 
                   "Progress: " + juce::String(current) + "/" + juce::String(total) + " - " + status);
    };
    
    std::vector<LoadedSample> loadedSamples = loader.loadInstrument(instrumentDir, progressCallback);
    
    // Store samples
    loadingStats_.totalSamples = static_cast<int>(loadedSamples.size());
    for (const auto& sample : loadedSamples) {
        storeSample(sample);
        if (sample.isGenerated) {
            loadingStats_.generatedSines++;
        } else {
            loadingStats_.loadedFromFiles++;
        }
        loadingStats_.totalMemoryUsed += sample.lengthSamples * sizeof(float);
    }
    
    loadingStats_.loadingTimeSeconds = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;
    
    logger_.log("SampleLibrary", "info", 
               "Loading complete: " + juce::String(loadingStats_.loadedFromFiles) + " WAV files, " + 
               juce::String(loadingStats_.generatedSines) + " generated, " +
               juce::String(loadingStats_.totalMemoryUsed / (1024*1024)) + "MB, " +
               juce::String(loadingStats_.loadingTimeSeconds, 2) + "s");
}

uint8_t SampleLibrary::velocityToDynamicLevel(uint8_t velocity) const {
    // Map velocity 0-127 to dynamic level 0-7
    return std::min(7, velocity / 16);
}
```

### 3. Voice Management 칰pravy

**SynthVoice.h zm캩ny**
```cpp
class SynthVoice {
private:
    uint8_t currentDynamicLevel_{0};
    uint32_t currentSampleLength_{0};  // Variable per sample
    
public:
    void start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library);
    uint8_t getDynamicLevel() const { return currentDynamicLevel_; }
};
```

**SynthVoice.cpp zm캩ny**
```cpp
void SynthVoice::start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library) {
    reset();
    
    midiNote_ = midiNote;
    velocity_ = velocity;
    currentDynamicLevel_ = library.velocityToDynamicLevel(velocity);
    
    // Get specific dynamic layer
    sampleData_ = library.getSampleData(midiNote, currentDynamicLevel_);
    currentSampleLength_ = library.getSampleLength(midiNote, currentDynamicLevel_);
    
    if (!sampleData_ || currentSampleLength_ == 0) {
        logger_.log("SynthVoice", "error", 
                   "Invalid sample for note " + juce::String((int)midiNote) + 
                   " level " + juce::String((int)currentDynamicLevel_));
        isActive_ = false;
        return;
    }
    
    position_ = 0;
    isActive_ = true;
    
    logger_.log("SynthVoice", "debug", 
               "Started note " + juce::String((int)midiNote) + 
               " level " + juce::String((int)currentDynamicLevel_) +
               " length " + juce::String(currentSampleLength_) + " samples");
}

void SynthVoice::render(float* outputBuffer, int numSamples) {
    if (!isActive_ || sampleData_ == nullptr || currentSampleLength_ == 0)
        return;
    
    // No real-time gain - pre-computed in dynamic layers
    for (int i = 0; i < numSamples; ++i) {
        if (position_ >= currentSampleLength_) {
            stop();  // Natural end based on actual sample length
            break;
        }
        outputBuffer[i] += sampleData_[position_];
        ++position_;
    }
}
```

## Dynamic Level Mapping

### Velocity  Dynamic Level
```cpp
uint8_t velocityToDynamicLevel(uint8_t velocity) {
    return std::min(7, velocity / 16);
}
```

### Dynamic Amplitudes
```cpp
static constexpr std::array<float, 8> DYNAMIC_AMPLITUDES = {
    0.05f,  // vel0 - pppp (velocity 1-16)
    0.12f,  // vel1 - ppp  (velocity 17-32)
    0.22f,  // vel2 - pp   (velocity 33-48)
    0.35f,  // vel3 - p    (velocity 49-64)
    0.50f,  // vel4 - mp   (velocity 65-80)
    0.68f,  // vel5 - mf   (velocity 81-96)
    0.85f,  // vel6 - f    (velocity 97-112)
    1.00f   // vel7 - ff   (velocity 113-127)
};
```

## Implementation Strategy

### Phase 1: SampleLoader Infrastructure
1. Create SampleLoader.h/cpp
2. Implement file analysis without loading
3. Add WAV format support
4. Test with single sample

### Phase 2: Dynamic Layers Integration
1. Modify SampleSegment structure
2. Update SampleLibrary API
3. Implement velocity뇫ynamic level mapping
4. Test with sine generation fallback

### Phase 3: Voice System Updates
1. Update SynthVoice for dynamic levels
2. Remove real-time gain calculation
3. Add variable length support
4. Test complete audio chain

### Phase 4: Error Handling & Optimization
1. Comprehensive validation
2. Memory usage optimization
3. Loading progress reporting
4. Cross-platform path handling

## Memory & Performance Characteristics

### Memory Usage
- **Variable allocation:** Based on actual sample lengths
- **Typical usage:** 200-800MB (vs 1.6GB fixed)
- **Peak usage:** Up to 4GB for very long samples
- **Optimization:** Shared data for identical samples

### Performance Benefits
- **Faster rendering:** No real-time multiplication
- **Natural endings:** Samples end when audio ends
- **Flexible dynamics:** 8 distinct amplitude levels
- **Efficient fallback:** Sine generation only when needed

### File System Benefits
- **User-friendly:** Drop WAV files in known location
- **Incremental:** Add samples as needed
- **Backward compatible:** Works without any external files
- **Debuggable:** Clear file naming and loading logs

## Technical Requirements

### WAV File Specifications
- **Format:** Standard WAV (16-bit, 24-bit, 32-bit float)
- **Channels:** Mono preferred (stereo will be converted)
- **Sample Rate:** Any (will be resampled to project rate)
- **Length:** Variable (0.1s minimum, no maximum)

### Loading Process
1. **Analyze** file metadata (length, sample rate)
2. **Validate** file integrity and specifications
3. **Calculate** memory requirements
4. **Allocate** exact memory needed
5. **Load** and optionally resample audio data
6. **Fallback** to sine generation if file missing/invalid

### Error Handling
- **Invalid files:** Skip with warning, generate sine fallback
- **Memory errors:** Graceful degradation, detailed logging
- **Directory issues:** Auto-create missing directories
- **Loading failures:** Continue with available samples

Tento syst칠m umo쮄갓je postupn칳 p콏echod od synthetic sine waves k real instrument samples se zachov치n칤m pln칠 funkcionality a performance optimizations.


===== File: VoiceManager.cpp =====
Path: C:\Users\jindr\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"
#include "Logger.h"

/**
 * @brief Konstruktor SynthVoice.
 * Inicializuje logger a resetuje stav.
 */
SynthVoice::SynthVoice()
    : logger_(Logger::getInstance())
{
    logger_.log("SynthVoice/constructor", "info", "SynthVoice inicializov치n");
    reset();
}

/**
 * @brief Spust칤 hlas s kontrolou dostupnosti vzorku.
 * @param midiNote MIDI nota
 * @param velocity Velocity
 * @param library SampleLibrary pro data
 */
void SynthVoice::start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library)
{
    logger_.log("SynthVoice/start", "info", "Spou코t캩n칤 hlasu pro notu " + juce::String(midiNote) + ", velocity " + juce::String(velocity));
    reset();

    midiNote_ = midiNote;
    velocity_ = velocity;
    currentDynamicLevel_ = library.velocityToDynamicLevel(velocity);

    sampleData_ = library.getSampleData(midiNote, currentDynamicLevel_);
    sampleLength_ = library.getSampleLength(midiNote, currentDynamicLevel_);

    if (!sampleData_ || sampleLength_ == 0) {
        logger_.log("SynthVoice/start", "error", "Neplatn칳 vzorek pro notu " + juce::String((int)midiNote) + " vrstva " + juce::String((int)currentDynamicLevel_));
        isActive_ = false;
        return;
    }

    position_ = 0;
    isActive_ = true;

    logger_.log("SynthVoice/start", "debug", "Spu코t캩na nota " + juce::String((int)midiNote) + " vrstva " + juce::String((int)currentDynamicLevel_) + " d칠lka=" + juce::String(sampleLength_));
}

void SynthVoice::stop()
{
    logger_.log("SynthVoice/stop", "debug", "Zastaven칤 hlasu pro notu " + juce::String(midiNote_));
    isActive_ = false;  // Okam쬴t칠 zastaven칤 (m콢쬰 b칳t roz코칤콏eno o release f치zi)
}

void SynthVoice::reset()
{
    logger_.log("SynthVoice/reset", "debug", "Reset hlasu");
    midiNote_ = 0;
    velocity_ = 0;
    isActive_ = false;
    sampleData_ = nullptr;
    sampleLength_ = 0;
    position_ = 0;
    queue_ = 0;  // Reset queue na dno
}

/**
 * @brief Renderuje audio s gainem podle velocity.
 * @param buffer Reference na audio buffer (stereo)
 * @param numSamples Po캜et sampl콢
 */
void SynthVoice::render(juce::AudioBuffer<float>& buffer, int numSamples)
{
    if (!isActive_ || sampleData_ == nullptr || sampleLength_ == 0) {
        logger_.log("SynthVoice/render", "debug", "Render p콏esko캜en - hlas neaktivn칤");
        return;
    }

    if (buffer.getNumChannels() < 2) {
        logger_.log("SynthVoice/render", "warn", "Buffer nem치 dost kan치l콢 pro stereo");
        return;
    }

    logger_.log("SynthVoice/render", "debug", "Za캜치tek renderov치n칤 " + juce::String(numSamples) + " sampl콢 pro notu " + juce::String(midiNote_));
    float* left = buffer.getWritePointer(0);
    float* right = buffer.getWritePointer(1);

    for (int i = 0; i < numSamples; ++i) {
        if (position_ >= sampleLength_) {
            logger_.log("SynthVoice/render", "debug", "Dohr치no, zastavuji hlas");
            stop();
            break;
        }
        left[i] += sampleData_[position_ * 2];      // Left
        right[i] += sampleData_[position_ * 2 + 1]; // Right
        ++position_;
    }
    logger_.log("SynthVoice/render", "debug", "Renderov치n칤 dokon캜eno");
}

// ======================== VoiceManager =========================

/**
 * @brief Konstruktor VoiceManager.
 * Vytvo콏칤 voices s v칳choz칤 queue=0.
 * @param library SampleLibrary
 * @param numVoices Po캜et hlas콢
 */
VoiceManager::VoiceManager(const SampleLibrary& library, int numVoices)
    : logger_(Logger::getInstance()), sampleLibrary_(library)
{
    logger_.log("VoiceManager/constructor", "info", "VoiceManager vytvo콏en s " + juce::String(numVoices) + " hlasy");
    voices_.reserve(numVoices);
    for (int i = 0; i < numVoices; ++i) {
        voices_.emplace_back(std::make_unique<SynthVoice>());
        voices_.back()->setQueue(0);  // V칳choz칤 queue na 0 (dno stacku)
    }
}

/**
 * @brief Zpracuje MIDI ud치losti (note-on/off) z queue.
 * @param midiState MidiStateManager
 * Oprava: Upraveno pro uint8_t z popNoteOn/popNoteOff, kontrola if (raw == 255)
 */
void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    logger_.log("VoiceManager/processMidiEvents", "info", "Za캜치tek zpracov치n칤 MIDI ud치lost칤");
    // Zpracov치n칤 NOTE ON
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOn(static_cast<uint8_t>(ch));  // Oprava: Explicit cast
            if (raw == 255) break;
            uint8_t note = raw;
            uint8_t vel = midiState.getVelocity(static_cast<uint8_t>(ch), note);  // Oprava: Explicit cast
            logger_.log("VoiceManager/processMidiEvents", "debug", "NoteOn kan치l " + juce::String(ch) + ", nota " + juce::String(note));
            startVoice(note, vel);
        }
    }

    // Zpracov치n칤 NOTE OFF
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            uint8_t raw = midiState.popNoteOff(static_cast<uint8_t>(ch));  // Oprava: Explicit cast
            if (raw == 255) break;
            uint8_t note = raw;
            logger_.log("VoiceManager/processMidiEvents", "debug", "NoteOff kan치l " + juce::String(ch) + ", nota " + juce::String(note));
            stopVoice(note);
        }
    }
    logger_.log("VoiceManager/processMidiEvents", "info", "Zpracov치n칤 MIDI ud치lost칤 dokon캜eno");
}

/**
 * @brief Generuje audio mixem hlas콢.
 * @param buffer Audio buffer (stereo)
 * @param numSamples Po캜et sampl콢
 */
void VoiceManager::generateAudio(juce::AudioBuffer<float>& buffer, int numSamples)
{
    logger_.log("VoiceManager/generateAudio", "info", "Za캜치tek generace audio, sampl콢: " + juce::String(numSamples));
    if (numSamples <= 0) {
        logger_.log("VoiceManager/generateAudio", "warn", "Neplatn칳 po캜et sampl콢, p콏eskakuji");
        return;
    }

    buffer.clear();  // Vy캜i코t캩n칤 stereo bufferu

    for (auto& v : voices_) {
        if (v->isActive()) v->render(buffer, numSamples);
    }
    logger_.log("VoiceManager/generateAudio", "info", "Generace audio dokon캜ena");
}

void VoiceManager::refresh()
{
    logger_.log("VoiceManager/refresh", "debug", "Refresh proveden (aktu치ln캩 pr치zdn칠)");
}

/**
 * @brief Spust칤 hlas s lep코칤m voice stealingem (inspirov치no HW syntetiz칠rem).
 * Nejprve hled치 existuj칤c칤, pak volnou s max queue, pak ukradne.
 * @param midiNote Nota
 * @param velocity Velocity
 */
void VoiceManager::startVoice(uint8_t midiNote, uint8_t velocity)
{
    logger_.log("VoiceManager/startVoice", "info", "Spou코t캩n칤 hlasu pro notu " + juce::String(midiNote) + ", velocity " + juce::String(velocity));
    // Nejprve hledej existuj칤c칤 voice pro tuto notu
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            logger_.log("VoiceManager/startVoice", "debug", "Nalezen existuj칤c칤 hlas pro notu " + juce::String(midiNote));
            v->start(midiNote, velocity, sampleLibrary_);
            mixleQueue(v->getQueue());  // P콏euspo콏치dej queue
            v->setQueue(static_cast<uint8_t>(voices_.size() - 1));  // Nastav na top
            return;
        }
    }

    // Hledej volnou voice s nejvy코코칤m queue (nejstar코칤 na top)
    SynthVoice* candidate = nullptr;
    uint8_t maxQueue = 0;
    for (auto& v : voices_) {
        if (!v->isActive() && v->getQueue() >= maxQueue) {
            candidate = v.get();
            maxQueue = v->getQueue();
        }
    }

    // Pokud nen칤 voln치, ukradni s nejvy코코칤m queue
    if (!candidate) {
        for (auto& v : voices_) {
            if (v->getQueue() >= maxQueue) {
                candidate = v.get();
                maxQueue = v->getQueue();
            }
        }
        logger_.log("VoiceManager/startVoice", "warn", "Voice stealing: ukraden voice pro notu " + juce::String((int)midiNote));
    }

    if (candidate) {
        mixleQueue(candidate->getQueue());  // P콏euspo콏치dej
        candidate->start(midiNote, velocity, sampleLibrary_);
        candidate->setQueue(static_cast<uint8_t>(voices_.size() - 1));  // Nastav na top
        logger_.log("VoiceManager/startVoice", "info", "Hlas spu코t캩n");
    } else {
        logger_.log("VoiceManager/startVoice", "error", "콯치dn칳 dostupn칳 hlas pro notu " + juce::String(midiNote));
    }
}

/**
 * @brief Zastav칤 hlas a p콏euspo콏치d치 queue.
 * @param midiNote Nota
 */
void VoiceManager::stopVoice(uint8_t midiNote)
{
    logger_.log("VoiceManager/stopVoice", "info", "Zastavov치n칤 hlasu pro notu " + juce::String(midiNote));
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->stop();
            mixleQueue(v->getQueue());  // P콏euspo콏치dej po uvoln캩n칤
            v->setQueue(0);  // Reset na dno
            logger_.log("VoiceManager/stopVoice", "info", "Hlas zastaven");
            return;
        }
    }
    logger_.log("VoiceManager/stopVoice", "warn", "콯치dn칳 aktivn칤 hlas pro notu " + juce::String(midiNote));
}

/**
 * @brief P콏euspo콏치d치 queue: Posune vybranou na dno, ostatn칤 posune nahoru/dol콢.
 * @param queueNumber 캛칤slo queue k mixlov치n칤
 */
void VoiceManager::mixleQueue(uint8_t queueNumber) {
    logger_.log("VoiceManager/mixleQueue", "debug", "P콏euspo콏치d치n칤 queue pro 캜칤slo " + juce::String(queueNumber));
    for (auto& v : voices_) {
        if (v->getQueue() == queueNumber) {
            v->setQueue(0);  // Posun na dno
        } else if (v->getQueue() > queueNumber) {
            v->setQueue(v->getQueue() - 1);  // Posun dol콢
        } else {
            v->setQueue(v->getQueue() + 1);  // Posun nahoru
        }
    }
    logger_.log("VoiceManager/mixleQueue", "debug", "Queue p콏euspo콏치d치na");
}

int VoiceManager::getActiveVoiceCount() const
{
    int count = 0;
    for (const auto& voice : voices_) {
        if (voice->isActive()) ++count;
    }
    logger_.log("VoiceManager/getActiveVoiceCount", "debug", "Aktivn칤ch hlas콢: " + juce::String(count));
    return count;
}


===== File: VoiceManager.h =====
Path: C:\Users\jindr\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <cstdint>
#include <memory>
#include <vector>
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "Logger.h"
#include <juce_audio_basics/juce_audio_basics.h>  // Pro AudioBuffer

/**
 * @class SynthVoice
 * @brief Jednoduch칳 renderer pro jeden hlas (voice), dr쮂 data vzorku a pozici.
 * 
 * Renderuje audio z readonly dat SampleLibrary. Podporuje start/stop/reset a rendering do stereo bufferu.
 * Nov캩 p콏id치na queue pro voice stealing (priorita: vy코코칤 = nov캩j코칤).
 */
class SynthVoice
{
public:
    /**
     * @brief Konstruktor SynthVoice.
     * Inicializuje logger a resetuje stav.
     */
    SynthVoice();

    /**
     * @brief Spust칤 hlas s kontrolou dostupnosti vzorku.
     * @param midiNote MIDI nota
     * @param velocity Velocity
     * @param library SampleLibrary pro data
     */
    void start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library);

    /**
     * @brief Zastav칤 hlas (deaktivuje ho).
     */
    void stop();

    /**
     * @brief Resetuje hlas do v칳choz칤ho stavu.
     */
    void reset();

    /**
     * @brief Renderuje audio do stereo bufferu (p콏i캜칤t치 k existuj칤c칤m dat콢m).
     * @param buffer Reference na audio buffer
     * @param numSamples Po캜et sampl콢 k renderov치n칤
     */
    void render(juce::AudioBuffer<float>& buffer, int numSamples);

    bool isActive() const { return isActive_; }  // Vr치t칤, zda je hlas aktivn칤
    uint8_t getNote() const { return midiNote_; }  // Vr치t칤 aktu치ln칤 notu
    uint8_t getQueue() const { return queue_; }  // Vr치t칤 prioritu queue
    void setQueue(uint8_t queue) { queue_ = queue; }  // Nastav칤 prioritu queue

private:
    Logger& logger_;  // Reference na logger

    uint8_t midiNote_{0};  // Aktu치ln칤 MIDI nota
    uint8_t velocity_{0};  // Velocity
    bool isActive_{false};  // Stav aktivity

    const float* sampleData_{nullptr};  // Ukazatel na data vzorku (interleaved stereo)
    uint32_t sampleLength_{0};  // D칠lka vzorku (pro jeden kan치l)
    uint32_t position_{0};  // Aktu치ln칤 pozice v vzorku

    uint8_t queue_{0};  // Prioritn칤 queue pro stealing (0 = dno, vy코코칤 = top)
    uint8_t currentDynamicLevel_{0};  // Aktu치ln칤 dynamick치 vrstva
};

/**
 * @class VoiceManager
 * @brief Spravuje kolekci hlas콢 (voices), zpracov치v치 MIDI ud치losti a generuje audio.
 * 
 * Vy쬬duje SampleLibrary. Podporuje voice stealing inspirovan칳 HW syntetiz칠rem (s queue prioritou).
 * Procesuje MIDI z MidiStateManager a mixuje audio z hlas콢 do stereo bufferu.
 */
class VoiceManager
{
public:
    /**
     * @brief Konstruktor s referenc칤 na SampleLibrary.
     * @param library Reference na SampleLibrary
     * @param numVoices Po캜et hlas콢 (v칳choz칤 16)
     */
    VoiceManager(const SampleLibrary& library, int numVoices = 16);

    ~VoiceManager() = default;

    /**
     * @brief Zpracuje MIDI ud치losti z MidiStateManager (note-on/off).
     * @param midiState Reference na MidiStateManager
     */
    void processMidiEvents(MidiStateManager& midiState);

    /**
     * @brief Generuje audio mixem v코ech aktivn칤ch hlas콢.
     * @param buffer Reference na audio buffer (stereo)
     * @param numSamples Po캜et sampl콢
     */
    void generateAudio(juce::AudioBuffer<float>& buffer, int numSamples);

    /**
     * @brief Housekeeping: M콢쬰 b칳t roz코칤콏eno (aktu치ln캩 pr치zdn칠).
     */
    void refresh();

    /**
     * @brief Vr치t칤 po캜et aktivn칤ch hlas콢 (pro debug a monitoring).
     * @return Po캜et aktivn칤ch hlas콢
     */
    int getActiveVoiceCount() const;

private:
    Logger& logger_;  // Reference na logger
    const SampleLibrary& sampleLibrary_;  // Povinn치 reference na vzorky
    std::vector<std::unique_ptr<SynthVoice>> voices_;  // Kolekce hlas콢

    /**
     * @brief Spust칤 hlas pro danou notu (s voice stealingem).
     * @param midiNote MIDI nota
     * @param velocity Velocity
     */
    void startVoice(uint8_t midiNote, uint8_t velocity);

    /**
     * @brief Zastav칤 hlas pro danou notu.
     * @param midiNote MIDI nota
     */
    void stopVoice(uint8_t midiNote);

    /**
     * @brief P콏euspo콏치d치 queue priorit (posune vybranou na dno, ostatn칤 posune).
     * @param queueNumber 캛칤slo queue k mixlov치n칤
     */
    void mixleQueue(uint8_t queueNumber);
};



===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"
#include <iomanip>
#include <sstream>

// Inicializace globálního přepínače
std::atomic<bool> Logger::loggingEnabled{true};

//==============================================================================
Logger::Logger()
{
    // Základní inicializace - žádné další akce v konstruktoru
}

Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

//==============================================================================
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    // Quick check bez mutex - optimalizace pro častý případ kdy je logování vypnuté
    if (!loggingEnabled.load(std::memory_order_relaxed)) {
        return;
    }
    
    try {
        // Vytvoření timestampu
        auto now = juce::Time::getCurrentTime();
        juce::String timestamp = now.formatted("%Y-%m-%d %H:%M:%S");
        
        // Formátování log entry
        juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;
        
        // Thread-safe přidání do bufferu
        pushToLogQueue(logEntry);
        
        // Asynchronní update GUI
        scheduleGUIUpdate();
        
    } catch (const std::exception& e) {
        // Fallback - pokud selže logování, alespoň to nezpůsobí crash
        // V produkční verzi by se mohlo logovat do souboru
        juce::ignoreUnused(e);
    }
}

void Logger::pushToLogQueue(const juce::String& logEntry)
{
    std::lock_guard<std::mutex> lock(logMutex_);
    
    // Atomický přístup k write indexu
    uint8_t writeIndex = logQueue_.writeIndex.load();
    uint8_t currentCount = logQueue_.count.load();
    
    // Zápis do bufferu
    logQueue_.logs[writeIndex] = logEntry;
    
    // Aktualizace indexů
    uint8_t newWriteIndex = static_cast<uint8_t>(writeIndex + 1);  // uint8 overflow = automatic wrap
    logQueue_.writeIndex.store(newWriteIndex);
    
    if (currentCount < 256) {
        logQueue_.count.store(currentCount + 1);
    } else {
        // Sliding window: posunutí read indexu
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + 1);
    }
    
    // Omezení na MAX_LOG_ENTRIES
    if (logQueue_.count.load() > MAX_LOG_ENTRIES) {
        uint8_t excess = logQueue_.count.load() - MAX_LOG_ENTRIES;
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + excess);
        logQueue_.count.store(MAX_LOG_ENTRIES);
    }
}

//==============================================================================
void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    std::lock_guard<std::mutex> lock(editorMutex_);
    // OPRAVA: Ukládáme jako weak_ptr místo raw pointeru
    if (ed != nullptr) {
        // V reálné implementaci bychom potřebovali shared_ptr z editoru
        // Pro tento příklad používáme raw pointer s opatrnou kontrolou
        editorWeakPtr_ = std::shared_ptr<AudioPluginAudioProcessorEditor>(ed, [](AudioPluginAudioProcessorEditor*){
            // No-op deleter, protože editor se spravuje jinde
        });
    } else {
        editorWeakPtr_.reset();
    }
}

void Logger::scheduleGUIUpdate()
{
    // OPRAVA: Bezpečnější async GUI update
    juce::MessageManager::callAsync([this]() {
        std::lock_guard<std::mutex> lock(editorMutex_);
        
        // Pokusíme se získat shared_ptr z weak_ptr
        if (auto editor = editorWeakPtr_.lock()) {
            editor->updateLogDisplay();
        }
        // Pokud weak_ptr je prázdný, editor už neexistuje a bezpečně ignorujeme
    });
}

//==============================================================================
juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}

juce::StringArray Logger::getCurrentLogs() const
{
    std::lock_guard<std::mutex> lock(logMutex_);
    
    juce::StringArray result;
    
    uint8_t currentCount = logQueue_.count.load();
    uint8_t readIndex = logQueue_.readIndex;
    
    // Čtení logů z circular bufferu
    for (uint8_t i = 0; i < currentCount; ++i) {
        uint8_t index = static_cast<uint8_t>(readIndex + i);  // uint8 automatic wrap
        result.add(logQueue_.logs[index]);
    }
    
    return result;
}

void Logger::clearLogs()
{
    std::lock_guard<std::mutex> lock(logMutex_);
    
    // Reset circular bufferu
    logQueue_.writeIndex.store(0);
    logQueue_.count.store(0);
    logQueue_.readIndex = 0;
    
    // Vymazání obsahu (pro úplnost)
    for (auto& log : logQueue_.logs) {
        log = juce::String();
    }
}

size_t Logger::getLogCount() const
{
    return logQueue_.count.load(std::memory_order_relaxed);
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>
#include <mutex>
#include <array>
#include <memory>

// Definice maximálního počtu logovacích záznamů (sliding window)
#define MAX_LOG_ENTRIES 100

// Forward declaration pro AudioPluginAudioProcessorEditor
class AudioPluginAudioProcessorEditor;

/**
 * Logger - thread-safe singleton pro logování událostí v pluginu
 * Opravená implementace s proper thread safety a exception handling
 */
class Logger
{
public:
    // Singleton access
    static Logger& getInstance();
    
    // Hlavní logovací metoda - thread-safe
    void log(const juce::String& component, const juce::String& severity, const juce::String& message);
    
    // Globální přepínač pro zapnutí/vypnutí logování
    static std::atomic<bool> loggingEnabled;
    
    // Thread-safe nastavení reference na editor s weak pointer pattern
    void setEditor(AudioPluginAudioProcessorEditor* ed);
    
    // Thread-safe getter pro logy
    juce::StringArray getLogBuffer() const;
    
    // Utility metody
    void clearLogs();
    size_t getLogCount() const;

private:
    // Privátní konstruktor pro singleton
    Logger();
    ~Logger() = default;
    
    // Zabrání kopírování
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    
    // Thread-safe circular buffer pro logy
    struct LogQueue {
        std::array<juce::String, 256> logs;  // Fixed size array
        std::atomic<uint8_t> writeIndex{0};  // Atomický write index
        std::atomic<uint8_t> count{0};       // Atomický počítadlo
        uint8_t readIndex{0};                // Read index (protected by mutex)
        
        LogQueue() = default;
    };
    
    LogQueue logQueue_;
    
    // Thread safety
    mutable std::mutex logMutex_;        // Mutex pro přístup k buffer
    mutable std::mutex editorMutex_;     // Mutex pro editor reference
    
    // OPRAVA: Weak pointer pattern pro bezpečný přístup k editoru
    std::weak_ptr<AudioPluginAudioProcessorEditor> editorWeakPtr_;
    
    // Helper metody
    void pushToLogQueue(const juce::String& logEntry);
    juce::StringArray getCurrentLogs() const;  // Thread-safe internal getter
    
    // OPRAVA: Bezpečnější async GUI update
    void scheduleGUIUpdate();
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"
#include <algorithm>
#include <cassert>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

//==============================================================================
MidiStateManager::MidiStateManager()
    : logger_(Logger::getInstance())
{
    logger_.log("MidiStateManager/constructor", "info", "=== INICIALIZACE MIDI STATE MANAGER ===");
    
    // Inicializace aktivních not
    for (auto& note : activeNotes_) {
        note.reset();
    }
    
    // Inicializace MIDI controller hodnot podle standardu
    for (int channel = 0; channel < 16; channel++) {
        for (int controller = 0; controller < 128; controller++) {
            controllerValues_[channel][controller] = 0;
        }
        
        // Výchozí hodnoty pro standardní controllery
        controllerValues_[channel][7] = 100;   // Volume (0-127, default high)
        controllerValues_[channel][10] = 64;   // Pan (0-127, default center)
        controllerValues_[channel][11] = 127;  // Expression (0-127, default max)
        controllerValues_[channel][64] = 0;    // Sustain pedal (0-127, default off)
        controllerValues_[channel][91] = 0;    // Reverb (0-127, default off)
        controllerValues_[channel][93] = 0;    // Chorus (0-127, default off)
    }
    
    // Reset všech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    logger_.log("MidiStateManager/constructor", "info", 
                "Max aktivnich not: " + juce::String(MAX_ACTIVE_NOTES));
    logger_.log("MidiStateManager/constructor", "info", 
                "MIDI channels: 16, Controllers: 128 per channel");
    logger_.log("MidiStateManager/constructor", "info", 
                "=== MIDI STATE MANAGER INICIALIZOVAN ===");
}

//==============================================================================
void MidiStateManager::processMidiBuffer(const juce::MidiBuffer& midiBuffer)
{
    // Počítadlo pro optimalizaci logování
    static uint32_t processedMessages = 0;
    int messagesInBuffer = 0;
    
    for (const auto& midiMetadata : midiBuffer) {
        auto message = midiMetadata.getMessage();
        processedMessages++;
        messagesInBuffer++;
        totalMidiMessages_.fetch_add(1, std::memory_order_relaxed);
        
        // Zpracování různých typů MIDI zpráv
        if (message.isNoteOn()) {
            // MIDI Note On s velocity 0 se považuje za Note Off podle standardu
            if (message.getVelocity() == 0) {
                putNoteOff(message.getChannel() - 1, message.getNoteNumber());
            } else {
                putNoteOn(message.getChannel() - 1, message.getNoteNumber(), message.getVelocity());
            }
        }
        else if (message.isNoteOff()) {
            putNoteOff(message.getChannel() - 1, message.getNoteNumber());
        }
        else if (message.isPitchWheel()) {
            // Převod z JUCE rozsahu (0-16383) na signed int16 (-8192 až +8191)
            int pitchWheelValue = message.getPitchWheelValue() - 8192;
            setPitchWheel(static_cast<int16_t>(pitchWheelValue));
        }
        else if (message.isController()) {
            setControllerValue(message.getChannel() - 1, 
                             message.getControllerNumber(), 
                             message.getControllerValue());
        }
        else if (message.isProgramChange()) {
            logger_.log("MidiStateManager/processMidiBuffer", "info",
                       "Program Change: " + juce::String(message.getProgramChangeNumber()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        else if (message.isChannelPressure()) {
            logger_.log("MidiStateManager/processMidiBuffer", "debug",
                       "Channel Pressure: " + juce::String(message.getChannelPressureValue()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        else if (message.isAftertouch()) {
            logger_.log("MidiStateManager/processMidiBuffer", "debug",
                       "Aftertouch: nota " + juce::String(message.getNoteNumber()) + 
                       " pressure " + juce::String(message.getAfterTouchValue()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        
        // Detailní logování pouze pro první zprávy nebo při debug režimu
        if (processedMessages <= 10) {
            juce::String midiInfo = "MIDI #" + juce::String(processedMessages) + 
                                   " @ sample " + juce::String(midiMetadata.samplePosition);
            
            if (message.isNoteOn() && message.getVelocity() > 0) {
                midiInfo += ": NOTE ON - " + 
                           message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + 
                           " vel:" + juce::String(message.getVelocity()) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isNoteOff() || (message.isNoteOn() && message.getVelocity() == 0)) {
                midiInfo += ": NOTE OFF - " + 
                           message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isPitchWheel()) {
                midiInfo += ": PITCH WHEEL - " + juce::String(message.getPitchWheelValue()) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isController()) {
                midiInfo += ": CC" + juce::String(message.getControllerNumber()) + 
                           " = " + juce::String(message.getControllerValue()) + 
                           " ch:" + juce::String(message.getChannel());
            } else {
                midiInfo += ": " + message.getDescription();
            }
            
            logger_.log("MidiStateManager/processMidiBuffer", "info", midiInfo);
        }
    }
    
    // Logování souhrnu pro buffer s více zprávami
    if (messagesInBuffer > 1) {
        logger_.log("MidiStateManager/processMidiBuffer", "info",
                   "Buffer zpracovan: " + juce::String(messagesInBuffer) + 
                   " zprav (celkem: " + juce::String(totalMidiMessages_.load()) + ")");
    }
}

//==============================================================================
void MidiStateManager::putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity)
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        logger_.log("MidiStateManager/putNoteOn", "warn", 
                   "Neplatny channel nebo key: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOn", "info", 
               "Note ON - Ch:" + juce::String(channel) + 
               " Key:" + juce::String(key) + 
               " Vel:" + juce::String(velocity));
    
    // OPRAVA: Unified locking strategy
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Hledání existujícího slotu nebo volného slotu
    int slot = findNoteSlot(channel, key);
    if (slot == -1) {
        slot = findFreeSlot();
    }
    
    if (slot != -1) {
        activeNotes_[slot].channel = channel;
        activeNotes_[slot].key = key;
        activeNotes_[slot].velocity = velocity;
        activeNotes_[slot].isActive = true;
        activeNotes_[slot].triggerTime = juce::Time::getMillisecondCounter();
        
        // Přidání do queue pro VoiceManager
        pushToQueue(noteOnQueues_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOn", "warn", 
                   "Zadny volny slot pro notu - zvyste MAX_ACTIVE_NOTES");
    }
}

void MidiStateManager::putNoteOff(uint8_t channel, uint8_t key)
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        logger_.log("MidiStateManager/putNoteOff", "warn", 
                   "Neplatny channel nebo key: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOff", "info", 
               "Note OFF - Ch:" + juce::String(channel) + 
               " Key:" + juce::String(key));
    
    // OPRAVA: Unified locking strategy
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Hledání a deaktivace noty
    int slot = findNoteSlot(channel, key);
    if (slot != -1) {
        activeNotes_[slot].isActive = false;
        
        // Přidání do note-off queue
        pushToQueue(noteOffQueues_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOff", "debug", 
                   "Note OFF pro neaktivni notu: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        
        // I neaktivní nota může potřebovat note-off (pro voice cleanup)
        pushToQueue(noteOffQueues_[channel], key);
    }
}

//==============================================================================
uint8_t MidiStateManager::popNoteOn(uint8_t channel)
{
    if (!isValidChannel(channel)) {
        return 0xff;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return popFromQueue(noteOnQueues_[channel]);
}

uint8_t MidiStateManager::popNoteOff(uint8_t channel)
{
    if (!isValidChannel(channel)) {
        return 0xff;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return popFromQueue(noteOffQueues_[channel]);
}

//==============================================================================
uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t key) const
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        return 0;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int slot = findNoteSlot(channel, key);
    if (slot != -1 && activeNotes_[slot].isActive) {
        return activeNotes_[slot].velocity;
    }
    
    return 0; // Výchozí velocity pro neaktivní notu
}

bool MidiStateManager::isNoteActive(uint8_t channel, uint8_t key) const
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        return false;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int slot = findNoteSlot(channel, key);
    return (slot != -1 && activeNotes_[slot].isActive);
}

//==============================================================================
void MidiStateManager::setPitchWheel(int16_t pitchWheelValue)
{
    pitchWheel_.store(pitchWheelValue, std::memory_order_relaxed);
    
    logger_.log("MidiStateManager/setPitchWheel", "debug", 
               "Pitch wheel: " + juce::String(pitchWheelValue));
}

//==============================================================================
void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
{
    if (!isValidChannel(channel) || !isValidController(controller)) {
        logger_.log("MidiStateManager/setControllerValue", "warn", 
                   "Neplatny channel nebo controller: ch=" + juce::String(channel) + 
                   " cc=" + juce::String(controller));
        return;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    controllerValues_[channel][controller] = value;
    
    // Logování pouze pro důležité controllery
    if (controller == 1 || controller == 7 || controller == 10 || controller == 64 || 
        controller == 91 || controller == 93) {
        
        juce::String ccName = "CC" + juce::String(controller);
        switch (controller) {
            case 1: ccName = "Modulation"; break;
            case 7: ccName = "Volume"; break;
            case 10: ccName = "Pan"; break;
            case 64: ccName = "Sustain"; break;
            case 91: ccName = "Reverb"; break;
            case 93: ccName = "Chorus"; break;
        }
        
        logger_.log("MidiStateManager/setControllerValue", "info", 
                   ccName + " Ch:" + juce::String(channel) + 
                   " Val:" + juce::String(value));
    }
}

uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const
{
    if (!isValidChannel(channel) || !isValidController(controller)) {
        return 0;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return controllerValues_[channel][controller];
}

//==============================================================================
void MidiStateManager::logActiveNotes() const
{
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int activeCount = 0;
    juce::String noteList;
    
    for (const auto& note : activeNotes_) {
        if (note.isActive) {
            activeCount++;
            if (noteList.isNotEmpty()) noteList += ", ";
            noteList += juce::String(note.key) + "(ch" + juce::String(note.channel) + ")";
        }
    }
    
    logger_.log("MidiStateManager/logActiveNotes", "debug", 
               "Aktivnich not: " + juce::String(activeCount) + " [" + noteList + "]");
}

int MidiStateManager::getActiveNoteCount() const
{
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int count = 0;
    for (const auto& note : activeNotes_) {
        if (note.isActive) {
            count++;
        }
    }
    return count;
}

void MidiStateManager::resetAllNotes()
{
    logger_.log("MidiStateManager/resetAllNotes", "info", "=== RESET VSECH NOT ===");
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Reset všech aktivních not
    for (auto& note : activeNotes_) {
        note.reset();
    }
    
    // Reset všech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    // Reset pitch wheel
    pitchWheel_.store(0);
    
    logger_.log("MidiStateManager/resetAllNotes", "info", "Vse resetovano");
}

//==============================================================================
// Private helper methods
//==============================================================================

int MidiStateManager::findNoteSlot(uint8_t channel, uint8_t key) const
{
    // Metoda se volá již v rámci mutex lock
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].channel == channel && activeNotes_[i].key == key) {
            return i;
        }
    }
    return -1; // Slot nenalezen
}

int MidiStateManager::findFreeSlot() const
{
    // Metoda se volá již v rámci mutex lock
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (!activeNotes_[i].isActive) {
            return i;
        }
    }
    return -1; // Žádný volný slot
}

void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note)
{
    // OPRAVA: Už jsme v unified mutex lock, nepotřebujeme další lock
    uint8_t currentCount = queue.count.load();
    if (currentCount < 255) {  // Ponecháme místo pro wrap-around detection
        uint8_t writeIndex = queue.writeIndex.load();
        queue.notes[writeIndex] = note;
        queue.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));  // uint8 auto wrap
        queue.count.store(currentCount + 1);
    } else {
        // Queue overflow - starší zprávy se ztratí (sliding window)
        logger_.log("MidiStateManager/pushToQueue", "warn", 
                   "Queue overflow - zprava ztracena");
    }
}

uint8_t MidiStateManager::popFromQueue(NoteQueue& queue)
{
    // OPRAVA: Už jsme v unified mutex lock, nepotřebujeme další lock
    uint8_t currentCount = queue.count.load();
    if (currentCount > 0) {
        uint8_t note = queue.notes[queue.readIndex];
        queue.readIndex = static_cast<uint8_t>(queue.readIndex + 1);  // uint8 auto wrap
        queue.count.store(currentCount - 1);
        return note;
    }
    
    return 0xff; // Fronta je prázdná
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <array>
#include <atomic>
#include "Logger.h"

/**
 * ActiveNote - struktura reprezentující aktivní MIDI notu
 * Optimalizovaná pro rychlý přístup a cache efficiency
 */
struct ActiveNote {
    uint8_t key;                // MIDI nota (0-127)
    uint8_t velocity;           // Velocity (0-127)
    uint8_t channel;            // MIDI channel (0-15)
    bool isActive;              // Flag indikující aktivní stav noty
    uint32_t triggerTime;       // Timestamp spuštění noty (pro voice stealing)
    
    // Konstruktor s výchozími hodnotami
    ActiveNote() : key(0), velocity(0), channel(0), isActive(false), triggerTime(0) {}
    
    // Reset metoda pro opětovné použití
    void reset() {
        key = 0;
        velocity = 0;
        channel = 0;
        isActive = false;
        triggerTime = 0;
    }
};

/**
 * NoteQueue - optimalizovaný circular buffer pro MIDI noty
 * Používá uint8 pro automatický wrap-around
 */
struct NoteQueue {
    std::array<uint8_t, 256> notes;     // Fixed array pro noty
    std::atomic<uint8_t> writeIndex{0}; // Thread-safe write index
    std::atomic<uint8_t> count{0};      // Thread-safe počítadlo
    uint8_t readIndex{0};               // Read index (protected by mutex)
    
    NoteQueue() {
        notes.fill(0xff);  // Vyplnění invalid hodnotou
    }
    
    // Reset metoda
    void reset() {
        writeIndex.store(0);
        count.store(0);
        readIndex = 0;
        notes.fill(0xff);
    }
};

/**
 * MidiStateManager - centrální správa MIDI stavu
 * OPRAVA: Unified mutex strategy pro thread safety
 */
class MidiStateManager 
{
public:
    MidiStateManager();
    ~MidiStateManager() = default;
    
    // Hlavní MIDI processing metoda
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer);
    
    // Note management - OPRAVA: Thread-safe s konzistentním lockingem
    void putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity);
    void putNoteOff(uint8_t channel, uint8_t key);
    
    // Queue access pro VoiceManager - OPRAVA: Thread-safe
    uint8_t popNoteOn(uint8_t channel);   // Vrací key nebo 0xff pokud žádný není
    uint8_t popNoteOff(uint8_t channel);  // Vrací key nebo 0xff pokud žádný není
    
    // Note state queries - OPRAVA: Thread-safe
    uint8_t getVelocity(uint8_t channel, uint8_t key) const;
    bool isNoteActive(uint8_t channel, uint8_t key) const;
    
    // Pitch wheel management
    void setPitchWheel(int16_t pitchWheelValue);
    int16_t getPitchWheel() const { return pitchWheel_.load(); }
    
    // Controller management - OPRAVA: Thread-safe
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;
    
    // Utility methods
    void logActiveNotes() const;
    int getActiveNoteCount() const;
    void resetAllNotes();  // Emergency reset
    
    // Statistics
    uint32_t getTotalMidiMessages() const { return totalMidiMessages_.load(); }

private:
    // Note storage
    static const int MAX_ACTIVE_NOTES = 128;
    std::array<ActiveNote, MAX_ACTIVE_NOTES> activeNotes_;
    
    // MIDI state
    std::atomic<int16_t> pitchWheel_{0};                    // Thread-safe pitch wheel
    std::array<std::array<uint8_t, 128>, 16> controllerValues_;  // [channel][controller]
    
    // Event queues pro každý MIDI channel
    std::array<NoteQueue, 16> noteOnQueues_;
    std::array<NoteQueue, 16> noteOffQueues_;
    
    // OPRAVA: Unified thread safety - jeden mutex pro všechny MIDI operace
    mutable std::mutex midiMutex_;         // Unified mutex pro všechny MIDI operace
    
    // Statistics a debugging
    std::atomic<uint32_t> totalMidiMessages_{0};
    Logger& logger_;
    
    // Helper methods
    int findNoteSlot(uint8_t channel, uint8_t key) const;
    int findFreeSlot() const;
    void pushToQueue(NoteQueue& queue, uint8_t note);
    uint8_t popFromQueue(NoteQueue& queue);
    
    // Validation helpers
    bool isValidChannel(uint8_t channel) const { return channel < 16; }
    bool isValidKey(uint8_t key) const { return key < 128; }
    bool isValidController(uint8_t controller) const { return controller < 128; }
    
    // Kopírování zakázáno
    MidiStateManager(const MidiStateManager&) = delete;
    MidiStateManager& operator=(const MidiStateManager&) = delete;
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    
    // Logování vytváření editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytvářeni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lepší čitelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmavě šedé pozadí
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelený text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmavý okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tlačítka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vyčištění display při vypnutí
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // Přidání tlačítka pro vyčištění logů
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastavení reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Rozšířená velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKONČENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logování před destrukcí
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstranění reference při destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    // Logování pouze při prvním vykreslení
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozadí
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horní sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Oddělovací čára
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    // Logování změny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozložení komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zabírá většinu místa
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tlačítka ve spodní části
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    // Získání bufferu z Loggeru přes getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestavení textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastavení textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledování nových událostí
    logDisplay->moveCaretToEnd();
    
    // Jednoduchý scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logování a ovládání
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       ),
       synthState_(SynthState::Uninitialized),
       currentSampleRate_(0.0),
       processBlockCount_(0),
       totalMidiEvents_(0)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== APLIKACE SPUSTENA ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Inicializace procesoru");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Plugin nazev: " + getName());
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Je synthesizer: " + juce::String(JucePlugin_IsSynth ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Prijima MIDI: " + juce::String(acceptsMidi() ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Produkuje MIDI: " + juce::String(producesMidi() ? "ANO" : "NE"));
    
    // Komponenty se vytvoří až v prepareToPlay kdy známe sample rate
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", 
                              "Stav: " + getStateDescription());
}

AudioPluginAudioProcessor::~AudioPluginAudioProcessor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== APLIKACE SE UKONCUJE ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Zahajeni destrukce procesoru");
    
    cleanupSynth();
    Logger::getInstance().setEditor(nullptr);
    
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== DESTRUKCE DOKONCENA ===");
}

//==============================================================================
bool AudioPluginAudioProcessor::initializeSynth(double sampleRate)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "=== INICIALIZACE SYNTH KOMPONENT ===");
    
    // OPRAVA: Nastavení stavu na Initializing
    synthState_.store(SynthState::Initializing);
    
    try {
        // Vytvoření komponent v správném pořadí
        sampleLibrary_ = std::make_unique<SampleLibrary>();
        sampleLibrary_->initialize(sampleRate);
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "SampleLibrary inicializovana");
        
        midiStateManager_ = std::make_unique<MidiStateManager>();
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "MidiStateManager inicializovan");
        
        voiceManager_ = std::make_unique<VoiceManager>(16);
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "VoiceManager inicializovan (16 hlasu)");
        
        currentSampleRate_ = sampleRate;
        
        // OPRAVA: Atomické nastavení stavu na Ready
        synthState_.store(SynthState::Ready);
        
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", 
                                  "=== SYNTH INICIALIZACE DOKONCENA === Stav: " + getStateDescription());
        return true;
        
    } catch (const std::exception& e) {
        handleSynthError("Chyba pri inicializaci: " + std::string(e.what()));
        return false;
    } catch (...) {
        handleSynthError("Neznama chyba pri inicializaci synth komponent");
        return false;
    }
}

void AudioPluginAudioProcessor::cleanupSynth()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/cleanupSynth", "info", "Uvolnovani synth komponent");
    
    // Uvolnění v opačném pořadí než vytvoření
    voiceManager_.reset();
    midiStateManager_.reset();
    sampleLibrary_.reset();
    
    synthState_.store(SynthState::Uninitialized);
    Logger::getInstance().log("AudioPluginAudioProcessor/cleanupSynth", "info", "Synth komponenty uvolneny");
}

void AudioPluginAudioProcessor::handleSynthError(const std::string& errorMessage)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/handleSynthError", "error", 
                              "SYNTH ERROR: " + juce::String(errorMessage));
    
    // Cleanup při chybě
    cleanupSynth();
    synthState_.store(SynthState::Error);
    
    Logger::getInstance().log("AudioPluginAudioProcessor/handleSynthError", "error", 
                              "Stav nastaven na ERROR, komponenty uvolneny");
}

juce::String AudioPluginAudioProcessor::getStateDescription() const
{
    switch (synthState_.load()) {
        case SynthState::Uninitialized: return "Neinicializovano";
        case SynthState::Initializing: return "Inicializuje se";
        case SynthState::Ready: return "Pripraveno";
        case SynthState::Error: return "Chyba";
        default: return "Neznamy stav";
    }
}

//==============================================================================
const juce::String AudioPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool AudioPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

double AudioPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int AudioPluginAudioProcessor::getNumPrograms()
{
    return 1;
}

int AudioPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void AudioPluginAudioProcessor::setCurrentProgram (int index)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setCurrentProgram", "info", "Zmena programu na index: " + juce::String(index));
    juce::ignoreUnused (index);
}

const juce::String AudioPluginAudioProcessor::getProgramName (int index)
{
    juce::ignoreUnused (index);
    return {};
}

void AudioPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/changeProgramName", "info", "Zmena nazvu programu [" + juce::String(index) + "]: " + newName);
    juce::ignoreUnused (index, newName);
}

//==============================================================================
void AudioPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== PRIPRAVA AUDIO PROCESINGU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Sample rate: " + juce::String(sampleRate, 1) + " Hz");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Buffer size: " + juce::String(samplesPerBlock) + " samples");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vstupni kanaly: " + juce::String(getTotalNumInputChannels()));
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vystupni kanaly: " + juce::String(getTotalNumOutputChannels()));
    
    // Výpočet latence
    double latencyMs = (double)samplesPerBlock / sampleRate * 1000.0;
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Odhadovana latence: " + juce::String(latencyMs, 2) + " ms");
    
    // OPRAVA: Exception-safe inicializace nebo reinicializace synth komponent
    if (synthState_.load() != SynthState::Ready || currentSampleRate_ != sampleRate) {
        if (synthState_.load() != SynthState::Uninitialized) {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Reinicializace kvuli zmene sample rate");
            cleanupSynth();
        }
        
        if (!initializeSynth(sampleRate)) {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "error", 
                                      "KRITICKA CHYBA: Inicializace synth selhala!");
            return; // Plugin zůstane v error stavu
        }
    }
    
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", 
                              "=== AUDIO PROCESSING PRIPRAVEN === Stav: " + getStateDescription());
}

void AudioPluginAudioProcessor::releaseResources()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "=== UVOLNOVANI AUDIO ZDROJU ===");
    
    // Resetování čítačů
    processBlockCount_ = 0;
    totalMidiEvents_ = 0;
    
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "Audio processing zastaven");
}

//==============================================================================
bool AudioPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    auto mainOutput = layouts.getMainOutputChannelSet();
    auto mainInput = layouts.getMainInputChannelSet();
    
    Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "debug", 
        "Kontrola layoutu - Input: " + mainInput.getDescription() + 
        ", Output: " + mainOutput.getDescription());
    
    if (mainOutput != juce::AudioChannelSet::mono() && mainOutput != juce::AudioChannelSet::stereo())
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Nepodporovany output layout: " + mainOutput.getDescription());
        return false;
    }

   #if ! JucePlugin_IsSynth
    if (mainOutput != mainInput)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Input a output layout se neshoduji");
        return false;
    }
   #endif

    return true;
  #endif
}

//==============================================================================
void AudioPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    
    // OPRAVA: Explicitní kontrola stavu s informativním logováním
    auto currentState = synthState_.load();
    if (currentState != SynthState::Ready) {
        // Vymažeme buffer a logujeme důvod
        buffer.clear();
        
        static int errorLogCount = 0;
        if (errorLogCount < 5) { // Omezíme spam v logu
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "warn", 
                                      "Audio block preskocen - stav: " + getStateDescription());
            errorLogCount++;
        }
        return;
    }
    
    // Počítadlo pro optimalizaci logování
    processBlockCount_++;
    
    // Detailní logování prvních bloků
    if (processBlockCount_ <= 3) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Audio blok #" + juce::String(processBlockCount_) + " - velikost: " + juce::String(buffer.getNumSamples()) + 
            " samples, kanaly: " + juce::String(buffer.getNumChannels()));
    } else if (processBlockCount_ % 1000 == 0) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "debug", 
            "Zpracovano " + juce::String(processBlockCount_) + " audio bloku, celkem MIDI: " + juce::String(totalMidiEvents_));
    }
    
    // MIDI EVENT PROCESSING
    if (!midiMessages.isEmpty()) {
        int midiEventsInBlock = 0;
        
        // Počítání MIDI událostí pro logování
        for (const auto& midiMetadata : midiMessages) {
            midiEventsInBlock++;
            totalMidiEvents_++;
        }
        
        if (midiEventsInBlock > 0) {
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
                "MIDI udalosti v bloku: " + juce::String(midiEventsInBlock) + 
                " (celkem: " + juce::String(totalMidiEvents_) + ")");
        }
        
        // Zpracování MIDI událostí přes MidiStateManager
        midiStateManager_->processMidiBuffer(midiMessages);
    }
    
    // VOICE MANAGEMENT - zpracování MIDI událostí do hlasů
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // AUDIO GENERATION - KRITICKÁ OPRAVA
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();
    
    // Vyčištění přebytečných výstupních kanálů
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i) {
        buffer.clear(i, 0, buffer.getNumSamples());
    }
    
    // OPRAVA: Generování audio pro každý výstupní kanál
    for (int channel = 0; channel < totalNumOutputChannels; ++channel) {
        auto* channelData = buffer.getWritePointer(channel);
        
        // Vymazání bufferu před generováním
        std::fill(channelData, channelData + buffer.getNumSamples(), 0.0f);
        
        // Generování audio ze všech hlasů
        voiceManager_->generateAudio(channelData, buffer.getNumSamples(), *sampleLibrary_);
    }
    
    // Voice management refresh (cleanup neaktivních hlasů)
    voiceManager_->refresh();
    
    // Analýza výstupní amplitudy pro první bloky
    if (processBlockCount_ <= 3 && buffer.getNumChannels() > 0) {
        float maxAmplitude = 0.0f;
        for (int channel = 0; channel < buffer.getNumChannels(); ++channel) {
            auto* channelData = buffer.getReadPointer(channel);
            for (int sample = 0; sample < buffer.getNumSamples(); ++sample) {
                maxAmplitude = juce::jmax(maxAmplitude, std::abs(channelData[sample]));
            }
        }
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Maximalni vystupni amplituda: " + juce::String(maxAmplitude, 6));
    }
}

//==============================================================================
bool AudioPluginAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "=== VYTVARENI GUI EDITORU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "Inicializace uzivatelskeho rozhrani");
    return new AudioPluginAudioProcessorEditor (*this);
}

//==============================================================================
void AudioPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/getStateInformation", "info", "Ukladani stavu pluginu");
    juce::ignoreUnused (destData);
}

void AudioPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setStateInformation", "info", 
        "Nacitani stavu pluginu (velikost: " + juce::String(sizeInBytes) + " bytu)");
    juce::ignoreUnused (data, sizeInBytes);
}

//==============================================================================
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioPluginAudioProcessor();
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Logger.h"
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "VoiceManager.h"

//==============================================================================
/**
 * AudioPluginAudioProcessor - hlavní třída audio pluginu
 * OPRAVA: Přidání explicitních error states pro lepší debugging
 */
class AudioPluginAudioProcessor final : public juce::AudioProcessor
{
public:
    // OPRAVA: Enum pro explicitní stavy synth komponent
    enum class SynthState { 
        Uninitialized, 
        Initializing, 
        Ready, 
        Error 
    };

    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    using AudioProcessor::processBlock;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;
    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    // OPRAVA: Getter pro aktuální stav (pro debugging)
    SynthState getCurrentState() const { return synthState_.load(); }
    juce::String getStateDescription() const;

private:
    //==============================================================================
    // OPRAVA: Exception-safe metody pro inicializaci
    bool initializeSynth(double sampleRate);
    void cleanupSynth();
    
    // OPRAVA: Error recovery metoda
    void handleSynthError(const std::string& errorMessage);

    // Synth komponenty - vytvářejí se až při prepareToPlay
    std::unique_ptr<SampleLibrary> sampleLibrary_;
    std::unique_ptr<MidiStateManager> midiStateManager_;
    std::unique_ptr<VoiceManager> voiceManager_;
    
    // OPRAVA: Atomic state management pro thread safety
    std::atomic<SynthState> synthState_{SynthState::Uninitialized};
    double currentSampleRate_;
    
    // Debug counters pro optimalizaci logování
    int processBlockCount_;
    int totalMidiEvents_;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessor)
};


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe


## Nastavení vývojového prostředí

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) proveďte následující kroky. Předpokládá se instalace Visual Studio Build Tools (s MSVC kompilátorem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Požadavky
- Visual Studio Build Tools (MSVC kompilátor).
- CMake nainstalovaný a přidán do PATH (např. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastavení
1. **Instalace rozšíření ve VS Code**:
   - Otevřete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a ladění) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otevření projektu**:
   - Přejděte na File > Open Folder a vyberte složku s CMakeLists.txt.
3. **Výběr kompilátoru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napište "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle potřeby (např. x64 pro moderní systémy).
4. **Konfigurace projektu**:
   - V Command Palette napište "CMake: Configure". To vygeneruje build soubory (obvykle ve složce "build").
5. **Build projektu**:
   - V Command Palette napište "CMake: Build" nebo použijte Shift+Ctrl+B (nyní nabídne CMake úlohy).
6. **Debugování (volitelně)**:
   - Nastavte breakpointy a spusťte "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovaný v JUCE frameworku, inspirovaný hardwarovými syntezátory s modulární architekturou.

## Architektura Systému

### Přehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
├── SampleLibrary (Pre-computed Audio Storage)
├── MidiStateManager (MIDI Event Processing)  
├── VoiceManager (Voice Allocation & Control)
└── Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**Účel:** Správa pre-computed audio sampelů pro jednotlivé MIDI noty

**Klíčové vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not × 12 sekund × sample rate
- **Pre-computed sine waves:** Generování při inicializaci místo realtime syntézy
- **Memory management:** Per-nota allocation s bezpečným uvolňováním
- **Rozšiřitelnost:** Připraveno pro načítání WAV souborů

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementační detaily:**
- Každý sample má pevnou délku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe přístup k sample datům

### 2. MidiStateManager
**Účel:** Centrální správa MIDI stavu a událostí

**Inspirováno:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracování
- Queue-based event distribution
- State tracking pro aktivní noty a controllery

**Klíčové struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Oddělené queues pro Note On/Off události
- Per-channel event routing (16 MIDI kanálů)
- Pop/push pattern podobný hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**Účel:** Polyphonic voice allocation a audio generování

**Inspirováno:** Hardware Performer class
- 16 polyphonic hlasů
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hledá existující hlas s touto notou
    // 2. Hledá neaktivní hlas s nejvyšší queue pozicí  
    // 3. Krade aktivní hlas s nejvyšší queue pozicí
}
```

**Queue Management (mixleQueue):**
Algoritmus převzatý z HW implementace:
1. Vybraný hlas → queue pozice 0
2. Ostatní hlasy → pozice++
3. Komprese queue pozic > původní pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se přehraje jednou)

### 4. Logger System
**Účel:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logování z audio vlákna
- Sliding window buffer (100 zpráv)
- Kategorizace: info/debug/warn
- GUI integration přes MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
├── Create SampleLibrary (dummy sample rate)
├── Create MidiStateManager  
└── Create VoiceManager (16 voices)

prepareToPlay:
├── Reinit SampleLibrary (correct sample rate)
├── Generate sine wave pro Middle C (nota 60)
└── Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celková alokace:** ~292MB pro kompletní library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic při destrukci

### Voice Memory
- **16 SynthVoice objektů:** Minimální memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporované MIDI zprávy:
- **Note On/Off:** Kompletní support včetně Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 až +8191)
- **Control Change:** 128 controllers × 16 kanálů
- **Channel support:** 16 MIDI kanálů

### MIDI Routing:
- **Prototype:** Pouze kanál 0 aktivní
- **Full version:** Všech 16 kanálů připraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
├── PluginProcessor.h/cpp
├── PluginEditor.h/cpp

Synth Engine:
├── SampleLibrary.h/cpp
├── MidiStateManager.h/cpp
├── VoiceManager.h/cpp

Utilities:
└── Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro všech 128 not
2. **WAV loading:** Implementace načítání externích sampelů
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** Vše se loguje do GUI
- **MIDI monitoring:** Detailní MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms při 480 samples/48kHz)
- **Polyphony:** 16 hlasů

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal díky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB při full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - většinou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - žádné allokace v audio vlákně
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**Důvod:** Konzistentní CPU usage, možnost komplexních waveforms
**Trade-off:** Vysoká paměť vs stabilní performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**Důvod:** Zachování hardware workflow, předvídatelné chování
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centrální state s queue distribution
**Důvod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**Důvod:** Complex debugging požadavky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include <stdexcept>
#include <cstring>

/**
 * Konstruktor: Pouze základní inicializace bez alokace
 */
SampleLibrary::SampleLibrary()
    : sampleRate_(0.0), 
      isInitialized_(false),
      logger_(Logger::getInstance())
{
    // Inicializace segmentů na výchozí hodnoty
    for (int i = 0; i < 128; ++i) {
        samples_[i].midiNote = static_cast<uint8_t>(i);
        samples_[i].isAllocated = false;
        samples_[i].lengthSamples = 0;
    }
    
    logger_.log("SampleLibrary/constructor", "info", "SampleLibrary vytvořena (bez alokace vzorků)");
}

/**
 * OPRAVA: Exception-safe hlavní inicializační metoda s transaction-style approach
 */
void SampleLibrary::initialize(double sampleRate)
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    if (sampleRate <= 0) {
        throw std::invalid_argument("Neplatny sample rate: " + std::to_string(sampleRate));
    }
    
    logger_.log("SampleLibrary/initialize", "info", "=== INICIALIZACE SAMPLE LIBRARY ===");
    logger_.log("SampleLibrary/initialize", "info", "Target sample rate: " + std::to_string(sampleRate));
    
    try {
        // Uložení nového sample rate
        sampleRate_ = sampleRate;
        
        // Vyčištění existujících vzorků při reinicializaci
        if (isInitialized_) {
            logger_.log("SampleLibrary/initialize", "info", "Reinicializace - mazání starých vzorků");
            for (int i = 0; i < 128; ++i) {
                samples_[i].sampleData.reset();
                samples_[i].isAllocated = false;
                samples_[i].lengthSamples = 0;
            }
        }
        
        // OPRAVA: Transaction-style generování vzorků
        if (!generateSamples()) {
            throw std::runtime_error("Selhalo generovani vzorku");
        }
        
        isInitialized_ = true;
        logger_.log("SampleLibrary/initialize", "info", "=== SAMPLE LIBRARY INICIALIZOVÁNA ===");
        
    } catch (const std::exception& e) {
        logger_.log("SampleLibrary/initialize", "error", "Chyba při inicializaci: " + std::string(e.what()));
        
        // OPRAVA: Cleanup při chybě
        isInitialized_ = false;
        for (int i = 0; i < 128; ++i) {
            samples_[i].sampleData.reset();
            samples_[i].isAllocated = false;
            samples_[i].lengthSamples = 0;
        }
        throw;
    }
}

/**
 * OPRAVA: Transaction-style generování vzorků s lepším error handling
 */
bool SampleLibrary::generateSamples()
{
    logger_.log("SampleLibrary/generateSamples", "info", 
                "Generování vzorků pro rozsah " + std::to_string(MIN_NOTE) + "-" + std::to_string(MAX_NOTE));
    
    int successCount = 0;
    int failCount = 0;
    
    // OPRAVA: Temporary array pro atomic replacement
    std::array<SampleSegment, 128> tempSamples;
    
    // Inicializace temp array
    for (int i = 0; i < 128; ++i) {
        tempSamples[i].midiNote = static_cast<uint8_t>(i);
        tempSamples[i].isAllocated = false;
        tempSamples[i].lengthSamples = 0;
    }
    
    // Generování vzorků pouze pro klavírní rozsah
    for (uint8_t note = MIN_NOTE; note <= MAX_NOTE; ++note) {
        try {
            if (generateSampleForNote(note, tempSamples[note])) {
                successCount++;
            } else {
                failCount++;
                logger_.log("SampleLibrary/generateSamples", "warn", 
                           "Selhalo generování vzorku pro notu: " + std::to_string(note));
            }
        } catch (const std::exception& e) {
            failCount++;
            logger_.log("SampleLibrary/generateSamples", "error", 
                       "Exception při generování noty " + std::to_string(note) + ": " + e.what());
        }
    }
    
    // OPRAVA: Pouze pokud je generování úspěšné, přeneseme data
    if (successCount > 0 && failCount == 0) {
        // Atomicky přenést hotové vzorky
        for (int i = 0; i < 128; ++i) {
            samples_[i] = std::move(tempSamples[i]);
        }
        
        logger_.log("SampleLibrary/generateSamples", "info", 
                    "Generování dokončeno - úspěšné: " + std::to_string(successCount));
        
        // Výpočet celkové velikosti v paměti
        size_t totalMemory = 0;
        for (int i = 0; i < 128; ++i) {
            if (samples_[i].isAllocated) {
                totalMemory += samples_[i].lengthSamples * sizeof(float);
            }
        }
        
        double memoryMB = static_cast<double>(totalMemory) / (1024.0 * 1024.0);
        logger_.log("SampleLibrary/generateSamples", "info", 
                    "Celková paměť vzorků: " + std::to_string(memoryMB) + " MB");
        
        return true;
    } else {
        logger_.log("SampleLibrary/generateSamples", "error", 
                    "Generování selhalo - úspěšné: " + std::to_string(successCount) + 
                    ", selhané: " + std::to_string(failCount));
        return false;
    }
}

/**
 * OPRAVA: Exception-safe generování jednotlivého vzorku s transaction approach
 */
bool SampleLibrary::generateSampleForNote(uint8_t note, SampleSegment& segment)
{
    try {
        // Výpočet frekvence pro notu
        double frequency = getFrequencyForNote(note);
        
        // Výpočet délky vzorku (několik period pro smooth loop)
        double periodLength = sampleRate_ / frequency;
        uint32_t sampleLength = static_cast<uint32_t>(periodLength * SAMPLE_PERIODS);
        
        // Kontrola rozumné délky vzorku
        if (sampleLength < 10 || sampleLength > sampleRate_ * 2) {  // Max 2 sekundy
            logger_.log("SampleLibrary/generateSampleForNote", "warn", 
                       "Nevalidní délka vzorku pro notu " + std::to_string(note) + 
                       ": " + std::to_string(sampleLength) + " samples");
            return false;
        }
        
        // OPRAVA: Transaction-style - připravit vše v temp objektu
        auto tempSampleData = std::make_unique<float[]>(sampleLength);
        
        // Generování sinusového vzorku s optimalizovanými parametry
        const double twoPi = 2.0 * 3.14159;
        const double phaseIncrement = twoPi * frequency / sampleRate_;
        
        for (uint32_t i = 0; i < sampleLength; ++i) {
            double phase = phaseIncrement * static_cast<double>(i);
            tempSampleData[i] = SAMPLE_AMPLITUDE * static_cast<float>(std::sin(phase));
        }
        
        // OPRAVA: Atomic assignment - pouze při úspěchu
        segment.sampleData = std::move(tempSampleData);
        segment.lengthSamples = sampleLength;
        segment.midiNote = note;
        segment.isAllocated = true;
        
        logger_.log("SampleLibrary/generateSampleForNote", "debug", 
                   "Vzorek pro notu " + std::to_string(note) + 
                   " (" + std::to_string(frequency) + " Hz): " + 
                   std::to_string(sampleLength) + " samples");
        
        return true;
        
    } catch (const std::bad_alloc& e) {
        logger_.log("SampleLibrary/generateSampleForNote", "error", 
                   "Nedostatek paměti pro notu " + std::to_string(note));
        return false;
    } catch (const std::exception& e) {
        logger_.log("SampleLibrary/generateSampleForNote", "error", 
                   "Chyba při generování noty " + std::to_string(note) + ": " + e.what());
        return false;
    }
}

/**
 * Thread-safe getter pro vzorek data
 */
const float* SampleLibrary::getSampleForNote(uint8_t note, uint32_t& sampleLength) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    // Kontrola platného rozsahu a alokace
    if (note >= 128 || !samples_[note].isAllocated || !samples_[note].sampleData) {
        sampleLength = 0;
        return nullptr;
    }
    
    // Vrácení pointeru na data a délky
    sampleLength = samples_[note].lengthSamples;
    return samples_[note].sampleData.get();
}

/**
 * Thread-safe getter pro segment
 */
const SampleSegment* SampleLibrary::getSampleSegment(uint8_t note) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    // Kontrola validity
    if (note >= 128 || !samples_[note].isAllocated) {
        return nullptr;
    }
    
    return &samples_[note];
}

/**
 * Kontrola dostupnosti noty
 */
bool SampleLibrary::isNoteAvailable(uint8_t note) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    
    return (note < 128) && samples_[note].isAllocated && (samples_[note].sampleData != nullptr);
}

/**
 * Utility metoda pro výpočet frekvence MIDI noty
 * Založeno na A4 = 440 Hz (nota 69)
 */
double SampleLibrary::getFrequencyForNote(uint8_t note) const
{
    // Výpočet frekvence podle standardního temperování
    return 440.0 * std::pow(2.0, (note - 69) / 12.0);
}


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <memory>
#include <cstdint>
#include <cmath>
#include "Logger.h"

/**
 * SampleSegment - struktura reprezentující segment vzorku pro MIDI notu
 * Používá smart pointer pro automatické memory management
 */
struct SampleSegment {
    std::unique_ptr<float[]> sampleData;  // Smart pointer pro automatické cleanup
    uint32_t lengthSamples;               // Délka v samples
    uint8_t midiNote;                     // MIDI nota (0-127)
    bool isAllocated;                     // Flag pro kontrolu alokace
    
    SampleSegment() : lengthSamples(0), midiNote(0), isAllocated(false) {}
    
    // Move konstruktor pro efektivní přesun dat
    SampleSegment(SampleSegment&& other) noexcept
        : sampleData(std::move(other.sampleData)),
          lengthSamples(other.lengthSamples),
          midiNote(other.midiNote),
          isAllocated(other.isAllocated)
    {
        other.lengthSamples = 0;
        other.midiNote = 0;
        other.isAllocated = false;
    }
    
    // Move assignment operator
    SampleSegment& operator=(SampleSegment&& other) noexcept
    {
        if (this != &other) {
            sampleData = std::move(other.sampleData);
            lengthSamples = other.lengthSamples;
            midiNote = other.midiNote;
            isAllocated = other.isAllocated;
            
            other.lengthSamples = 0;
            other.midiNote = 0;
            other.isAllocated = false;
        }
        return *this;
    }
    
    // Zakázání kopírování (pouze move)
    SampleSegment(const SampleSegment&) = delete;
    SampleSegment& operator=(const SampleSegment&) = delete;
};

/**
 * SampleLibrary - třída pro správu a generování audio vzorků
 * OPRAVA: Transaction-style inicializace s exception safety
 */
class SampleLibrary
{
public:
    // Konstruktor: Pouze základní inicializace
    SampleLibrary();
    
    // Destruktor: Automatické cleanup díky smart pointers
    ~SampleLibrary() = default;
    
    // OPRAVA: Exception-safe hlavní inicializační metoda
    void initialize(double sampleRate);
    
    // Thread-safe getter pro vzorek data
    const float* getSampleForNote(uint8_t note, uint32_t& sampleLength) const;
    
    // Thread-safe getter pro segment
    const SampleSegment* getSampleSegment(uint8_t note) const;
    
    // Metoda pro kontrolu dostupnosti noty
    bool isNoteAvailable(uint8_t note) const;
    
    // Getter pro aktuální sample rate
    double getSampleRate() const { return sampleRate_; }

private:
    // OPRAVA: Transaction-style generování vzorků s lepším error handling
    bool generateSamples();
    
    // OPRAVA: Exception-safe generování jednotlivého vzorku s transaction approach
    bool generateSampleForNote(uint8_t note, SampleSegment& segment);
    
    // Utility metoda pro výpočet frekvence
    double getFrequencyForNote(uint8_t note) const;
    
    // Optimalizované konstanty pro rozsah generování
    static const uint8_t MIN_NOTE = 21;  // A0 - nejnižší nota klavíru
    static const uint8_t MAX_NOTE = 108; // C8 - nejvyšší nota klavíru
    
    // Konstanta pro délku vzorku (počet period)
    static const int SAMPLE_PERIODS = 8;  // Optimalizováno pro kvalitu vs. paměť
    
    // Audio parametry
    static constexpr float SAMPLE_AMPLITUDE = 0.25f;  // Konzervativní amplituda
    
    // Data storage
    SampleSegment samples_[128];  // Fixed array pro všechny MIDI noty
    double sampleRate_;           // Aktuální sample rate
    bool isInitialized_;          // Flag inicializace
    
    // Logger reference
    Logger& logger_;
    
    // Thread safety - pro případné budoucí multi-threading
    mutable std::mutex accessMutex_;
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"
#include <limits>
#include <mutex>
#include <memory>
#include <atomic>
#include <array>
#include <algorithm>

//==============================================================================
// SynthVoice Implementation
//==============================================================================

SynthVoice::SynthVoice(int voiceNumber)
    : voiceNumber_(voiceNumber),
      currentNote_(0),
      velocity_(0),
      isActive_(false),
      startTime_(0),
      samplePosition_(0.0),  // OPRAVA: Double pro přesnost
      pitchWheel_(0),
      logger_(Logger::getInstance())
{
    logger_.log("SynthVoice/constructor", "debug", "Hlas #" + juce::String(voiceNumber_) + " vytvořen");
}

void SynthVoice::noteOn(uint8_t note, uint8_t velocity)
{
    currentNote_ = note;
    velocity_ = velocity;
    isActive_ = true;
    startTime_ = juce::Time::getMillisecondCounter();
    
    // OPRAVA: Vždy resetovat sample position při note on (i pro retrigger)
    samplePosition_ = 0.0;
    
    logger_.log("SynthVoice/noteOn", "info", 
                "Hlas #" + juce::String(voiceNumber_) + 
                " spustil notu " + juce::String(note) + 
                " s velocity " + juce::String(velocity) + 
                " (reset position)");
}

void SynthVoice::noteOff()
{
    if (isActive_) {
        logger_.log("SynthVoice/noteOff", "info", 
                    "Hlas #" + juce::String(voiceNumber_) + 
                    " zastavil notu " + juce::String(currentNote_));
    }
    
    isActive_ = false;
    // Poznámka: samplePosition_ se neresetuje - umožní dokončení vzorku s fade-out (pokud bude implementován)
}

void SynthVoice::reset()
{
    if (isActive_) {
        logger_.log("SynthVoice/reset", "debug", 
                    "Hlas #" + juce::String(voiceNumber_) + " resetován");
    }
    
    isActive_ = false;
    samplePosition_ = 0.0;  // OPRAVA: Reset na double
    currentNote_ = 0;
    velocity_ = 0;
    startTime_ = 0;
}

void SynthVoice::setPitchWheel(int16_t pitchWheel)
{
    pitchWheel_ = pitchWheel;
    logger_.log("SynthVoice/setPitchWheel", "debug", 
                "Hlas #" + juce::String(voiceNumber_) + " pitch wheel nastaven: " + juce::String(pitchWheel));
}

void SynthVoice::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    if (!isActive_) {
        return;  // Nehrajeme, nic negenerujeme
    }
    
    // Získání vzorku pro aktuální notu
    uint32_t sampleLength;
    const float* sampleData = sampleLibrary.getSampleForNote(currentNote_, sampleLength);
    
    if (!sampleData || sampleLength == 0) {
        // Vzorek není dostupný - zastavíme hlas
        logger_.log("SynthVoice/generateAudio", "warn", 
                    "Vzorek pro notu " + juce::String(currentNote_) + " není dostupný");
        isActive_ = false;
        return;
    }
    
    // Výpočet velocity scaling
    float velocityScale = velocity_ / 127.0f;
    
    // OPRAVA: Přesnější implementace pitch bend s double precision
    const double bendRangeSemitones = 2.0;  // Konfigurovatelné, default ±2 semitony
    
    // Použití double precision pro přesnější výpočty
    double pitchBendRatio = std::pow(2.0, (static_cast<double>(pitchWheel_) / 8192.0) * (bendRangeSemitones / 12.0));
    
    // Generování audio samples s resamplem
    for (int i = 0; i < numSamples; ++i) {
        int intPos = static_cast<int>(samplePosition_);
        if (intPos < static_cast<int>(sampleLength) - 1) {  // Zabránění out-of-bounds
            // Jednoduchá lineární interpolace pro fractional position
            double frac = samplePosition_ - intPos;
            float sample = static_cast<float>(
                sampleData[intPos] * (1.0 - frac) + sampleData[intPos + 1] * frac
            );
            outputBuffer[i] += sample * velocityScale;
            samplePosition_ += pitchBendRatio;  // Aplikování pitch bend
        } else {
            // Konec vzorku - zastavíme hlas
            isActive_ = false;
            break;
        }
    }
}

//==============================================================================
// VoiceManager Implementation
//==============================================================================

VoiceManager::VoiceManager(int maxVoices)
    : maxVoices_(std::min(maxVoices, MAX_VOICES)),
      globalPitchWheel_(0),
      logger_(Logger::getInstance()),
      voiceStealCount_(0)
{
    logger_.log("VoiceManager/constructor", "info", 
                "=== INICIALIZACE VOICE MANAGER ===");
    logger_.log("VoiceManager/constructor", "info", 
                "Počet hlasů: " + juce::String(maxVoices_));
    
    // Vytvoření hlasů
    for (int i = 0; i < maxVoices_; ++i) {
        voices_[i] = std::make_unique<SynthVoice>(i);
    }
    
    logger_.log("VoiceManager/constructor", "info", 
                "=== VOICE MANAGER INICIALIZOVÁN ===");
}

VoiceManager::~VoiceManager()
{
    logger_.log("VoiceManager/destructor", "info", "Voice Manager se uvolňuje");
    
    // Smart pointery se uvolní automaticky
    // Vypíšeme statistiky
    logger_.log("VoiceManager/destructor", "info", 
                "Celkem voice stealing událostí: " + juce::String(voiceStealCount_));
}

void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // Zpracování Note On/Off událostí pro všechny MIDI kanály
    for (uint8_t channel = 0; channel < 16; ++channel) {
        // Note On události
        uint8_t note;
        while ((note = midiState.popNoteOn(channel)) != 0xff) {
            uint8_t velocity = midiState.getVelocity(channel, note);
            startNote(note, velocity);
        }
        
        // Note Off události
        while ((note = midiState.popNoteOff(channel)) != 0xff) {
            stopNote(note);
        }
    }
    
    // Globální pitch wheel
    int16_t pitchWheel = midiState.getPitchWheel();
    if (pitchWheel != globalPitchWheel_) {
        setPitchWheel(pitchWheel);
    }
}

void VoiceManager::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    // KRITICKÁ OPRAVA: Nepřepisujeme buffer, ale mixujeme do něj
    // Buffer už byl vynulován v processBlock
    
    // Generování audio ze všech aktivních hlasů
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && voices_[i]->isActive()) {
            voices_[i]->generateAudio(outputBuffer, numSamples, sampleLibrary);
        }
    }
}

void VoiceManager::refresh()
{
    // Cleanup pouze neaktivních hlasů (OPRAVA původního problému)
    int activeCount = 0;
    
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i]) {
            if (voices_[i]->isActive()) {
                activeCount++;
            }
            // Neaktivní hlasy ponecháme - mohou být znovu použity
        }
    }
    
    // Logování pouze při změně počtu aktivních hlasů
    static int lastActiveCount = 0;
    if (activeCount != lastActiveCount) {
        logger_.log("VoiceManager/refresh", "debug", 
                    "Aktivní hlasy: " + juce::String(activeCount) + "/" + juce::String(maxVoices_));
        lastActiveCount = activeCount;
    }
}

void VoiceManager::allNotesOff()
{
    logger_.log("VoiceManager/allNotesOff", "info", "=== ALL NOTES OFF ===");
    
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i]) {
            voices_[i]->reset();
        }
    }
    
    logger_.log("VoiceManager/allNotesOff", "info", "Všechny hlasy zastaveny");
}

int VoiceManager::getActiveVoiceCount() const
{
    int count = 0;
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && voices_[i]->isActive()) {
            count++;
        }
    }
    return count;
}

void VoiceManager::setPitchWheel(int16_t pitchWheel)
{
    globalPitchWheel_ = pitchWheel;
    
    // Aplikace na všechny hlasy
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i]) {
            voices_[i]->setPitchWheel(pitchWheel);
        }
    }
    
    logger_.log("VoiceManager/setPitchWheel", "debug", 
                "Pitch wheel nastaven: " + juce::String(pitchWheel));
}

//==============================================================================
// Private helper methods - zjednodušené voice allocation
//==============================================================================

int VoiceManager::findVoiceForNote(uint8_t note) const
{
    // Najde existující hlas, který hraje tuto notu
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && voices_[i]->isActive() && voices_[i]->getCurrentNote() == note) {
            return i;
        }
    }
    return -1;  // Nenalezen
}

int VoiceManager::findFreeVoice() const
{
    // Najde první volný (neaktivní) hlas
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && !voices_[i]->isActive()) {
            return i;
        }
    }
    return -1;  // Žádný volný hlas
}

int VoiceManager::findOldestVoice() const
{
    // Voice stealing: najde nejstarší aktivní hlas
    int oldestVoice = -1;
    uint32_t oldestTime = std::numeric_limits<uint32_t>::max();
    
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && voices_[i]->isActive()) {
            if (voices_[i]->getStartTime() < oldestTime) {
                oldestTime = voices_[i]->getStartTime();
                oldestVoice = i;
            }
        }
    }
    
    return oldestVoice;
}

void VoiceManager::startNote(uint8_t note, uint8_t velocity)
{
    // 1. Kontrola existujícího hlasu pro tuto notu (retriggering)
    int voiceIndex = findVoiceForNote(note);
    if (voiceIndex != -1) {
        logger_.log("VoiceManager/startNote", "debug", 
                    "Retrigger noty " + juce::String(note) + " na hlasu #" + juce::String(voiceIndex));
        voices_[voiceIndex]->noteOn(note, velocity);  // OPRAVA: noteOn nyní správně resetuje pozici
        return;
    }
    
    // 2. Hledání volného hlasu
    voiceIndex = findFreeVoice();
    if (voiceIndex != -1) {
        logger_.log("VoiceManager/startNote", "debug", 
                    "Přiřazení noty " + juce::String(note) + " na volný hlas #" + juce::String(voiceIndex));
        voices_[voiceIndex]->noteOn(note, velocity);
        return;
    }
    
    // 3. Voice stealing - použití nejstaršího hlasu
    voiceIndex = findOldestVoice();
    if (voiceIndex != -1) {
        voiceStealCount_++;
        logger_.log("VoiceManager/startNote", "info", 
                    "VOICE STEALING: nota " + juce::String(note) + 
                    " krade hlas #" + juce::String(voiceIndex) + 
                    " (celkem: " + juce::String(voiceStealCount_) + ")");
        voices_[voiceIndex]->noteOn(note, velocity);
        return;
    }
    
    // 4. Fallback - toto by se nemělo stát
    logger_.log("VoiceManager/startNote", "error", 
                "Nelze přiřadit hlas pro notu " + juce::String(note));
}

void VoiceManager::stopNote(uint8_t note)
{
    // Najde a zastaví všechny hlasy hrající tuto notu
    bool found = false;
    
    for (int i = 0; i < maxVoices_; ++i) {
        if (voices_[i] && voices_[i]->isActive() && voices_[i]->getCurrentNote() == note) {
            voices_[i]->noteOff();
            found = true;
            logger_.log("VoiceManager/stopNote", "debug", 
                        "Zastavena nota " + juce::String(note) + " na hlasu #" + juce::String(i));
        }
    }
    
    if (!found) {
        logger_.log("VoiceManager/stopNote", "debug", 
                    "Note Off pro notu " + juce::String(note) + " - žádný aktivní hlas nenalezen");
    }
}


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include "MidiStateManager.h"
#include "SampleLibrary.h"
#include "Logger.h"

/**
 * SynthVoice - reprezentuje jeden hlas syntetizátoru.
 * OPRAVA: Správné retrigger handling a přesnější pitch bend
 */
class SynthVoice 
{
public:
    // Konstruktor: Inicializuje hlas s číslem.
    SynthVoice(int voiceNumber);
    
    // OPRAVA: Metody pro spuštění a zastavení noty s proper resetem
    void noteOn(uint8_t note, uint8_t velocity);
    void noteOff();
    
    // Metoda pro nastavení pitch wheel.
    void setPitchWheel(int16_t pitchWheel);
    
    // Gettery pro stav.
    uint8_t getCurrentNote() const { return currentNote_; }
    bool isActive() const { return isActive_; }
    uint32_t getStartTime() const { return startTime_; }
    
    // OPRAVA: Metoda pro generování audio s přesnější pitch bend implementací
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Metoda pro reset hlasu.
    void reset();

private:
    int voiceNumber_;           // Číslo hlasu.
    uint8_t currentNote_;       // Aktuální nota.
    uint8_t velocity_;          // Velocity noty.
    bool isActive_;             // Aktivní stav.
    uint32_t startTime_;        // Čas spuštění pro voice stealing.
    
    // OPRAVA: Používáme double pro přesnější fractional position tracking
    double samplePosition_;     // Pozice v aktuálním vzorku (double pro přesnost)
    int16_t pitchWheel_;        // Hodnota pitch wheel.
    
    Logger& logger_;            // Reference na logger.
};

/**
 * VoiceManager - správa hlasů pro polyfonii.
 * Podporuje až 16 hlasů s voice stealingem pro hraní více not.
 */
class VoiceManager 
{
public:
    // Konstruktor: Inicializuje maximální počet hlasů.
    VoiceManager(int maxVoices = 16);
    
    // Destruktor: Uvolní hlasy.
    ~VoiceManager();
    
    // Metoda pro zpracování MIDI událostí z MidiStateManager.
    void processMidiEvents(MidiStateManager& midiState);
    
    // Metoda pro generování audio ze všech aktivních hlasů.
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Metoda pro refresh stavu hlasů (cleanup neaktivních).
    void refresh();
    
    // Metoda pro zastavení všech not.
    void allNotesOff();
    
    // Getter pro počet aktivních hlasů.
    int getActiveVoiceCount() const;
    
    // Metoda pro nastavení pitch wheel pro všechny hlasy.
    void setPitchWheel(int16_t pitchWheel);

private:
    // OPRAVA: Pomocné metody s lepším voice allocation algoritmem
    void startNote(uint8_t note, uint8_t velocity);
    void stopNote(uint8_t note);
    int findVoiceForNote(uint8_t note) const;
    int findFreeVoice() const;
    int findOldestVoice() const;
    
    // Maximální počet hlasů.
    static const int MAX_VOICES = 16;
    std::unique_ptr<SynthVoice> voices_[MAX_VOICES];  // Pole hlasů (smart pointers pro bezpečnost).
    int maxVoices_;                                   // Aktuální maximální počet hlasů.
    int16_t globalPitchWheel_;                        // Globální pitch wheel.
    int voiceStealCount_;                             // Počítadlo voice stealing.
    
    Logger& logger_;                                  // Reference na logger.
};



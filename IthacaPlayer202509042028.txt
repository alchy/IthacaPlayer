===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"
#include <sstream>

std::atomic<bool> Logger::loggingEnabled{true};

Logger::Logger() {}

Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled.load(std::memory_order_relaxed))
        return;

    try {
        auto now = juce::Time::getCurrentTime();
        juce::String timestamp = now.formatted("%Y-%m-%d %H:%M:%S");
        juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

        pushToLogQueue(logEntry);
        scheduleGUIUpdate();
    } catch (...) {
        // bezpe캜n칳 fallback
    }
}

void Logger::pushToLogQueue(const juce::String& logEntry)
{
    std::lock_guard<std::mutex> lock(logMutex_);

    uint8_t writeIndex = logQueue_.writeIndex.load();
    uint8_t currentCount = logQueue_.count.load();

    logQueue_.logs[writeIndex] = logEntry;
    logQueue_.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));

    if (currentCount < 256) {
        logQueue_.count.store(currentCount + 1);
    } else {
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + 1);
    }

    if (logQueue_.count.load() > MAX_LOG_ENTRIES) {
        uint8_t excess = logQueue_.count.load() - MAX_LOG_ENTRIES;
        logQueue_.readIndex = static_cast<uint8_t>(logQueue_.readIndex + excess);
        logQueue_.count.store(MAX_LOG_ENTRIES);
    }
}

void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    std::lock_guard<std::mutex> lock(editorMutex_);
    editorPtr_ = ed;
}

void Logger::scheduleGUIUpdate()
{
    juce::MessageManager::callAsync([this]() {
        std::lock_guard<std::mutex> lock(editorMutex_);
        if (editorPtr_ != nullptr) {
            editorPtr_->updateLogDisplay();
        }
    });
}

juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}

juce::StringArray Logger::getCurrentLogs() const
{
    std::lock_guard<std::mutex> lock(logMutex_);

    juce::StringArray result;
    uint8_t currentCount = logQueue_.count.load();
    uint8_t readIndex = logQueue_.readIndex;

    for (uint8_t i = 0; i < currentCount; ++i) {
        uint8_t index = static_cast<uint8_t>(readIndex + i);
        result.add(logQueue_.logs[index]);
    }
    return result;
}

void Logger::clearLogs()
{
    std::lock_guard<std::mutex> lock(logMutex_);
    logQueue_.writeIndex.store(0);
    logQueue_.count.store(0);
    logQueue_.readIndex = 0;
    for (auto& log : logQueue_.logs) {
        log = juce::String();
    }
}

size_t Logger::getLogCount() const
{
    return logQueue_.count.load(std::memory_order_relaxed);
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>
#include <mutex>
#include <array>

#define MAX_LOG_ENTRIES 100

class AudioPluginAudioProcessorEditor;

class Logger
{
public:
    static Logger& getInstance();

    void log(const juce::String& component, const juce::String& severity, const juce::String& message);
    static std::atomic<bool> loggingEnabled;

    void setEditor(AudioPluginAudioProcessorEditor* ed);

    juce::StringArray getLogBuffer() const;
    void clearLogs();
    size_t getLogCount() const;

private:
    Logger();
    ~Logger() = default;

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    struct LogQueue {
        std::array<juce::String, 256> logs;
        std::atomic<uint8_t> writeIndex{0};
        std::atomic<uint8_t> count{0};
        uint8_t readIndex{0};
    };

    LogQueue logQueue_;

    mutable std::mutex logMutex_;
    mutable std::mutex editorMutex_;

    // 游댢 oprava: u jen raw pointer (JUCE spravuje lifecycle editoru)
    AudioPluginAudioProcessorEditor* editorPtr_{nullptr};

    void pushToLogQueue(const juce::String& logEntry);
    juce::StringArray getCurrentLogs() const;
    void scheduleGUIUpdate();
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"
#include <algorithm>
#include <cassert>

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

//==============================================================================
MidiStateManager::MidiStateManager()
    : logger_(Logger::getInstance())
{
    logger_.log("MidiStateManager/constructor", "info", "=== INICIALIZACE MIDI STATE MANAGER ===");
    
    // Inicializace aktivn칤ch not
    for (auto& note : activeNotes_) {
        note.reset();
    }
    
    // Inicializace MIDI controller hodnot podle standardu
    for (int channel = 0; channel < 16; channel++) {
        for (int controller = 0; controller < 128; controller++) {
            controllerValues_[channel][controller] = 0;
        }
        
        // V칳choz칤 hodnoty pro standardn칤 controllery
        controllerValues_[channel][7] = 100;   // Volume (0-127, default high)
        controllerValues_[channel][10] = 64;   // Pan (0-127, default center)
        controllerValues_[channel][11] = 127;  // Expression (0-127, default max)
        controllerValues_[channel][64] = 0;    // Sustain pedal (0-127, default off)
        controllerValues_[channel][91] = 0;    // Reverb (0-127, default off)
        controllerValues_[channel][93] = 0;    // Chorus (0-127, default off)
    }
    
    // Reset v코ech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    logger_.log("MidiStateManager/constructor", "info", 
                "Max aktivnich not: " + juce::String(MAX_ACTIVE_NOTES));
    logger_.log("MidiStateManager/constructor", "info", 
                "MIDI channels: 16, Controllers: 128 per channel");
    logger_.log("MidiStateManager/constructor", "info", 
                "=== MIDI STATE MANAGER INICIALIZOVAN ===");
}

//==============================================================================
void MidiStateManager::processMidiBuffer(const juce::MidiBuffer& midiBuffer)
{
    // Po캜칤tadlo pro optimalizaci logov치n칤
    static uint32_t processedMessages = 0;
    int messagesInBuffer = 0;
    
    for (const auto& midiMetadata : midiBuffer) {
        auto message = midiMetadata.getMessage();
        processedMessages++;
        messagesInBuffer++;
        totalMidiMessages_.fetch_add(1, std::memory_order_relaxed);
        
        // Zpracov치n칤 r콢zn칳ch typ콢 MIDI zpr치v
        if (message.isNoteOn()) {
            // MIDI Note On s velocity 0 se pova쬿je za Note Off podle standardu
            if (message.getVelocity() == 0) {
                putNoteOff(message.getChannel() - 1, message.getNoteNumber());
            } else {
                putNoteOn(message.getChannel() - 1, message.getNoteNumber(), message.getVelocity());
            }
        }
        else if (message.isNoteOff()) {
            putNoteOff(message.getChannel() - 1, message.getNoteNumber());
        }
        else if (message.isPitchWheel()) {
            // P콏evod z JUCE rozsahu (0-16383) na signed int16 (-8192 a +8191)
            int pitchWheelValue = message.getPitchWheelValue() - 8192;
            setPitchWheel(static_cast<int16_t>(pitchWheelValue));
        }
        else if (message.isController()) {
            setControllerValue(message.getChannel() - 1, 
                             message.getControllerNumber(), 
                             message.getControllerValue());
        }
        else if (message.isProgramChange()) {
            logger_.log("MidiStateManager/processMidiBuffer", "info",
                       "Program Change: " + juce::String(message.getProgramChangeNumber()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        else if (message.isChannelPressure()) {
            logger_.log("MidiStateManager/processMidiBuffer", "debug",
                       "Channel Pressure: " + juce::String(message.getChannelPressureValue()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        else if (message.isAftertouch()) {
            logger_.log("MidiStateManager/processMidiBuffer", "debug",
                       "Aftertouch: nota " + juce::String(message.getNoteNumber()) + 
                       " pressure " + juce::String(message.getAfterTouchValue()) + 
                       " na kanalu " + juce::String(message.getChannel()));
        }
        
        // Detailn칤 logov치n칤 pouze pro prvn칤 zpr치vy nebo p콏i debug re쬴mu
        if (processedMessages <= 10) {
            juce::String midiInfo = "MIDI #" + juce::String(processedMessages) + 
                                   " @ sample " + juce::String(midiMetadata.samplePosition);
            
            if (message.isNoteOn() && message.getVelocity() > 0) {
                midiInfo += ": NOTE ON - " + 
                           message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + 
                           " vel:" + juce::String(message.getVelocity()) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isNoteOff() || (message.isNoteOn() && message.getVelocity() == 0)) {
                midiInfo += ": NOTE OFF - " + 
                           message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isPitchWheel()) {
                midiInfo += ": PITCH WHEEL - " + juce::String(message.getPitchWheelValue()) + 
                           " ch:" + juce::String(message.getChannel());
            } else if (message.isController()) {
                midiInfo += ": CC" + juce::String(message.getControllerNumber()) + 
                           " = " + juce::String(message.getControllerValue()) + 
                           " ch:" + juce::String(message.getChannel());
            } else {
                midiInfo += ": " + message.getDescription();
            }
            
            logger_.log("MidiStateManager/processMidiBuffer", "info", midiInfo);
        }
    }
    
    // Logov치n칤 souhrnu pro buffer s v칤ce zpr치vami
    if (messagesInBuffer > 1) {
        logger_.log("MidiStateManager/processMidiBuffer", "info",
                   "Buffer zpracovan: " + juce::String(messagesInBuffer) + 
                   " zprav (celkem: " + juce::String(totalMidiMessages_.load()) + ")");
    }
}

//==============================================================================
void MidiStateManager::putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity)
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        logger_.log("MidiStateManager/putNoteOn", "warn", 
                   "Neplatny channel nebo key: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOn", "info", 
               "Note ON - Ch:" + juce::String(channel) + 
               " Key:" + juce::String(key) + 
               " Vel:" + juce::String(velocity));
    
    // OPRAVA: Unified locking strategy
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Hled치n칤 existuj칤c칤ho slotu nebo voln칠ho slotu
    int slot = findNoteSlot(channel, key);
    if (slot == -1) {
        slot = findFreeSlot();
    }
    
    if (slot != -1) {
        activeNotes_[slot].channel = channel;
        activeNotes_[slot].key = key;
        activeNotes_[slot].velocity = velocity;
        activeNotes_[slot].isActive = true;
        activeNotes_[slot].triggerTime = juce::Time::getMillisecondCounter();
        
        // P콏id치n칤 do queue pro VoiceManager
        pushToQueue(noteOnQueues_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOn", "warn", 
                   "Zadny volny slot pro notu - zvyste MAX_ACTIVE_NOTES");
    }
}

void MidiStateManager::putNoteOff(uint8_t channel, uint8_t key)
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        logger_.log("MidiStateManager/putNoteOff", "warn", 
                   "Neplatny channel nebo key: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOff", "info", 
               "Note OFF - Ch:" + juce::String(channel) + 
               " Key:" + juce::String(key));
    
    // OPRAVA: Unified locking strategy
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Hled치n칤 a deaktivace noty
    int slot = findNoteSlot(channel, key);
    if (slot != -1) {
        activeNotes_[slot].isActive = false;
        
        // P콏id치n칤 do note-off queue
        pushToQueue(noteOffQueues_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOff", "debug", 
                   "Note OFF pro neaktivni notu: ch=" + juce::String(channel) + 
                   " key=" + juce::String(key));
        
        // I neaktivn칤 nota m콢쬰 pot콏ebovat note-off (pro voice cleanup)
        pushToQueue(noteOffQueues_[channel], key);
    }
}

//==============================================================================
uint8_t MidiStateManager::popNoteOn(uint8_t channel)
{
    if (!isValidChannel(channel)) {
        return 0xff;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return popFromQueue(noteOnQueues_[channel]);
}

uint8_t MidiStateManager::popNoteOff(uint8_t channel)
{
    if (!isValidChannel(channel)) {
        return 0xff;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return popFromQueue(noteOffQueues_[channel]);
}

//==============================================================================
uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t key) const
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        return 0;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int slot = findNoteSlot(channel, key);
    if (slot != -1 && activeNotes_[slot].isActive) {
        return activeNotes_[slot].velocity;
    }
    
    return 0; // V칳choz칤 velocity pro neaktivn칤 notu
}

bool MidiStateManager::isNoteActive(uint8_t channel, uint8_t key) const
{
    if (!isValidChannel(channel) || !isValidKey(key)) {
        return false;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int slot = findNoteSlot(channel, key);
    return (slot != -1 && activeNotes_[slot].isActive);
}

//==============================================================================
void MidiStateManager::setPitchWheel(int16_t pitchWheelValue)
{
    pitchWheel_.store(pitchWheelValue, std::memory_order_relaxed);
    
    logger_.log("MidiStateManager/setPitchWheel", "debug", 
               "Pitch wheel: " + juce::String(pitchWheelValue));
}

//==============================================================================
void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
{
    if (!isValidChannel(channel) || !isValidController(controller)) {
        logger_.log("MidiStateManager/setControllerValue", "warn", 
                   "Neplatny channel nebo controller: ch=" + juce::String(channel) + 
                   " cc=" + juce::String(controller));
        return;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    controllerValues_[channel][controller] = value;
    
    // Logov치n칤 pouze pro d콢le쬴t칠 controllery
    if (controller == 1 || controller == 7 || controller == 10 || controller == 64 || 
        controller == 91 || controller == 93) {
        
        juce::String ccName = "CC" + juce::String(controller);
        switch (controller) {
            case 1: ccName = "Modulation"; break;
            case 7: ccName = "Volume"; break;
            case 10: ccName = "Pan"; break;
            case 64: ccName = "Sustain"; break;
            case 91: ccName = "Reverb"; break;
            case 93: ccName = "Chorus"; break;
        }
        
        logger_.log("MidiStateManager/setControllerValue", "info", 
                   ccName + " Ch:" + juce::String(channel) + 
                   " Val:" + juce::String(value));
    }
}

uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const
{
    if (!isValidChannel(channel) || !isValidController(controller)) {
        return 0;
    }
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    return controllerValues_[channel][controller];
}

//==============================================================================
void MidiStateManager::logActiveNotes() const
{
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int activeCount = 0;
    juce::String noteList;
    
    for (const auto& note : activeNotes_) {
        if (note.isActive) {
            activeCount++;
            if (noteList.isNotEmpty()) noteList += ", ";
            noteList += juce::String(note.key) + "(ch" + juce::String(note.channel) + ")";
        }
    }
    
    logger_.log("MidiStateManager/logActiveNotes", "debug", 
               "Aktivnich not: " + juce::String(activeCount) + " [" + noteList + "]");
}

int MidiStateManager::getActiveNoteCount() const
{
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    int count = 0;
    for (const auto& note : activeNotes_) {
        if (note.isActive) {
            count++;
        }
    }
    return count;
}

void MidiStateManager::resetAllNotes()
{
    logger_.log("MidiStateManager/resetAllNotes", "info", "=== RESET VSECH NOT ===");
    
    // OPRAVA: Unified locking
    std::lock_guard<std::mutex> lock(midiMutex_);
    
    // Reset v코ech aktivn칤ch not
    for (auto& note : activeNotes_) {
        note.reset();
    }
    
    // Reset v코ech queue
    for (auto& queue : noteOnQueues_) {
        queue.reset();
    }
    for (auto& queue : noteOffQueues_) {
        queue.reset();
    }
    
    // Reset pitch wheel
    pitchWheel_.store(0);
    
    logger_.log("MidiStateManager/resetAllNotes", "info", "Vse resetovano");
}

//==============================================================================
// Private helper methods
//==============================================================================

int MidiStateManager::findNoteSlot(uint8_t channel, uint8_t key) const
{
    // Metoda se vol치 ji v r치mci mutex lock
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].channel == channel && activeNotes_[i].key == key) {
            return i;
        }
    }
    return -1; // Slot nenalezen
}

int MidiStateManager::findFreeSlot() const
{
    // Metoda se vol치 ji v r치mci mutex lock
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (!activeNotes_[i].isActive) {
            return i;
        }
    }
    return -1; // 콯치dn칳 voln칳 slot
}

void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note)
{
    // OPRAVA: U jsme v unified mutex lock, nepot콏ebujeme dal코칤 lock
    uint8_t currentCount = queue.count.load();
    if (currentCount < 255) {  // Ponech치me m칤sto pro wrap-around detection
        uint8_t writeIndex = queue.writeIndex.load();
        queue.notes[writeIndex] = note;
        queue.writeIndex.store(static_cast<uint8_t>(writeIndex + 1));  // uint8 auto wrap
        queue.count.store(currentCount + 1);
    } else {
        // Queue overflow - star코칤 zpr치vy se ztrat칤 (sliding window)
        logger_.log("MidiStateManager/pushToQueue", "warn", 
                   "Queue overflow - zprava ztracena");
    }
}

uint8_t MidiStateManager::popFromQueue(NoteQueue& queue)
{
    // OPRAVA: U jsme v unified mutex lock, nepot콏ebujeme dal코칤 lock
    uint8_t currentCount = queue.count.load();
    if (currentCount > 0) {
        uint8_t note = queue.notes[queue.readIndex];
        queue.readIndex = static_cast<uint8_t>(queue.readIndex + 1);  // uint8 auto wrap
        queue.count.store(currentCount - 1);
        return note;
    }
    
    return 0xff; // Fronta je pr치zdn치
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <array>
#include <atomic>
#include "Logger.h"

/**
 * ActiveNote - struktura reprezentuj칤c칤 aktivn칤 MIDI notu
 * Optimalizovan치 pro rychl칳 p콏칤stup a cache efficiency
 */
struct ActiveNote {
    uint8_t key;                // MIDI nota (0-127)
    uint8_t velocity;           // Velocity (0-127)
    uint8_t channel;            // MIDI channel (0-15)
    bool isActive;              // Flag indikuj칤c칤 aktivn칤 stav noty
    uint32_t triggerTime;       // Timestamp spu코t캩n칤 noty (pro voice stealing)
    
    // Konstruktor s v칳choz칤mi hodnotami
    ActiveNote() : key(0), velocity(0), channel(0), isActive(false), triggerTime(0) {}
    
    // Reset metoda pro op캩tovn칠 pou쬴t칤
    void reset() {
        key = 0;
        velocity = 0;
        channel = 0;
        isActive = false;
        triggerTime = 0;
    }
};

/**
 * NoteQueue - optimalizovan칳 circular buffer pro MIDI noty
 * Pou쮂셨치 uint8 pro automatick칳 wrap-around
 */
struct NoteQueue {
    std::array<uint8_t, 256> notes;     // Fixed array pro noty
    std::atomic<uint8_t> writeIndex{0}; // Thread-safe write index
    std::atomic<uint8_t> count{0};      // Thread-safe po캜칤tadlo
    uint8_t readIndex{0};               // Read index (protected by mutex)
    
    NoteQueue() {
        notes.fill(0xff);  // Vypln캩n칤 invalid hodnotou
    }
    
    // Reset metoda
    void reset() {
        writeIndex.store(0);
        count.store(0);
        readIndex = 0;
        notes.fill(0xff);
    }
};

/**
 * MidiStateManager - centr치ln칤 spr치va MIDI stavu
 * OPRAVA: Unified mutex strategy pro thread safety
 */
class MidiStateManager 
{
public:
    MidiStateManager();
    ~MidiStateManager() = default;
    
    // Hlavn칤 MIDI processing metoda
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer);
    
    // Note management - OPRAVA: Thread-safe s konzistentn칤m lockingem
    void putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity);
    void putNoteOff(uint8_t channel, uint8_t key);
    
    // Queue access pro VoiceManager - OPRAVA: Thread-safe
    uint8_t popNoteOn(uint8_t channel);   // Vrac칤 key nebo 0xff pokud 쮂멳n칳 nen칤
    uint8_t popNoteOff(uint8_t channel);  // Vrac칤 key nebo 0xff pokud 쮂멳n칳 nen칤
    
    // Note state queries - OPRAVA: Thread-safe
    uint8_t getVelocity(uint8_t channel, uint8_t key) const;
    bool isNoteActive(uint8_t channel, uint8_t key) const;
    
    // Pitch wheel management
    void setPitchWheel(int16_t pitchWheelValue);
    int16_t getPitchWheel() const { return pitchWheel_.load(); }
    
    // Controller management - OPRAVA: Thread-safe
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;
    
    // Utility methods
    void logActiveNotes() const;
    int getActiveNoteCount() const;
    void resetAllNotes();  // Emergency reset
    
    // Statistics
    uint32_t getTotalMidiMessages() const { return totalMidiMessages_.load(); }

private:
    // Note storage
    static const int MAX_ACTIVE_NOTES = 128;
    std::array<ActiveNote, MAX_ACTIVE_NOTES> activeNotes_;
    
    // MIDI state
    std::atomic<int16_t> pitchWheel_{0};                    // Thread-safe pitch wheel
    std::array<std::array<uint8_t, 128>, 16> controllerValues_;  // [channel][controller]
    
    // Event queues pro ka쬯칳 MIDI channel
    std::array<NoteQueue, 16> noteOnQueues_;
    std::array<NoteQueue, 16> noteOffQueues_;
    
    // OPRAVA: Unified thread safety - jeden mutex pro v코echny MIDI operace
    mutable std::mutex midiMutex_;         // Unified mutex pro v코echny MIDI operace
    
    // Statistics a debugging
    std::atomic<uint32_t> totalMidiMessages_{0};
    Logger& logger_;
    
    // Helper methods
    int findNoteSlot(uint8_t channel, uint8_t key) const;
    int findFreeSlot() const;
    void pushToQueue(NoteQueue& queue, uint8_t note);
    uint8_t popFromQueue(NoteQueue& queue);
    
    // Validation helpers
    bool isValidChannel(uint8_t channel) const { return channel < 16; }
    bool isValidKey(uint8_t key) const { return key < 128; }
    bool isValidController(uint8_t controller) const { return controller < 128; }
    
    // Kop칤rov치n칤 zak치z치no
    MidiStateManager(const MidiStateManager&) = delete;
    MidiStateManager& operator=(const MidiStateManager&) = delete;
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    
    // Logov치n칤 vytv치콏en칤 editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytv치콏eni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lep코칤 캜itelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmav캩 코ed칠 pozad칤
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelen칳 text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmav칳 okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tla캜칤tka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vy캜i코t캩n칤 display p콏i vypnut칤
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // P콏id치n칤 tla캜칤tka pro vy캜i코t캩n칤 log콢
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastaven칤 reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Roz코칤콏en치 velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKON캛ENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logov치n칤 p콏ed destrukc칤
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstran캩n칤 reference p콏i destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    // Logov치n칤 pouze p콏i prvn칤m vykreslen칤
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozad칤
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horn칤 sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Odd캩lovac칤 캜치ra
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    // Logov치n칤 zm캩ny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozlo쬰n칤 komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zab칤r치 v캩t코inu m칤sta
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tla캜칤tka ve spodn칤 캜치sti
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    // Z칤sk치n칤 bufferu z Loggeru p콏es getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestaven칤 textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastaven칤 textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledov치n칤 nov칳ch ud치lost칤
    logDisplay->moveCaretToEnd();
    
    // Jednoduch칳 scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logov치n칤 a ovl치d치n칤
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       ),
       synthState_(SynthState::Uninitialized),
       currentSampleRate_(0.0),
       processBlockCount_(0),
       totalMidiEvents_(0)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== APLIKACE SPUSTENA ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Inicializace procesoru");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Plugin nazev: " + getName());
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Je synthesizer: " + juce::String(JucePlugin_IsSynth ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Prijima MIDI: " + juce::String(acceptsMidi() ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Produkuje MIDI: " + juce::String(producesMidi() ? "ANO" : "NE"));
    
    // Komponenty se vytvo콏칤 a v prepareToPlay kdy zn치me sample rate
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", 
                              "Stav: " + getStateDescription());
}

AudioPluginAudioProcessor::~AudioPluginAudioProcessor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== APLIKACE SE UKONCUJE ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Zahajeni destrukce procesoru");
    
    cleanupSynth();
    Logger::getInstance().setEditor(nullptr);
    
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== DESTRUKCE DOKONCENA ===");
}

//==============================================================================
// Inicializuje synth komponenty s danou sample rate.
// Vr치t칤 true p콏i 칰sp캩chu, jinak false.
bool AudioPluginAudioProcessor::initializeSynth(double sampleRate)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "=== INICIALIZACE SYNTH KOMPONENT ===");
    
    // Nastaven칤 stavu na Initializing
    synthState_.store(SynthState::Initializing);
    
    try {
        // Vytvo콏en칤 komponent v spr치vn칠m po콏ad칤
        sampleLibrary_ = std::make_unique<SampleLibrary>();
        sampleLibrary_->initialize(sampleRate);
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "SampleLibrary inicializovana");
        
        midiStateManager_ = std::make_unique<MidiStateManager>();
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "MidiStateManager inicializovan");
        
        // VoiceManager nyn칤 vy쬬duje referenci na SampleLibrary p콏i konstrukci
        voiceManager_ = std::make_unique<VoiceManager>(*sampleLibrary_, 16);
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", "VoiceManager inicializovan (16 hlasu)");
        
        currentSampleRate_ = sampleRate;
        
        // Atomick칠 nastaven칤 stavu na Ready
        synthState_.store(SynthState::Ready);
        
        Logger::getInstance().log("AudioPluginAudioProcessor/initializeSynth", "info", 
                                  "=== SYNTH INICIALIZACE DOKONCENA === Stav: " + getStateDescription());
        return true;
        
    } catch (const std::exception& e) {
        handleSynthError("Chyba pri inicializaci: " + std::string(e.what()));
        return false;
    } catch (...) {
        handleSynthError("Neznama chyba pri inicializaci synth komponent");
        return false;
    }
}

// Uvoln칤 synth komponenty v opa캜n칠m po콏ad칤 ne byly vytvo콏eny.
void AudioPluginAudioProcessor::cleanupSynth()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/cleanupSynth", "info", "Uvolnovani synth komponent");
    
    // Uvoln캩n칤 v opa캜n칠m po콏ad칤 ne vytvo콏en칤
    voiceManager_.reset();
    midiStateManager_.reset();
    sampleLibrary_.reset();
    
    synthState_.store(SynthState::Uninitialized);
    Logger::getInstance().log("AudioPluginAudioProcessor/cleanupSynth", "info", "Synth komponenty uvolneny");
}

// Zpracuje chybu p콏i inicializaci synth komponent.
void AudioPluginAudioProcessor::handleSynthError(const std::string& errorMessage)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/handleSynthError", "error", 
                              "SYNTH ERROR: " + juce::String(errorMessage));
    
    // Cleanup p콏i chyb캩
    cleanupSynth();
    synthState_.store(SynthState::Error);
    
    Logger::getInstance().log("AudioPluginAudioProcessor/handleSynthError", "error", 
                              "Stav nastaven na ERROR, komponenty uvolneny");
}

// Vr치t칤 textov칳 popis aktu치ln칤ho stavu synth.
juce::String AudioPluginAudioProcessor::getStateDescription() const
{
    switch (synthState_.load()) {
        case SynthState::Uninitialized: return "Neinicializovano";
        case SynthState::Initializing: return "Inicializuje se";
        case SynthState::Ready: return "Pripraveno";
        case SynthState::Error: return "Chyba";
        default: return "Neznamy stav";
    }
}

//==============================================================================
const juce::String AudioPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool AudioPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

double AudioPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int AudioPluginAudioProcessor::getNumPrograms()
{
    return 1;
}

int AudioPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void AudioPluginAudioProcessor::setCurrentProgram (int index)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setCurrentProgram", "info", "Zmena programu na index: " + juce::String(index));
    juce::ignoreUnused (index);
}

const juce::String AudioPluginAudioProcessor::getProgramName (int index)
{
    juce::ignoreUnused (index);
    return {};
}

void AudioPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/changeProgramName", "info", "Zmena nazvu programu [" + juce::String(index) + "]: " + newName);
    juce::ignoreUnused (index, newName);
}

//==============================================================================
void AudioPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== PRIPRAVA AUDIO PROCESINGU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Sample rate: " + juce::String(sampleRate, 1) + " Hz");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Buffer size: " + juce::String(samplesPerBlock) + " samples");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vstupni kanaly: " + juce::String(getTotalNumInputChannels()));
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vystupni kanaly: " + juce::String(getTotalNumOutputChannels()));
    
    // V칳po캜et latence
    double latencyMs = (double)samplesPerBlock / sampleRate * 1000.0;
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Odhadovana latence: " + juce::String(latencyMs, 2) + " ms");
    
    // OPRAVA: Exception-safe inicializace nebo reinicializace synth komponent
    if (synthState_.load() != SynthState::Ready || currentSampleRate_ != sampleRate) {
        if (synthState_.load() != SynthState::Uninitialized) {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Reinicializace kvuli zmene sample rate");
            cleanupSynth();
        }
        
        if (!initializeSynth(sampleRate)) {
            Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "error", 
                                      "KRITICKA CHYBA: Inicializace synth selhala!");
            return; // Plugin z콢stane v error stavu
        }
    }
    
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", 
                              "=== AUDIO PROCESSING PRIPRAVEN === Stav: " + getStateDescription());
}

void AudioPluginAudioProcessor::releaseResources()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "=== UVOLNOVANI AUDIO ZDROJU ===");
    
    // Resetov치n칤 캜칤ta캜콢
    processBlockCount_ = 0;
    totalMidiEvents_ = 0;
    
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "Audio processing zastaven");
}

//==============================================================================
bool AudioPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    auto mainOutput = layouts.getMainOutputChannelSet();
    auto mainInput = layouts.getMainInputChannelSet();
    
    Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "debug", 
        "Kontrola layoutu - Input: " + mainInput.getDescription() + 
        ", Output: " + mainOutput.getDescription());
    
    if (mainOutput != juce::AudioChannelSet::mono() && mainOutput != juce::AudioChannelSet::stereo())
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Nepodporovany output layout: " + mainOutput.getDescription());
        return false;
    }

   #if ! JucePlugin_IsSynth
    if (mainOutput != mainInput)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Input a output layout se neshoduji");
        return false;
    }
   #endif

    return true;
  #endif
}

//==============================================================================
void AudioPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    
    // Explicitn칤 kontrola stavu s informativn칤m logov치n칤m
    auto currentState = synthState_.load();
    if (currentState != SynthState::Ready) {
        // Vyma쬰me buffer a logujeme d콢vod
        buffer.clear();
        
        static int errorLogCount = 0;
        if (errorLogCount < 5) { // Omez칤me spam v logu
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "warn", 
                                      "Audio block preskocen - stav: " + getStateDescription());
            errorLogCount++;
        }
        return;
    }
    
    // Po캜칤tadlo pro optimalizaci logov치n칤
    processBlockCount_++;
    
    // Detailn칤 logov치n칤 prvn칤ch blok콢
    if (processBlockCount_ <= 3) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Audio blok #" + juce::String(processBlockCount_) + " - velikost: " + juce::String(buffer.getNumSamples()) + 
            " samples, kanaly: " + juce::String(buffer.getNumChannels()));
    } else if (processBlockCount_ % 1000 == 0) {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "debug", 
            "Zpracovano " + juce::String(processBlockCount_) + " audio bloku, celkem MIDI: " + juce::String(totalMidiEvents_));
    }
    
    // MIDI EVENT PROCESSING
    if (!midiMessages.isEmpty()) {
        int midiEventsInBlock = 0;
        
        // Po캜칤t치n칤 MIDI ud치lost칤 pro logov치n칤
        for (const auto& midiMetadata : midiMessages) {
            midiEventsInBlock++;
            totalMidiEvents_++;
        }
        
        if (midiEventsInBlock > 0) {
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
                "MIDI udalosti v bloku: " + juce::String(midiEventsInBlock) + 
                " (celkem: " + juce::String(totalMidiEvents_) + ")");
        }
        
        // Zpracov치n칤 MIDI ud치lost칤 p콏es MidiStateManager
        midiStateManager_->processMidiBuffer(midiMessages);
    }
    
    // VOICE MANAGEMENT - zpracov치n칤 MIDI ud치lost칤 do hlas콢
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // AUDIO GENERATION
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();
    
    // Vy캜i코t캩n칤 p콏ebyte캜n칳ch v칳stupn칤ch kan치l콢
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i) {
        buffer.clear(i, 0, buffer.getNumSamples());
    }
    
    // Generov치n칤 audio pro ka쬯칳 v칳stupn칤 kan치l
    for (int channel = 0; channel < totalNumOutputChannels; ++channel) {
        auto* channelData = buffer.getWritePointer(channel);
        
        // Vymaz치n칤 bufferu p콏ed generov치n칤m
        std::fill(channelData, channelData + buffer.getNumSamples(), 0.0f);
        
        // Generov치n칤 audio ze v코ech hlas콢
        // Odstran캩n t콏et칤 parametr (*sampleLibrary_), proto쬰 VoiceManager dr쮂 intern칤 referenci
        voiceManager_->generateAudio(channelData, buffer.getNumSamples());
    }
    
    // Voice management refresh (cleanup neaktivn칤ch hlas콢)
    voiceManager_->refresh();
    
    // Anal칳za v칳stupn칤 amplitudy pro prvn칤 bloky
    if (processBlockCount_ <= 3 && buffer.getNumChannels() > 0) {
        float maxAmplitude = 0.0f;
        for (int channel = 0; channel < buffer.getNumChannels(); ++channel) {
            auto* channelData = buffer.getReadPointer(channel);
            for (int sample = 0; sample < buffer.getNumSamples(); ++sample) {
                maxAmplitude = juce::jmax(maxAmplitude, std::abs(channelData[sample]));
            }
        }
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Maximalni vystupni amplituda: " + juce::String(maxAmplitude, 6));
    }
}

//==============================================================================
bool AudioPluginAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "=== VYTVARENI GUI EDITORU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "Inicializace uzivatelskeho rozhrani");
    return new AudioPluginAudioProcessorEditor (*this);
}

//==============================================================================
void AudioPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/getStateInformation", "info", "Ukladani stavu pluginu");
    juce::ignoreUnused (destData);
}

void AudioPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setStateInformation", "info", 
        "Nacitani stavu pluginu (velikost: " + juce::String(sizeInBytes) + " bytu)");
    juce::ignoreUnused (data, sizeInBytes);
}

//==============================================================================
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioPluginAudioProcessor();
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Logger.h"
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "VoiceManager.h"

//==============================================================================
/**
 * AudioPluginAudioProcessor - hlavn칤 t콏칤da audio pluginu
 * OPRAVA: P콏id치n칤 explicitn칤ch error states pro lep코칤 debugging
 */
class AudioPluginAudioProcessor final : public juce::AudioProcessor
{
public:
    // OPRAVA: Enum pro explicitn칤 stavy synth komponent
    enum class SynthState { 
        Uninitialized, 
        Initializing, 
        Ready, 
        Error 
    };

    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    using AudioProcessor::processBlock;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;
    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    // OPRAVA: Getter pro aktu치ln칤 stav (pro debugging)
    SynthState getCurrentState() const { return synthState_.load(); }
    juce::String getStateDescription() const;

private:
    //==============================================================================
    // OPRAVA: Exception-safe metody pro inicializaci
    bool initializeSynth(double sampleRate);
    void cleanupSynth();
    
    // OPRAVA: Error recovery metoda
    void handleSynthError(const std::string& errorMessage);

    // Synth komponenty - vytv치콏ej칤 se a p콏i prepareToPlay
    std::unique_ptr<SampleLibrary> sampleLibrary_;
    std::unique_ptr<MidiStateManager> midiStateManager_;
    std::unique_ptr<VoiceManager> voiceManager_;
    
    // OPRAVA: Atomic state management pro thread safety
    std::atomic<SynthState> synthState_{SynthState::Uninitialized};
    double currentSampleRate_;
    
    // Debug counters pro optimalizaci logov치n칤
    int processBlockCount_;
    int totalMidiEvents_;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessor)
};


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe


## Nastaven칤 v칳vojov칠ho prost콏ed칤

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) prove캞te n치sleduj칤c칤 kroky. P콏edpokl치d치 se instalace Visual Studio Build Tools (s MSVC kompil치torem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Po쬬davky
- Visual Studio Build Tools (MSVC kompil치tor).
- CMake nainstalovan칳 a p콏id치n do PATH (nap콏. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastaven칤
1. **Instalace roz코칤콏en칤 ve VS Code**:
   - Otev콏ete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a lad캩n칤) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otev콏en칤 projektu**:
   - P콏ejd캩te na File > Open Folder a vyberte slo쬶u s CMakeLists.txt.
3. **V칳b캩r kompil치toru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napi코te "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle pot콏eby (nap콏. x64 pro modern칤 syst칠my).
4. **Konfigurace projektu**:
   - V Command Palette napi코te "CMake: Configure". To vygeneruje build soubory (obvykle ve slo쬮e "build").
5. **Build projektu**:
   - V Command Palette napi코te "CMake: Build" nebo pou쬴jte Shift+Ctrl+B (nyn칤 nab칤dne CMake 칰lohy).
6. **Debugov치n칤 (voliteln캩)**:
   - Nastavte breakpointy a spus콘te "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovan칳 v JUCE frameworku, inspirovan칳 hardwarov칳mi syntez치tory s modul치rn칤 architekturou.

## Architektura Syst칠mu

### P콏ehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
較럭較 SampleLibrary (Pre-computed Audio Storage)
較럭較 MidiStateManager (MIDI Event Processing)  
較럭較 VoiceManager (Voice Allocation & Control)
較덕較 Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**칔캜el:** Spr치va pre-computed audio sampel콢 pro jednotliv칠 MIDI noty

**Kl칤캜ov칠 vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not 칑 12 sekund 칑 sample rate
- **Pre-computed sine waves:** Generov치n칤 p콏i inicializaci m칤sto realtime synt칠zy
- **Memory management:** Per-nota allocation s bezpe캜n칳m uvol켿ov치n칤m
- **Roz코i콏itelnost:** P콏ipraveno pro na캜칤t치n칤 WAV soubor콢

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementa캜n칤 detaily:**
- Ka쬯칳 sample m치 pevnou d칠lku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe p콏칤stup k sample dat콢m

### 2. MidiStateManager
**칔캜el:** Centr치ln칤 spr치va MIDI stavu a ud치lost칤

**Inspirov치no:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracov치n칤
- Queue-based event distribution
- State tracking pro aktivn칤 noty a controllery

**Kl칤캜ov칠 struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Odd캩len칠 queues pro Note On/Off ud치losti
- Per-channel event routing (16 MIDI kan치l콢)
- Pop/push pattern podobn칳 hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**칔캜el:** Polyphonic voice allocation a audio generov치n칤

**Inspirov치no:** Hardware Performer class
- 16 polyphonic hlas콢
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hled치 existuj칤c칤 hlas s touto notou
    // 2. Hled치 neaktivn칤 hlas s nejvy코코칤 queue pozic칤  
    // 3. Krade aktivn칤 hlas s nejvy코코칤 queue pozic칤
}
```

**Queue Management (mixleQueue):**
Algoritmus p콏evzat칳 z HW implementace:
1. Vybran칳 hlas  queue pozice 0
2. Ostatn칤 hlasy  pozice++
3. Komprese queue pozic > p콢vodn칤 pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se p콏ehraje jednou)

### 4. Logger System
**칔캜el:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logov치n칤 z audio vl치kna
- Sliding window buffer (100 zpr치v)
- Kategorizace: info/debug/warn
- GUI integration p콏es MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
較럭較 Create SampleLibrary (dummy sample rate)
較럭較 Create MidiStateManager  
較덕較 Create VoiceManager (16 voices)

prepareToPlay:
較럭較 Reinit SampleLibrary (correct sample rate)
較럭較 Generate sine wave pro Middle C (nota 60)
較덕較 Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celkov치 alokace:** ~292MB pro kompletn칤 library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic p콏i destrukci

### Voice Memory
- **16 SynthVoice objekt콢:** Minim치ln칤 memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporovan칠 MIDI zpr치vy:
- **Note On/Off:** Kompletn칤 support v캜etn캩 Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 a +8191)
- **Control Change:** 128 controllers 칑 16 kan치l콢
- **Channel support:** 16 MIDI kan치l콢

### MIDI Routing:
- **Prototype:** Pouze kan치l 0 aktivn칤
- **Full version:** V코ech 16 kan치l콢 p콏ipraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
較럭較 PluginProcessor.h/cpp
較럭較 PluginEditor.h/cpp

Synth Engine:
較럭較 SampleLibrary.h/cpp
較럭較 MidiStateManager.h/cpp
較럭較 VoiceManager.h/cpp

Utilities:
較덕較 Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro v코ech 128 not
2. **WAV loading:** Implementace na캜칤t치n칤 extern칤ch sampel콢
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** V코e se loguje do GUI
- **MIDI monitoring:** Detailn칤 MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms p콏i 480 samples/48kHz)
- **Polyphony:** 16 hlas콢

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal d칤ky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB p콏i full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - v캩t코inou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - 쮂멳n칠 allokace v audio vl치kn캩
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**D콢vod:** Konzistentn칤 CPU usage, mo쬹ost komplexn칤ch waveforms
**Trade-off:** Vysok치 pam캩콘 vs stabiln칤 performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**D콢vod:** Zachov치n칤 hardware workflow, p콏edv칤dateln칠 chov치n칤
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centr치ln칤 state s queue distribution
**D콢vod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**D콢vod:** Complex debugging po쬬davky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"
#include <cmath>

SampleLibrary::SampleLibrary()
    : logger_(Logger::getInstance())
{
    // nic d치l v konstruktoru - actual allocation happens in initialize()
}

/*
 * initialize
 *  - ulo쮂 sampleRate a vygeneruje v코echno (MIN_NOTE..MAX_NOTE)
 *  - pokud generov치n칤 n캩jak칠 noty sel쬰, loguje a pokra캜uje (nep콏eru코칤 ostatn칤)
 *  - OPRAVA: Odebr치n lock mutexu, proto쬰 inicializace je single-threaded (z prepareToPlay),
 *    co zabra켿uje deadlocku p콏i rekurzivn칤m zamyk치n칤 v generateSampleForNote.
 */
void SampleLibrary::initialize(double sampleRate)
{
    if (sampleRate <= 0.0) {
        logger_.log("SampleLibrary/initialize", "error", "Invalid sampleRate: " + juce::String(sampleRate));
        throw std::invalid_argument("Invalid sampleRate");
    }

    sampleRate_ = sampleRate;
    clear();

    logger_.log("SampleLibrary/initialize", "info",
                "Inicializace sample library se sampleRate=" + juce::String(sampleRate_));

    int success = 0;
    int fail = 0;
    for (uint8_t n = MIN_NOTE; n <= MAX_NOTE; ++n) {
        if (generateSampleForNote(n)) ++success;
        else ++fail;
    }

    logger_.log("SampleLibrary/initialize", "info",
                "Generov치n칤 sampl콢 dokon캜eno. Success: " + juce::String(success) +
                " Fail: " + juce::String(fail));
}


/*
 * clear - vyma쬰 intern칤 data
 */
void SampleLibrary::clear()
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    for (auto& seg : sampleSegments_)
        seg.reset();

    logger_.log("SampleLibrary/clear", "debug", "SampleLibrary cleared");
}

/*
 * generateSampleForNote
 *  - vygeneruje sinusovku d칠lky SAMPLE_SECONDS pro danou notu
 *  - vr치t칤 true pokud usp캩je
 */
bool SampleLibrary::generateSampleForNote(uint8_t note)
{
    // lok치ln칤 kalkulace bez dr쬰n칤 locku po dobu generov치n칤 (aloka캜n캩-intenzivn칤)
    double freq = getFrequencyForNote(note);
    uint32_t sampleLength = static_cast<uint32_t>(sampleRate_ * SAMPLE_SECONDS);

    if (sampleLength < 1) {
        logger_.log("SampleLibrary/generateSampleForNote", "error",
                    "Invalid sample length for note " + juce::String((int)note));
        return false;
    }

    std::unique_ptr<float[]> tmpData;
    try {
        tmpData = std::make_unique<float[]>(sampleLength);
    } catch (const std::bad_alloc&) {
        logger_.log("SampleLibrary/generateSampleForNote", "error",
                    "Allocation failed for note " + juce::String((int)note));
        return false;
    }

    const double twoPi = 2.0 * juce::MathConstants<double>::pi;
    const double phaseInc = twoPi * freq / sampleRate_;

    for (uint32_t i = 0; i < sampleLength; ++i) {
        double phase = phaseInc * static_cast<double>(i);
        // explicit cast -> potla캜칤 warning C4244
        tmpData[i] = SAMPLE_AMPLITUDE * static_cast<float>(std::sin(phase));
    }

    // commit: ulo쬰n칤 do intern칤 struktury pod lockem (atomic-ish)
    {
        std::lock_guard<std::mutex> lock(accessMutex_);
        SampleSegment& seg = sampleSegments_[note];
        seg.sampleData = std::move(tmpData);
        seg.lengthSamples = sampleLength;
        seg.midiNote = note;
        seg.isAllocated = true;
    }

    logger_.log("SampleLibrary/generateSampleForNote", "debug",
                "Vzorek vygenerov치n pro notu " + juce::String((int)note) +
                " freq=" + juce::String(freq, 2) +
                " samples=" + juce::String(sampleLength));
    return true;
}

/*
 * getSampleData / getSampleLength / isNoteAvailable
 *  - vrac칤 read-only data (chr치n캩n칠 mutexem)
 */
const float* SampleLibrary::getSampleData(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated)
        return sampleSegments_[midiNote].sampleData.get();
    return nullptr;
}

uint32_t SampleLibrary::getSampleLength(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    if (midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated)
        return sampleSegments_[midiNote].lengthSamples;
    return 0;
}

bool SampleLibrary::isNoteAvailable(uint8_t midiNote) const
{
    std::lock_guard<std::mutex> lock(accessMutex_);
    return midiNote < sampleSegments_.size() && sampleSegments_[midiNote].isAllocated;
}

double SampleLibrary::getFrequencyForNote(uint8_t midiNote) const
{
    // standardn칤 formule A4=440Hz (MIDI 69)
    return 440.0 * std::pow(2.0, (static_cast<int>(midiNote) - 69) / 12.0);
}


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <memory>
#include <array>
#include "Logger.h"

/*
 * SampleSegment
 *   - vlastn칤 jednoduch칠 칰lo쬴코t캩 pro float vzorek (unique_ptr)
 *   - lengthSamples = d칠lka v samplech
 */
struct SampleSegment
{
    std::unique_ptr<float[]> sampleData;
    uint32_t lengthSamples{0};
    uint8_t midiNote{0};
    bool isAllocated{false};

    void reset()
    {
        sampleData.reset();
        lengthSamples = 0;
        midiNote = 0;
        isAllocated = false;
    }
};

/*
 * SampleLibrary
 * - refaktorizovan치, thread-safe (intern칤 mutex pro mutace)
 * - initialize(sampleRate) p콏iprav칤 (vygeneruje) v코echny vzorky v rozsahu MIN_NOTE..MAX_NOTE
 * - poskytuje read-only p콏칤stup: getSampleData/getSampleLength/isNoteAvailable
 */
class SampleLibrary
{
public:
    SampleLibrary();
    ~SampleLibrary() = default;

    // Inicializace knihovny (nutn칠 zavolat p콏ed pou쬴t칤m)
    // Vygeneruje v코echny vzorky v rozsahu MIN_NOTE..MAX_NOTE (12 sekund ka쬯칳)
    void initialize(double sampleRate);

    // Vy캜ist칤 v코echny vzorky (uvoln칤 pam캩콘)
    void clear();

    // Generuje a ulo쮂 vzorek pro konkr칠tn칤 notu (pou쬴to intern캩 i extern캩)
    // Vrac칤 true pokud generace prob캩hla 칰sp캩코n캩.
    bool generateSampleForNote(uint8_t note);

    // Read-only p콏칤stup
    const float* getSampleData(uint8_t midiNote) const;
    uint32_t getSampleLength(uint8_t midiNote) const;
    bool isNoteAvailable(uint8_t midiNote) const;

    // Konstanty
    static constexpr uint8_t MIN_NOTE = 21;   // A0
    static constexpr uint8_t MAX_NOTE = 108;  // C8
    static constexpr double SAMPLE_SECONDS = 12.0; // d칠lka v sekund치ch

private:
    // intern칤 helper pro frekvenci
    double getFrequencyForNote(uint8_t midiNote) const;

    mutable std::mutex accessMutex_;                // chr치n칤 sampleSegments_
    std::array<SampleSegment, 128> sampleSegments_; // 칰lo쬴코t캩 pro v코echny MIDInoty
    double sampleRate_{44100.0};
    Logger& logger_;
    static constexpr float SAMPLE_AMPLITUDE = 0.25f; // bezpe캜n치 amplitude
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"
#include "Logger.h"

SynthVoice::SynthVoice()
    : logger_(Logger::getInstance())
{
    reset();
}

void SynthVoice::start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library)
{
    reset();

    midiNote_ = midiNote;
    velocity_ = velocity;

    if (!library.isNoteAvailable(midiNote)) {
        logger_.log("SynthVoice/start", "error", "Requested note not available: " + juce::String((int)midiNote));
        isActive_ = false;
        return;
    }

    sampleData_ = library.getSampleData(midiNote);
    sampleLength_ = library.getSampleLength(midiNote);

    if (!sampleData_ || sampleLength_ == 0) {
        logger_.log("SynthVoice/start", "error", "Invalid sample for note " + juce::String((int)midiNote));
        isActive_ = false;
        return;
    }

    position_ = 0;
    isActive_ = true;

    logger_.log("SynthVoice/start", "debug", "Started note " + juce::String((int)midiNote) +
                                             " len=" + juce::String(sampleLength_));
}

void SynthVoice::stop()
{
    isActive_ = false;
}

void SynthVoice::reset()
{
    midiNote_ = 0;
    velocity_ = 0;
    isActive_ = false;
    sampleData_ = nullptr;
    sampleLength_ = 0;
    position_ = 0;
}

void SynthVoice::render(float* outputBuffer, int numSamples)
{
    if (!isActive_ || sampleData_ == nullptr || sampleLength_ == 0)
        return;

    // jednoduch칳 line치rn칤 gain podle velocity
    const float gain = static_cast<float>(velocity_) / 127.0f;

    for (int i = 0; i < numSamples; ++i) {
        if (position_ >= sampleLength_) {
            // dohr치no -> disable
            stop();
            break;
        }
        outputBuffer[i] += sampleData_[position_] * gain;
        ++position_;
    }
}

// ======================== VoiceManager =========================

VoiceManager::VoiceManager(const SampleLibrary& library, int numVoices)
    : logger_(Logger::getInstance()), sampleLibrary_(library)
{
    voices_.reserve(numVoices);
    for (int i = 0; i < numVoices; ++i)
        voices_.emplace_back(std::make_unique<SynthVoice>());

    logger_.log("VoiceManager/constructor", "info", "VoiceManager created with " + juce::String(numVoices) + " voices");
}

void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // NOTE ON
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            int raw = midiState.popNoteOn(ch);
            if (raw == 0xff) break;
            uint8_t note = static_cast<uint8_t>(raw);
            uint8_t vel = static_cast<uint8_t>(midiState.getVelocity(ch, note));
            startVoice(note, vel);
        }
    }

    // NOTE OFF
    for (int ch = 0; ch < 16; ++ch) {
        while (true) {
            int raw = midiState.popNoteOff(ch);
            if (raw == 0xff) break;
            uint8_t note = static_cast<uint8_t>(raw);
            stopVoice(note);
        }
    }
}

void VoiceManager::generateAudio(float* buffer, int numSamples)
{
    if (buffer == nullptr || numSamples <= 0) return;

    // mix v코ech aktivn칤ch hlas콢
    for (auto& v : voices_) {
        if (v->isActive()) v->render(buffer, numSamples);
    }
}

void VoiceManager::refresh()
{
    // m콢쬰 b칳t roz코칤콏eno o statistiky / voice stealing atd.
}

void VoiceManager::startVoice(uint8_t midiNote, uint8_t velocity)
{
    // hledejte voln칳 hlas
    for (auto& v : voices_) {
        if (!v->isActive()) {
            v->start(midiNote, velocity, sampleLibrary_);
            return;
        }
    }

    // voice stealing: recyklovat nejstar코칤 (zjednodu코eno: index 0)
    if (!voices_.empty()) {
        voices_[0]->start(midiNote, velocity, sampleLibrary_);
        logger_.log("VoiceManager/startVoice", "warn", "Voice stealing: recycled voice 0 for note " + juce::String((int)midiNote));
    }
}

void VoiceManager::stopVoice(uint8_t midiNote)
{
    for (auto& v : voices_) {
        if (v->isActive() && v->getNote() == midiNote) {
            v->stop();
            return;
        }
    }
}


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <cstdint>
#include <memory>
#include <vector>
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "Logger.h"

/*
 * SynthVoice: jednoduch칳, real-time-friendly renderer,
 * dr쮂 pointer na readonly data (ne vlastn칤) a pozici.
 */
class SynthVoice
{
public:
    SynthVoice();

    // start: nastaven칤 noty/velocity a ukazatele na data
    void start(uint8_t midiNote, uint8_t velocity, const SampleLibrary& library);

    // stop: okam쬴t캩 p콏estane b칳t aktivn칤 (m콢쬰 b칳t zm캩n캩no na release-phase)
    void stop();

    // reset: kompletn칤 n치vrat do default stavu
    void reset();

    // render: zap칤코e numSamples do bufferu (p콏i캜칤t치)
    void render(float* outputBuffer, int numSamples);

    bool isActive() const { return isActive_; }
    uint8_t getNote() const { return midiNote_; }

private:
    Logger& logger_;

    uint8_t midiNote_{0};
    uint8_t velocity_{0};
    bool isActive_{false};

    const float* sampleData_{nullptr};
    uint32_t sampleLength_{0};
    uint32_t position_{0};
};

/*
 * VoiceManager: spravuje vector hlas콢, nutn캩 je konstruov치n s referenc칤 na SampleLibrary.
 * T칤m garantujeme, 쬰 p콏i konstrukci existuje sample library a nelze zde m칤t nullptr.
 */
class VoiceManager
{
public:
    // Konstruktor vy쬬duje referenci na existuj칤c칤 SampleLibrary (nelze b칳t nullptr).
    VoiceManager(const SampleLibrary& library, int numVoices = 16);

    ~VoiceManager() = default;

    // processMidiEvents 캜te queue z MidiStateManager a spou코t칤/stav칤 hlasy
    void processMidiEvents(MidiStateManager& midiState);

    // generateAudio mixuje audio z jednotliv칳ch hlas콢
    void generateAudio(float* buffer, int numSamples);

    // refresh: housekeeping (m콢쬰 implementovat voice stealing, atd.)
    void refresh();

private:
    Logger& logger_;
    const SampleLibrary& sampleLibrary_; // povinn치 reference
    std::vector<std::unique_ptr<SynthVoice>> voices_;

    void startVoice(uint8_t midiNote, uint8_t velocity);
    void stopVoice(uint8_t midiNote);
};



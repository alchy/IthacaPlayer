===== File: CMakeLists.txt =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\CMakeLists.txt
=====
cmake_minimum_required(VERSION 3.22)

project(ITHACA_PLAYER VERSION 0.0.1)

add_subdirectory(JUCE)

juce_add_plugin(IthacaPlayer
    COMPANY_NAME "Lord Audio"
    IS_SYNTH TRUE
    NEEDS_MIDI_INPUT TRUE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    PLUGIN_MANUFACTURER_CODE Lau0
    PLUGIN_CODE Itca
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "IthacaPlayer")

juce_generate_juce_header(IthacaPlayer)

target_sources(IthacaPlayer
    PRIVATE
        Logger.h
        Logger.cpp
        SampleLibrary.h
        SampleLibrary.cpp
        MidiStateManager.h
        MidiStateManager.cpp
        VoiceManager.h
        VoiceManager.cpp
        PluginEditor.h
        PluginEditor.cpp
        PluginProcessor.h
        PluginProcessor.cpp)

target_compile_definitions(IthacaPlayer
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

target_link_libraries(IthacaPlayer
    PRIVATE
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)


===== File: JUCE-BUILD.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\JUCE-BUILD.md
=====
# https://cmake.org/download/
# https://trirpi.github.io/posts/developing-audio-plugins-with-juce-and-visual-studio-code/


# pridani JUCE
- git submodule add https://github.com/juce-framework/JUCE.git JUCE

cd JUCE
cmake -B build
cmake -B build -DJUCE_BUILD_EXTRAS=ON
cmake --build build --target AudioPluginHost

# Visual Studio Code

Build the Project 
- Terminal > Run Build Task (or press Ctrl+Shift+B)

Run Without Debugging 
- 


===== File: Logger.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.cpp
=====
#include "Logger.h"
#include "PluginEditor.h"

// Inicializace globálního přepínače logování.
bool Logger::loggingEnabled = true;

/**
 * Metoda pro získání instance singletonu.
 */
Logger& Logger::getInstance()
{
    static Logger instance;
    return instance;
}

/**
 * Metoda pro thread-safe logování.
 * Vytváří formátovaný log s timestampem a přidává do bufferu.
 * Aktualizuje GUI přes MessageManager.
 */
void Logger::log(const juce::String& component, const juce::String& severity, const juce::String& message)
{
    if (!loggingEnabled) return;

    // Vytvoření timestampu pro log.
    juce::String timestamp = juce::Time::getCurrentTime().formatted("%Y-%m-%d %H:%M:%S");

    // Formátování logovacího záznamu.
    juce::String logEntry = "[" + timestamp + "] [" + component + "] [" + severity + "]: " + message;

    // Přidání do circular bufferu.
    pushToLogQueue(logEntry);

    // Thread-safe aktualizace GUI přes MessageManager.
    auto currentEditor = editor.load();
    if (currentEditor != nullptr)
    {
        juce::MessageManager::callAsync([this, currentEditor]() {
            // Dvojitá kontrola pro bezpečnost po async volání.
            if (editor.load() == currentEditor && currentEditor != nullptr)
            {
                currentEditor->updateLogDisplay();
            }
        });
    }
}

/**
 * Metoda pro thread-safe nastavení reference na editor.
 */
void Logger::setEditor(AudioPluginAudioProcessorEditor* ed)
{
    editor.store(ed);
}

/**
 * Pomocná metoda pro přidání logu do circular bufferu.
 * Pokud buffer překročí MAX_LOG_ENTRIES, přepíše nejstarší položku (sliding window).
 */
void Logger::pushToLogQueue(const juce::String& logEntry)
{
    logQueue.logs[logQueue.writeIndex] = logEntry;
    logQueue.writeIndex++;  // uint8 overflow automaticky wrap-around na 0 po 255
    if (logQueue.count < 256) {
        logQueue.count++;
    } else {
        // Sliding window: Pokud plný, posun readIndex (přepis nejstaršího).
        logQueue.readIndex++;
    }
    
    // Omezení na MAX_LOG_ENTRIES (pokud je menší než 256, ručně ořezat).
    if (logQueue.count > MAX_LOG_ENTRIES) {
        logQueue.readIndex = (logQueue.readIndex + (logQueue.count - MAX_LOG_ENTRIES)) % 256;
        logQueue.count = MAX_LOG_ENTRIES;
    }
}

/**
 * Pomocná metoda pro získání aktuálních logů jako StringArray.
 * Používá se pro přístup k bufferu z GUI.
 */
juce::StringArray Logger::getCurrentLogs() const
{
    juce::StringArray result;
    uint8_t index = logQueue.readIndex;
    for (uint8_t i = 0; i < logQueue.count; ++i) {
        result.add(logQueue.logs[index]);
        index++;  // uint8 wrap-around automaticky
    }
    return result;
}

/**
 * Metoda pro získání aktuálních logů jako StringArray.
 */
juce::StringArray Logger::getLogBuffer() const
{
    return getCurrentLogs();
}


===== File: Logger.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\Logger.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_events/juce_events.h>
#include <atomic>

// Definice maximálního počtu logovacích záznamů (sliding window)
#define MAX_LOG_ENTRIES 100

// Forward declaration pro AudioPluginAudioProcessorEditor
class AudioPluginAudioProcessorEditor;

/**
 * Logger - třída pro thread-safe logování událostí v pluginu (singleton).
 * Ukládá logy do circular bufferu s omezenou velikostí.
 * Logování lze globálně zapnout/vypnout.
 * Používá MessageManager pro bezpečnou aktualizaci GUI.
 */
class Logger
{
public:
    // Metoda pro získání instance singletonu.
    static Logger& getInstance();

    // Metoda pro thread-safe logování s timestampem, komponentou, severity a zprávou.
    void log(const juce::String& component, const juce::String& severity, const juce::String& message);

    // Globální přepínač pro zapnutí/vypnutí logování.
    static bool loggingEnabled;

    // Metoda pro thread-safe nastavení reference na editor (pro GUI update).
    void setEditor(AudioPluginAudioProcessorEditor* ed);

    // Metoda pro získání aktuálních logů jako StringArray.
    juce::StringArray getLogBuffer() const;

private:
    // Privátní konstruktor pro singleton pattern.
    Logger() = default;

    // Zabránění kopírování instance.
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    // Struktura pro circular buffer logů (velikost 256 pro uint8 wrap-around).
    struct LogQueue {
        juce::String logs[256];     // Fixed array pro logovací zprávy
        uint8_t readIndex;          // Index pro čtení (uint8 pro automatický wrap-around)
        uint8_t writeIndex;         // Index pro zápis (uint8 pro automatický wrap-around)
        uint8_t count;              // Počet položek v bufferu
        
        LogQueue() : readIndex(0), writeIndex(0), count(0) {}
    };
    
    LogQueue logQueue;  // Circular buffer pro logy

    // Reference na editor pro thread-safe GUI update.
    std::atomic<AudioPluginAudioProcessorEditor*> editor{nullptr};
    
    // Pomocná metoda pro přidání logu do circular bufferu s omezením velikosti.
    void pushToLogQueue(const juce::String& logEntry);
    
    // Pomocná metoda pro získání aktuálních logů jako StringArray (pro GUI).
    juce::StringArray getCurrentLogs() const;
};


===== File: MidiStateManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.cpp
=====
#include "MidiStateManager.h"

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

MidiStateManager::MidiStateManager()
    : pitchWheel_(0)
    , logger_(Logger::getInstance())
{
    // Inicializace všech aktivních not na výchozí hodnoty.
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        activeNotes_[i] = ActiveNote();
    }
    
    // Inicializace hodnot MIDI controllerů (výchozí podle MIDI standardu).
    for (int channel = 0; channel < 16; channel++) {
        for (int controller = 0; controller < 128; controller++) {
            controllerValues_[channel][controller] = 0;
        }
        // Výchozí hodnoty pro vybrané controllery.
        controllerValues_[channel][7] = 100;  // Volume
        controllerValues_[channel][10] = 64;  // Pan (center)
        controllerValues_[channel][64] = 0;   // Sustain pedal (off)
    }
    
    logger_.log("MidiStateManager/constructor", "info", "MidiStateManager inicializovan");
    logger_.log("MidiStateManager/constructor", "info", "Max aktivnich not: " + juce::String(MAX_ACTIVE_NOTES));
}

void MidiStateManager::putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity)
{
    if (channel >= 16 || key >= 128) {
        logger_.log("MidiStateManager/putNoteOn", "warn", "Neplatny channel nebo key: ch=" + 
                    juce::String(channel) + " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOn", "info", "Note ON - Ch:" + juce::String(channel) + 
                " Key:" + juce::String(key) + " Vel:" + juce::String(velocity));
    
    // Vyhledání existujícího slotu nebo volného slotu pro notu.
    int slot = findNoteSlot(channel, key);
    if (slot == -1) {
        slot = findFreeSlot();
    }
    
    if (slot != -1) {
        activeNotes_[slot].channel = channel;
        activeNotes_[slot].key = key;
        activeNotes_[slot].velocity = velocity;
        activeNotes_[slot].isActive = true;
        activeNotes_[slot].triggerTime = juce::Time::getMillisecondCounter();
        
        // Přidání do fronty note-on pro channel.
        pushToQueue(noteOnQueue_[channel], key);
    } else {
        logger_.log("MidiStateManager/putNoteOn", "warn", "Zadny volny slot pro novou notu");
    }
}

void MidiStateManager::putNoteOff(uint8_t channel, uint8_t key)
{
    if (channel >= 16 || key >= 128) {
        logger_.log("MidiStateManager/putNoteOff", "warn", "Neplatny channel nebo key: ch=" + 
                    juce::String(channel) + " key=" + juce::String(key));
        return;
    }
    
    logger_.log("MidiStateManager/putNoteOff", "info", "Note OFF - Ch:" + juce::String(channel) + 
                " Key:" + juce::String(key));
    
    // Vyhledání slotu a označení noty jako neaktivní.
    int slot = findNoteSlot(channel, key);
    if (slot != -1) {
        activeNotes_[slot].isActive = false;
        
        // Přidání do fronty note-off pro channel.
        pushToQueue(noteOffQueue_[channel], key);
    }
}

uint8_t MidiStateManager::popNoteOn(uint8_t channel)
{
    if (channel >= 16) {
        return 0xff;
    }
    
    return popFromQueue(noteOnQueue_[channel]);
}

uint8_t MidiStateManager::popNoteOff(uint8_t channel)
{
    if (channel >= 16) {
        return 0xff;
    }
    
    return popFromQueue(noteOffQueue_[channel]);
}

uint8_t MidiStateManager::getVelocity(uint8_t channel, uint8_t key) const
{
    int slot = findNoteSlot(channel, key);
    if (slot != -1 && activeNotes_[slot].isActive) {
        return activeNotes_[slot].velocity;
    }
    
    return 0; // Výchozí velocity, pokud nota není aktivní
}

void MidiStateManager::setPitchWheel(int16_t pitchWheelValue)
{
    pitchWheel_ = pitchWheelValue;
    logger_.log("MidiStateManager/setPitchWheel", "debug", "Pitch wheel: " + juce::String(pitchWheelValue));
}

void MidiStateManager::setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
{
    if (channel >= 16 || controller >= 128) {
        logger_.log("MidiStateManager/setControllerValue", "warn", "Neplatny channel nebo controller: ch=" + 
                    juce::String(channel) + " cc=" + juce::String(controller));
        return;
    }
    
    controllerValues_[channel][controller] = value;
    
    // Logování pouze pro vybrané controllery.
    if (controller == 1 || controller == 7 || controller == 10 || controller == 64) {
        juce::String ccName = "CC" + juce::String(controller);
        if (controller == 1) ccName = "Modulation";
        else if (controller == 7) ccName = "Volume";
        else if (controller == 10) ccName = "Pan";
        else if (controller == 64) ccName = "Sustain";
        
        logger_.log("MidiStateManager/setControllerValue", "info", 
                    ccName + " Ch:" + juce::String(channel) + " Val:" + juce::String(value));
    }
}

uint8_t MidiStateManager::getControllerValue(uint8_t channel, uint8_t controller) const
{
    if (channel >= 16 || controller >= 128) {
        return 0;
    }
    
    return controllerValues_[channel][controller];
}

void MidiStateManager::processMidiBuffer(const juce::MidiBuffer& midiBuffer)
{
    for (const auto& midiMetadata : midiBuffer) {
        auto message = midiMetadata.getMessage();
        
        if (message.isNoteOn()) {
            // MIDI Note On s velocity 0 se považuje za Note Off.
            if (message.getVelocity() == 0) {
                putNoteOff(message.getChannel() - 1, message.getNoteNumber());
            } else {
                putNoteOn(message.getChannel() - 1, message.getNoteNumber(), message.getVelocity());
            }
        }
        else if (message.isNoteOff()) {
            putNoteOff(message.getChannel() - 1, message.getNoteNumber());
        }
        else if (message.isPitchWheel()) {
            // Převod z JUCE rozsahu (0-16383) na signed int16 (-8192 až +8191).
            int pitchWheelValue = message.getPitchWheelValue() - 8192;
            setPitchWheel(pitchWheelValue);
        }
        else if (message.isController()) {
            setControllerValue(message.getChannel() - 1, message.getControllerNumber(), message.getControllerValue());
        }
    }
}

void MidiStateManager::logActiveNotes() const
{
    int activeCount = 0;
    juce::String noteList;
    
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].isActive) {
            activeCount++;
            if (noteList.isNotEmpty()) noteList += ", ";
            noteList += juce::String(activeNotes_[i].key);
        }
    }
    
    logger_.log("MidiStateManager/logActiveNotes", "debug", 
                "Aktivnich not: " + juce::String(activeCount) + " [" + noteList + "]");
}

int MidiStateManager::getActiveNoteCount() const
{
    int count = 0;
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].isActive) {
            count++;
        }
    }
    return count;
}

int MidiStateManager::findNoteSlot(uint8_t channel, uint8_t key) const
{
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (activeNotes_[i].channel == channel && activeNotes_[i].key == key) {
            return i;
        }
    }
    return -1; // Slot nenalezen
}

int MidiStateManager::findFreeSlot() const
{
    for (int i = 0; i < MAX_ACTIVE_NOTES; i++) {
        if (!activeNotes_[i].isActive) {
            return i;
        }
    }
    return -1; // Žádný volný slot
}

void MidiStateManager::pushToQueue(NoteQueue& queue, uint8_t note)
{
    if (queue.count < 256) {
        queue.notes[queue.writeIndex] = note;
        queue.writeIndex++;  // uint8 overflow automaticky wrap-around na 0 po 255
        queue.count++;
    }
    // Pokud je buffer plný, nová položka se ignoruje (sliding window není potřeba, protože velikost je fixed)
}

uint8_t MidiStateManager::popFromQueue(NoteQueue& queue)
{
    if (queue.count > 0) {
        uint8_t note = queue.notes[queue.readIndex];
        queue.readIndex++;  // uint8 overflow automaticky wrap-around na 0 po 255
        queue.count--;
        return note;
    }
    return 0xff; // Fronta je prázdná
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: MidiStateManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\MidiStateManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include "Logger.h"

/**
 * ActiveNote - struktura reprezentující aktivní MIDI notu.
 * Obsahuje základní atributy pro správu stavu noty.
 */
struct ActiveNote {
    uint8_t key;           // MIDI nota (0-127)
    uint8_t velocity;      // Velocity (0-127)
    uint8_t channel;       // MIDI channel (0-15)
    bool isActive;         // Flag indikující aktivní stav noty
    uint32_t triggerTime;  // Timestamp spuštění noty (pro voice stealing)
    
    ActiveNote() : key(0), velocity(0), channel(0), isActive(false), triggerTime(0) {}
};

/**
 * MidiStateManager - třída pro centrální správu MIDI stavu.
 * Zpracovává MIDI události, ukládá stavy not a controllerů, používá fronty pro události.
 */
class MidiStateManager 
{
public:
    MidiStateManager();
    
    // Metoda pro přidání note-on události do stavu a fronty.
    void putNoteOn(uint8_t channel, uint8_t key, uint8_t velocity);
    
    // Metoda pro přidání note-off události do stavu a fronty.
    void putNoteOff(uint8_t channel, uint8_t key);
    
    // Metoda pro vytažení note-on klávesy z fronty pro daný channel.
    uint8_t popNoteOn(uint8_t channel);   // Vrací key nebo 0xff pokud žádný není
    
    // Metoda pro vytažení note-off klávesy z fronty pro daný channel.
    uint8_t popNoteOff(uint8_t channel);  // Vrací key nebo 0xff pokud žádný není
    
    // Metoda pro získání velocity aktivní noty pro daný channel a key.
    uint8_t getVelocity(uint8_t channel, uint8_t key) const;
    
    // Metoda pro nastavení hodnoty pitch wheel.
    void setPitchWheel(int16_t pitchWheelValue);
    
    // Metoda pro získání aktuální hodnoty pitch wheel.
    int16_t getPitchWheel() const { return pitchWheel_; }
    
    // Metoda pro nastavení hodnoty MIDI controlleru pro daný channel.
    void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value);
    
    // Metoda pro získání hodnoty MIDI controlleru pro daný channel.
    uint8_t getControllerValue(uint8_t channel, uint8_t controller) const;
    
    // Metoda pro logování aktuálně aktivních not.
    void logActiveNotes() const;
    
    // Metoda pro získání počtu aktivních not.
    int getActiveNoteCount() const;
    
    // Hlavní metoda pro zpracování MIDI bufferu z JUCE.
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer);
    
private:
    // Metoda pro vyhledání slotu pro konkrétní notu v poli aktivních not.
    int findNoteSlot(uint8_t channel, uint8_t key) const;
    
    // Metoda pro vyhledání volného slotu v poli aktivních not.
    int findFreeSlot() const;
    
    // Konstanta definující maximální počet aktivních not (fixed velikost).
    static const int MAX_ACTIVE_NOTES = 128;
    ActiveNote activeNotes_[MAX_ACTIVE_NOTES];
    
    // Hodnota pitch wheel (signed pro rozsah -8192 až +8191).
    int16_t pitchWheel_;
    
    // Dvourozměrné pole pro ukládání hodnot MIDI controllerů (channel x controller).
    uint8_t controllerValues_[16][128];  // [channel][controller]
    
    // Struktura pro circular buffer fronty not (velikost 256 pro uint8 wrap-around).
    struct NoteQueue {
        uint8_t notes[256];         // Fixed array pro noty
        uint8_t readIndex;          // Index pro čtení (uint8 pro automatický wrap-around)
        uint8_t writeIndex;         // Index pro zápis (uint8 pro automatický wrap-around)
        uint8_t count;              // Počet položek v bufferu
        
        NoteQueue() : readIndex(0), writeIndex(0), count(0) {
            for (int i = 0; i < 256; i++) notes[i] = 0xff;
        }
    };
    
    NoteQueue noteOnQueue_[16];   // Fronty pro note-on události (jedna pro každý channel)
    NoteQueue noteOffQueue_[16];  // Fronty pro note-off události (jedna pro každý channel)
    
    // Reference na logger pro protokolování událostí.
    Logger& logger_;
    
    // Pomocná metoda pro přidání položky do circular bufferu.
    void pushToQueue(NoteQueue& queue, uint8_t note);
    
    // Pomocná metoda pro vytažení položky z circular bufferu.
    uint8_t popFromQueue(NoteQueue& queue);
};


===== File: PluginEditor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Logger.h"

//==============================================================================
AudioPluginAudioProcessorEditor::AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    
    // Logování vytváření editoru
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== INICIALIZACE GUI ===");
    Logger::getInstance().log("PluginEditor/constructor", "info", "Vytvářeni komponenty editoru");
    
    // Inicializace log display (multiline, read-only, se scrollbar)
    logDisplay = std::make_unique<juce::TextEditor>();
    logDisplay->setMultiLine(true);
    logDisplay->setReadOnly(true);
    logDisplay->setScrollbarsShown(true);
    
    // Oprava deprecated Font konstruktoru
    juce::Font monoFont(juce::FontOptions(juce::Font::getDefaultMonospacedFontName(), 11.0f, juce::Font::plain));
    logDisplay->setFont(monoFont);
    
    // Styling pro lepší čitelnost
    logDisplay->setColour(juce::TextEditor::backgroundColourId, juce::Colour(0xff1e1e1e)); // Tmavě šedé pozadí
    logDisplay->setColour(juce::TextEditor::textColourId, juce::Colour(0xff00ff00));        // Zelený text (matrix style)
    logDisplay->setColour(juce::TextEditor::outlineColourId, juce::Colour(0xff404040));     // Tmavý okraj
    
    addAndMakeVisible(logDisplay.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Log display inicializovan s matrix theme");

    // Inicializace toggle tlačítka
    toggleLogging = std::make_unique<juce::ToggleButton>("Zapnout/Vypnout logovani");
    toggleLogging->setToggleState(Logger::loggingEnabled, juce::dontSendNotification);
    toggleLogging->onClick = [this] {
        bool newState = toggleLogging->getToggleState();
        Logger::loggingEnabled = newState;
        Logger::getInstance().log("PluginEditor/toggleButton", "info", 
            "Logovani " + juce::String(newState ? "ZAPNUTO" : "VYPNUTO"));
        if (!Logger::loggingEnabled) {
            logDisplay->clear();  // Vyčištění display při vypnutí
        }
    };
    addAndMakeVisible(toggleLogging.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Toggle button inicializovan");

    // Přidání tlačítka pro vyčištění logů
    clearLogsButton = std::make_unique<juce::TextButton>("Vycistit logy");
    clearLogsButton->onClick = [this] {
        logDisplay->clear();
        Logger::getInstance().log("PluginEditor/clearButton", "info", "=== LOGY VYCISTENY UZIVATELEM ===");
    };
    addAndMakeVisible(clearLogsButton.get());
    
    Logger::getInstance().log("PluginEditor/constructor", "info", "Clear button inicializovan");

    // Nastavení reference na tento editor v Loggeru
    Logger::getInstance().setEditor(this);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Reference na editor nastavena v Loggeru");

    // Rozšířená velikost okna na 800x500
    setSize (1024, 600);
    Logger::getInstance().log("PluginEditor/constructor", "info", "Velikost okna nastavena: 800x500");
    Logger::getInstance().log("PluginEditor/constructor", "info", "=== GUI INICIALIZACE DOKONČENA ===");
}

AudioPluginAudioProcessorEditor::~AudioPluginAudioProcessorEditor()
{
    // Logování před destrukcí
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== UZAVIRANI GUI ===");
    Logger::getInstance().log("PluginEditor/destructor", "info", "Zahajeni destrukce editoru");
    
    // Odstranění reference při destrukci
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("PluginEditor/destructor", "info", "Reference na editor odstranena");
    Logger::getInstance().log("PluginEditor/destructor", "info", "=== GUI UZAVRENO ===");
}

//==============================================================================
void AudioPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    // Logování pouze při prvním vykreslení
    static bool firstPaint = true;
    if (firstPaint)
    {
        Logger::getInstance().log("PluginEditor/paint", "info", "=== PRVNI VYKRESLENI GUI ===");
        Logger::getInstance().log("PluginEditor/paint", "info", "Rozmery canvas: " + 
            juce::String(getWidth()) + "x" + juce::String(getHeight()));
        firstPaint = false;
    }
    
    // Gradient pozadí
    juce::ColourGradient gradient(juce::Colour(0xff2a2a2a), 0, 0,
                                  juce::Colour(0xff1a1a1a), 0, (float)getHeight(), false);
    g.setGradientFill(gradient);
    g.fillAll();

    // Horní sekce - nadpis a info
    g.setColour (juce::Colours::lightblue);
    g.setFont(juce::FontOptions(20.0f, juce::Font::bold));
    g.drawFittedText("IthacaPlayer Debug Interface", 10, 10, getWidth() - 20, 40, juce::Justification::centred, 1);
    
    g.setColour(juce::Colours::lightgrey);
    g.setFont(juce::FontOptions(12.0f));
    g.drawFittedText("Real-time logging a debugging audio pluginu", 10, 50, getWidth() - 20, 20, juce::Justification::centred, 1);
    
    // Oddělovací čára
    g.setColour(juce::Colour(0xff404040));
    g.fillRect(10, 80, getWidth() - 20, 1);
}

void AudioPluginAudioProcessorEditor::resized()
{
    // Logování změny velikosti
    Logger::getInstance().log("PluginEditor/resized", "debug", "Zmena velikosti GUI: " + 
        juce::String(getWidth()) + "x" + juce::String(getHeight()));
    
    // Layout - rozložení komponent
    int margin = 10;
    int buttonHeight = 30;
    int headerHeight = 90;  // Prostor pro nadpis
    
    // Log display zabírá většinu místa
    int logDisplayHeight = getHeight() - headerHeight - buttonHeight * 2 - margin * 4;
    logDisplay->setBounds(margin, headerHeight, getWidth() - 2 * margin, logDisplayHeight);

    // Tlačítka ve spodní části
    int buttonY = headerHeight + logDisplayHeight + margin;
    int buttonWidth = (getWidth() - 3 * margin) / 2;
    
    toggleLogging->setBounds(margin, buttonY, buttonWidth, buttonHeight);
    clearLogsButton->setBounds(margin * 2 + buttonWidth, buttonY, buttonWidth, buttonHeight);
    
    Logger::getInstance().log("PluginEditor/resized", "debug", "Layout komponent aktualizovan - log area: " + 
        juce::String(logDisplay->getWidth()) + "x" + juce::String(logDisplay->getHeight()));
}

/**
 * Aktualizace log display s auto-scroll na konec.
 */
void AudioPluginAudioProcessorEditor::updateLogDisplay()
{
    // Získání bufferu z Loggeru přes getter
    const juce::StringArray& buffer = Logger::getInstance().getLogBuffer();

    // Sestavení textu
    juce::String logText;
    for (const auto& entry : buffer)
    {
        logText += entry + "\n";
    }

    // Nastavení textu
    logDisplay->setText(logText);

    // Auto-scroll na konec pro sledování nových událostí
    logDisplay->moveCaretToEnd();
    
    // Jednoduchý scroll na konec
    logDisplay->scrollEditorToPositionCaret(0, logDisplay->getHeight() - 20);
}


===== File: PluginEditor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginEditor.h
=====
#pragma once

#include "PluginProcessor.h"
#include <juce_gui_basics/juce_gui_basics.h>

//==============================================================================
class AudioPluginAudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit AudioPluginAudioProcessorEditor (AudioPluginAudioProcessor&);
    ~AudioPluginAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

    // Metoda pro aktualizaci log display
    void updateLogDisplay();

private:
    // Reference na procesor
    AudioPluginAudioProcessor& processorRef;

    // Komponenty pro logování a ovládání
    std::unique_ptr<juce::TextEditor> logDisplay;
    std::unique_ptr<juce::ToggleButton> toggleLogging;
    std::unique_ptr<juce::TextButton> clearLogsButton;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessorEditor)
};


===== File: PluginProcessor.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.cpp
=====
#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
AudioPluginAudioProcessor::AudioPluginAudioProcessor()
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       )
{
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "=== APLIKACE SPUSTENA ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Inicializace procesoru");
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Plugin nazev: " + getName());
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Je synthesizer: " + juce::String(JucePlugin_IsSynth ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Prijima MIDI: " + juce::String(acceptsMidi() ? "ANO" : "NE"));
    Logger::getInstance().log("AudioPluginAudioProcessor/constructor", "info", "Produkuje MIDI: " + juce::String(producesMidi() ? "ANO" : "NE"));
}

AudioPluginAudioProcessor::~AudioPluginAudioProcessor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== APLIKACE SE UKONCUJE ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "Zahajeni destrukce procesoru");
    Logger::getInstance().setEditor(nullptr);
    Logger::getInstance().log("AudioPluginAudioProcessor/destructor", "info", "=== DESTRUKCE DOKONCENA ===");
}

const juce::String AudioPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool AudioPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool AudioPluginAudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

double AudioPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int AudioPluginAudioProcessor::getNumPrograms()
{
    return 1;
}

int AudioPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void AudioPluginAudioProcessor::setCurrentProgram (int index)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setCurrentProgram", "info", "Zmena programu na index: " + juce::String(index));
    juce::ignoreUnused (index);
}

const juce::String AudioPluginAudioProcessor::getProgramName (int index)
{
    juce::ignoreUnused (index);
    return {};
}

void AudioPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/changeProgramName", "info", "Zmena nazvu programu [" + juce::String(index) + "]: " + newName);
    juce::ignoreUnused (index, newName);
}

void AudioPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "=== PRIPRAVA AUDIO PROCESINGU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Sample rate: " + juce::String(sampleRate, 1) + " Hz");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Buffer size: " + juce::String(samplesPerBlock) + " samples");
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vstupni kanaly: " + juce::String(getTotalNumInputChannels()));
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Vystupni kanaly: " + juce::String(getTotalNumOutputChannels()));
    
    // Vypocet latence
    double latencyMs = (double)samplesPerBlock / sampleRate * 1000.0;
    Logger::getInstance().log("AudioPluginAudioProcessor/prepareToPlay", "info", "Odhadovana latence: " + juce::String(latencyMs, 2) + " ms");
    
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void AudioPluginAudioProcessor::releaseResources()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "=== UVOLNOVANI AUDIO ZDROJU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/releaseResources", "info", "Audio processing zastaven");
}

bool AudioPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    auto mainOutput = layouts.getMainOutputChannelSet();
    auto mainInput = layouts.getMainInputChannelSet();
    
    Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "debug", 
        "Kontrola layoutu - Input: " + mainInput.getDescription() + 
        ", Output: " + mainOutput.getDescription());
    
    if (mainOutput != juce::AudioChannelSet::mono() && mainOutput != juce::AudioChannelSet::stereo())
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Nepodporovany output layout: " + mainOutput.getDescription());
        return false;
    }

   #if ! JucePlugin_IsSynth
    if (mainOutput != mainInput)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/isBusesLayoutSupported", "warn", 
            "Input a output layout se neshoduji");
        return false;
    }
   #endif

    return true;
  #endif
}

void AudioPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer,
                                              juce::MidiBuffer& midiMessages)
{
    // Pocitadlo pro omezeni logovani
    static int processCount = 0;
    static int totalMidiEvents = 0;
    processCount++;
    
    // Detailni logování prvnich bloku
    if (processCount <= 5)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Audio blok #" + juce::String(processCount) + " - velikost: " + juce::String(buffer.getNumSamples()) + 
            " samples, kanaly: " + juce::String(buffer.getNumChannels()));
            
        // Analyza amplitudy pro prvni bloky
        if (buffer.getNumChannels() > 0)
        {
            float maxAmplitude = 0.0f;
            for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
            {
                auto* channelData = buffer.getReadPointer(channel);
                for (int sample = 0; sample < buffer.getNumSamples(); ++sample)
                {
                    maxAmplitude = juce::jmax(maxAmplitude, std::abs(channelData[sample]));
                }
            }
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
                "Maximalni amplituda v bloku: " + juce::String(maxAmplitude, 6));
        }
    }
    else if (processCount % 1000 == 0)
    {
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "debug", 
            "Zpracovano " + juce::String(processCount) + " audio bloku, celkem MIDI: " + juce::String(totalMidiEvents));
    }
    
    // Detailni MIDI logování
    if (!midiMessages.isEmpty())
    {
        int midiEventsInBlock = 0;
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", "=== MIDI UDALOSTI ===");
        
        for (const auto& midiMetadata : midiMessages)
        {
            auto message = midiMetadata.getMessage();
            int sampleNumber = midiMetadata.samplePosition;
            midiEventsInBlock++;
            totalMidiEvents++;
            
            juce::String midiInfo = "MIDI #" + juce::String(totalMidiEvents) + 
                                   " @ sample " + juce::String(sampleNumber) + ": ";
            
            if (message.isNoteOn())
            {
                midiInfo += "NOTE ON - Note: " + juce::String(message.getNoteNumber()) + 
                           " (" + message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + ")" +
                           ", Velocity: " + juce::String(message.getVelocity()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isNoteOff())
            {
                midiInfo += "NOTE OFF - Note: " + juce::String(message.getNoteNumber()) + 
                           " (" + message.getMidiNoteName(message.getNoteNumber(), true, true, 4) + ")" +
                           ", Velocity: " + juce::String(message.getVelocity()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isController())
            {
                midiInfo += "CC - Controller: " + juce::String(message.getControllerNumber()) +
                           ", Value: " + juce::String(message.getControllerValue()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isPitchWheel())
            {
                midiInfo += "PITCH BEND - Value: " + juce::String(message.getPitchWheelValue()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isProgramChange())
            {
                midiInfo += "PROGRAM CHANGE - Program: " + juce::String(message.getProgramChangeNumber()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isChannelPressure())
            {
                midiInfo += "CHANNEL PRESSURE - Pressure: " + juce::String(message.getChannelPressureValue()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else if (message.isAftertouch())
            {
                midiInfo += "AFTERTOUCH - Note: " + juce::String(message.getNoteNumber()) +
                           ", Pressure: " + juce::String(message.getAfterTouchValue()) +
                           ", Channel: " + juce::String(message.getChannel());
            }
            else
            {
                midiInfo += "OTHER - " + message.getDescription();
            }
            
            Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", midiInfo);
        }
        
        Logger::getInstance().log("AudioPluginAudioProcessor/processBlock", "info", 
            "Celkem MIDI udalosti v bloku: " + juce::String(midiEventsInBlock));
    }

    juce::ScopedNoDenormals noDenormals;
    auto totalNumInputChannels  = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    // Vyčištění přebytečných výstupních kanálů
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // Zde by bylo audio processing - momentálně jen passthrough
    for (int channel = 0; channel < totalNumInputChannels; ++channel)
    {
        auto* channelData = buffer.getWritePointer (channel);
        juce::ignoreUnused (channelData);
        // TODO: Implementovat audio processing
    }
}

bool AudioPluginAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()
{
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "=== VYTVARENI GUI EDITORU ===");
    Logger::getInstance().log("AudioPluginAudioProcessor/createEditor", "info", "Inicializace uzivatelského rozhrani");
    return new AudioPluginAudioProcessorEditor (*this);
}

void AudioPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/getStateInformation", "info", "Ukladani stavu pluginu");
    juce::ignoreUnused (destData);
}

void AudioPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    Logger::getInstance().log("AudioPluginAudioProcessor/setStateInformation", "info", 
        "Nacitani stavu pluginu (velikost: " + juce::String(sizeInBytes) + " bytu)");
    juce::ignoreUnused (data, sizeInBytes);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new AudioPluginAudioProcessor();
}


===== File: PluginProcessor.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\PluginProcessor.h
=====
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Logger.h"
#include "SampleLibrary.h"
#include "MidiStateManager.h"
#include "VoiceManager.h"

//==============================================================================
class AudioPluginAudioProcessor final : public juce::AudioProcessor
{
public:
    //==============================================================================
    AudioPluginAudioProcessor();
    ~AudioPluginAudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    using AudioProcessor::processBlock;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

private:
    // Synth komponenty - komponenty pro správu vzorků, MIDI a hlasů.
    std::unique_ptr<SampleLibrary> sampleLibrary_;
    std::unique_ptr<MidiStateManager> midiStateManager_;
    std::unique_ptr<VoiceManager> voiceManager_;
    
    // State management - flag pro inicializaci syntezátoru.
    bool synthInitialized_;
    
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioPluginAudioProcessor)
};


===== File: README.md =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\README.md
=====
## Cesty na build soubory

[build]   juce_vst3_helper.vcxproj .\build\Debug\juce_vst3_helper.exe
[build]   IthacaPlayer.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\IthacaPlayer_SharedCode.lib
[build]   IthacaPlayer_VST3.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\VST3\IthacaPlayer.vst3\Contents\x86_64-win\IthacaPlayer.vst3
[build]   IthacaPlayer_Standalone.vcxproj -> .\build\IthacaPlayer_artefacts\Debug\Standalone\IthacaPlayer.exe


## Nastavení vývojového prostředí

Pro kompilaci C++ projektu s CMakeLists.txt ve Visual Studio Code (VS Code) proveďte následující kroky. Předpokládá se instalace Visual Studio Build Tools (s MSVC kompilátorem: https://visualstudio.microsoft.com/cs/visual-cpp-build-tools/) a CMake.

### Požadavky
- Visual Studio Build Tools (MSVC kompilátor).
- CMake nainstalovaný a přidán do PATH (např. C:\Program Files\CMake\bin).
- VS Code.

### Kroky nastavení
1. **Instalace rozšíření ve VS Code**:
   - Otevřete Extensions (Ctrl+Shift+X).
   - Nainstalujte: C/C++ (od Microsoftu pro podporu C++ syntaxe, IntelliSense a ladění) a CMake Tools (od Microsoftu pro integraci CMake).
   - Restartujte VS Code.
2. **Otevření projektu**:
   - Přejděte na File > Open Folder a vyberte složku s CMakeLists.txt.
3. **Výběr kompilátoru (kit)**:
   - V Command Palette (Ctrl+Shift+P) napište "CMake: Select a Kit".
   - Vyberte "amd64" (64-bit) nebo ekvivalent podle potřeby (např. x64 pro moderní systémy).
4. **Konfigurace projektu**:
   - V Command Palette napište "CMake: Configure". To vygeneruje build soubory (obvykle ve složce "build").
5. **Build projektu**:
   - V Command Palette napište "CMake: Build" nebo použijte Shift+Ctrl+B (nyní nabídne CMake úlohy).
6. **Debugování (volitelně)**:
   - Nastavte breakpointy a spusťte "CMake: Debug" v Command Palette.

---

# IthacaPlayer - Software Synthesizer

Audio plugin synthesizer implementovaný v JUCE frameworku, inspirovaný hardwarovými syntezátory s modulární architekturou.

## Architektura Systému

### Přehled Komponent

```
AudioPluginAudioProcessor (Main Controller)
├── SampleLibrary (Pre-computed Audio Storage)
├── MidiStateManager (MIDI Event Processing)  
├── VoiceManager (Voice Allocation & Control)
└── Logger (Debug & Monitoring)
```

## Core Komponenty

### 1. SampleLibrary
**Účel:** Správa pre-computed audio sampelů pro jednotlivé MIDI noty

**Klíčové vlastnosti:**
- **Static allocation:** 292MB RAM pro 128 MIDI not × 12 sekund × sample rate
- **Pre-computed sine waves:** Generování při inicializaci místo realtime syntézy
- **Memory management:** Per-nota allocation s bezpečným uvolňováním
- **Rozšiřitelnost:** Připraveno pro načítání WAV souborů

**API:**
```cpp
SampleLibrary(double sampleRate)
bool generateSineWaveForNote(uint8_t midiNote, float frequency)
const float* getSampleData(uint8_t midiNote)
uint32_t getSampleLength(uint8_t midiNote)
bool isNoteAvailable(uint8_t midiNote)
```

**Implementační detaily:**
- Každý sample má pevnou délku 12 sekund
- Amplitude 0.3f pro prevenci clippingu
- Thread-safe přístup k sample datům

### 2. MidiStateManager
**Účel:** Centrální správa MIDI stavu a událostí

**Inspirováno:** Hardware MidiParser + ActiveKeys pattern
- Circular buffer approach pro MIDI zpracování
- Queue-based event distribution
- State tracking pro aktivní noty a controllery

**Klíčové struktury:**
```cpp
struct ActiveNote {
    uint8_t key, velocity, channel;
    bool isActive;
    uint32_t triggerTime; // Pro voice stealing
};
```

**Queue Management:**
- Oddělené queues pro Note On/Off události
- Per-channel event routing (16 MIDI kanálů)
- Pop/push pattern podobný hardware implementaci

**API:**
```cpp
void processMidiBuffer(const juce::MidiBuffer& midiBuffer)
uint8_t popNoteOn(uint8_t channel)   // Returns key nebo 0xff
uint8_t popNoteOff(uint8_t channel)  // Returns key nebo 0xff
void setPitchWheel(int16_t value)
void setControllerValue(uint8_t channel, uint8_t controller, uint8_t value)
```

### 3. VoiceManager
**Účel:** Polyphonic voice allocation a audio generování

**Inspirováno:** Hardware Performer class
- 16 polyphonic hlasů
- Sophisticated voice stealing algorithm
- Queue-based priority system

**Voice Allocation Algorithm:**
```cpp
int getFreeVoice(uint8_t note) {
    // 1. Hledá existující hlas s touto notou
    // 2. Hledá neaktivní hlas s nejvyšší queue pozicí  
    // 3. Krade aktivní hlas s nejvyšší queue pozicí
}
```

**Queue Management (mixleQueue):**
Algoritmus převzatý z HW implementace:
1. Vybraný hlas → queue pozice 0
2. Ostatní hlasy → pozice++
3. Komprese queue pozic > původní pozice

**SynthVoice vlastnosti:**
- Sample position tracking
- Velocity scaling
- Pitch wheel support
- No-loop playback (12s sample se přehraje jednou)

### 4. Logger System
**Účel:** Real-time debugging a monitoring

**Vlastnosti:**
- Thread-safe logování z audio vlákna
- Sliding window buffer (100 zpráv)
- Kategorizace: info/debug/warn
- GUI integration přes MessageManager

**Usage Pattern:**
```cpp
Logger::getInstance().log("Component/method", "severity", "message");
```

## Audio Processing Flow

### Main Processing Loop (processBlock)

```cpp
void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) {
    // 1. MIDI Processing
    midiStateManager_->processMidiBuffer(midiMessages);
    
    // 2. Voice Management  
    voiceManager_->processMidiEvents(*midiStateManager_);
    
    // 3. Audio Generation
    voiceManager_->generateAudio(channelData, numSamples, *sampleLibrary_);
    
    // 4. Refresh Cycle
    voiceManager_->refresh();
}
```

### Initialization Sequence

```
Constructor:
├── Create SampleLibrary (dummy sample rate)
├── Create MidiStateManager  
└── Create VoiceManager (16 voices)

prepareToPlay:
├── Reinit SampleLibrary (correct sample rate)
├── Generate sine wave pro Middle C (nota 60)
└── Mark synthInitialized = true
```

## Memory Management

### Sample Library Storage
- **Celková alokace:** ~292MB pro kompletní library
- **Current prototype:** Pouze 1 nota (Middle C) = ~2.3MB
- **Allocation strategy:** On-demand per nota
- **Deallocation:** Automatic při destrukci

### Voice Memory
- **16 SynthVoice objektů:** Minimální memory footprint  
- **Sample position tracking:** uint32_t per voice
- **State variables:** note, velocity, gate status

## MIDI Implementation

### Podporované MIDI zprávy:
- **Note On/Off:** Kompletní support včetně Note On velocity 0
- **Pitch Wheel:** 14-bit resolution (-8192 až +8191)
- **Control Change:** 128 controllers × 16 kanálů
- **Channel support:** 16 MIDI kanálů

### MIDI Routing:
- **Prototype:** Pouze kanál 0 aktivní
- **Full version:** Všech 16 kanálů připraveno

## Build System

### CMake Configuration:
```cmake
IS_SYNTH TRUE
NEEDS_MIDI_INPUT TRUE  
FORMATS AU VST3 Standalone
```

### Source Files:
```
Core Audio:
├── PluginProcessor.h/cpp
├── PluginEditor.h/cpp

Synth Engine:
├── SampleLibrary.h/cpp
├── MidiStateManager.h/cpp
├── VoiceManager.h/cpp

Utilities:
└── Logger.h/cpp
```

## Development Workflow

### Current Prototype Status:
- **Working:** MIDI input, voice allocation, sine wave playback
- **Limitation:** Pouze Middle C (nota 60) generuje audio
- **Voice count:** 16 polyphonic
- **Sample length:** 12 sekund per nota

### Next Development Steps:
1. **Full note range:** Generate sine waves pro všech 128 not
2. **WAV loading:** Implementace načítání externích sampelů
3. **ADSR envelope:** Note-off handling s envelope
4. **Effects:** Reverb, filter, modulation
5. **Preset system:** Save/load configurations

### Debug Features:
- **Real-time logging:** Vše se loguje do GUI
- **MIDI monitoring:** Detailní MIDI event tracking  
- **Voice status:** Queue positions, active notes
- **Performance:** Audio block processing statistics

## Technical Specifications

### Audio:
- **Sample rates:** 44.1kHz - 192kHz support
- **Bit depth:** 32-bit float processing
- **Latency:** Buffer size dependent (~10ms při 480 samples/48kHz)
- **Polyphony:** 16 hlasů

### MIDI:
- **Input latency:** Sub-millisecond  
- **Jitter:** Minimal díky JUCE MIDI buffering
- **Throughput:** Unlimited MIDI events per block

### Memory:
- **Runtime:** ~292MB při full library
- **Prototype:** ~2.3MB current usage
- **Stack:** Minimal - většinou heap allocation

### Performance:
- **CPU usage:** Low - pre-computed samples
- **Real-time safe:** Ano - žádné allokace v audio vlákně
- **Thread safety:** Logger + MIDI state management

## Architecture Decisions

### Pre-computed vs Real-time:
**Volba:** Pre-computed samples
**Důvod:** Konzistentní CPU usage, možnost komplexních waveforms
**Trade-off:** Vysoká paměť vs stabilní performance

### Voice Stealing Algorithm:
**Volba:** Queue-based priority system  
**Důvod:** Zachování hardware workflow, předvídatelné chování
**Benefit:** Longest-idle voice stealing

### MIDI State Management:
**Volba:** Centrální state s queue distribution
**Důvod:** Thread safety, clean separation of concerns
**Pattern:** Hardware MidiParser + ActiveKeys adaptace

### Logging Strategy:
**Volba:** Comprehensive real-time logging
**Důvod:** Complex debugging požadavky
**Implementation:** Thread-safe async GUI updates


===== File: SampleLibrary.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.cpp
=====
#include "SampleLibrary.h"

/**
 * Konstruktor: Inicializuje proměnné, ale negeneruje vzorky (to probíhá v initialize).
 */
SampleLibrary::SampleLibrary()
    : sampleRate_(0.0), logger_(Logger::getInstance())
{
    // Inicializace segmentů na výchozí hodnoty.
    for (int i = 0; i < 128; ++i) {
        samples[i] = SampleSegment();
        samples[i].midiNote = i;
    }
}

/**
 * Destruktor: Uvolní alokované vzorky.
 */
SampleLibrary::~SampleLibrary()
{
    // Uvolnění alokovaných dat pro každý segment.
    for (int i = 0; i < 128; ++i) {
        if (samples[i].isAllocated) {
            delete[] samples[i].sampleData;
            samples[i].sampleData = nullptr;
            samples[i].isAllocated = false;
        }
    }
}

/**
 * Metoda pro inicializaci s aktuálním sample rate.
 * Volána z prepareToPlay v PluginProcessor.
 */
void SampleLibrary::initialize(double sampleRate)
{
    sampleRate_ = sampleRate;
    generateSamples();
    logger_.log("SampleLibrary/initialize", "info", "Vzorky inicializovany pro sample rate: " + std::to_string(sampleRate_));
}

/**
 * Metoda pro získání vzorku pro danou MIDI notu.
 * Vrací pointer na data a nastavuje délku; nullptr pokud není dostupný.
 */
const float* SampleLibrary::getSampleForNote(uint8_t note, uint32_t& sampleLength) const
{
    // Kontrola platného rozsahu noty.
    if (note >= 128 || !samples[note].isAllocated) {
        sampleLength = 0;
        return nullptr;
    }
    
    // Vrácení pointeru na data a délky.
    sampleLength = samples[note].lengthSamples;
    return samples[note].sampleData;
}

/**
 * Metoda pro získání segmentu vzorku pro danou MIDI notu.
 * Vrací pointer na segment nebo nullptr pokud není dostupný.
 */
const SampleSegment* SampleLibrary::getSampleSegment(uint8_t note) const
{
    // Vrácení segmentu, nebo nullptr pokud není alokován.
    if (note >= 128 || !samples[note].isAllocated) {
        return nullptr;
    }
    return &samples[note];
}

/**
 * Metoda pro generování vzorků pro MIDI noty v rozsahu.
 * Generuje pouze pro klavírní rozsah, ostatní zůstávají prázdné.
 */
void SampleLibrary::generateSamples()
{
    // Generování vzorků pouze pro optimalizovaný rozsah (úspora paměti).
    for (uint8_t note = MIN_NOTE; note <= MAX_NOTE; ++note) {
        double frequency = getFrequencyForNote(note);
        uint32_t sampleLength = static_cast<uint32_t>(sampleRate_ / frequency * 10);  // Délka vzorku (např. 10 period).
        
        // Alokace dat pro vzorek.
        float* data = new float[sampleLength];
        
        // Generování jednoduchého sinusového vzorku.
        const double twoPi = 2.0 * 3.14159;
        const double increment = twoPi * frequency / sampleRate_;
        for (uint32_t i = 0; i < sampleLength; ++i) {
            double phase = increment * static_cast<double>(i);
            data[i] = 0.3f * std::sin(phase);  // Amplituda 0.3 pro nižší hlasitost.
        }
        
        // Nastavení segmentu.
        samples[note].sampleData = data;
        samples[note].lengthSamples = sampleLength;
        samples[note].midiNote = note;
        samples[note].isAllocated = true;
    }
    
    // Logování počtu generovaných vzorků.
    logger_.log("SampleLibrary/generateSamples", "debug", "Generovano " + std::to_string(MAX_NOTE - MIN_NOTE + 1) + " vzorku.");
}

/**
 * Metoda pro výpočet frekvence pro MIDI notu.
 * Založeno na A4 = 440 Hz.
 */
double SampleLibrary::getFrequencyForNote(uint8_t note) const
{
    // Výpočet frekvence podle MIDI noty.
    return 440.0 * std::pow(2.0, (note - 69) / 12.0);
}


===== File: SampleLibrary.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\SampleLibrary.h
=====
#pragma once

#include <vector>
#include <cstdint>
#include <cmath>  // Pro generování sinusovky
#include "Logger.h"

/**
 * SampleSegment - struktura reprezentující segment vzorku pro MIDI notu.
 * Obsahuje pointer na data, délku a flag alokace.
 */
struct SampleSegment {
    float* sampleData;           // Pointer na audio data
    uint32_t lengthSamples;      // Délka v samples
    uint8_t midiNote;            // MIDI nota (0-127)
    bool isAllocated;            // Flag pro alokaci
    
    SampleSegment() : sampleData(nullptr), lengthSamples(0), midiNote(0), isAllocated(false) {}
};

/**
 * SampleLibrary - třída pro správu a generování audio vzorků.
 * Generuje vzorky pro MIDI noty při inicializaci a poskytuje je pro synth voices.
 */
class SampleLibrary
{
public:
    // Konstruktor: Inicializuje proměnné, ale negeneruje vzorky (to probíhá v initialize).
    SampleLibrary();
    
    // Destruktor: Uvolní alokované vzorky.
    ~SampleLibrary();
    
    // Metoda pro inicializaci s aktuálním sample rate (volána z prepareToPlay).
    void initialize(double sampleRate);
    
    // Metoda pro získání vzorku pro danou MIDI notu.
    const float* getSampleForNote(uint8_t note, uint32_t& sampleLength) const;
    
    // Metoda pro získání segmentu vzorku pro danou MIDI notu (vrací nullptr pokud není dostupný).
    const SampleSegment* getSampleSegment(uint8_t note) const;

private:
    // Metoda pro generování vzorků pro MIDI noty v rozsahu.
    void generateSamples();
    
    // Metoda pro výpočet frekvence pro MIDI notu (A4 = 440 Hz).
    double getFrequencyForNote(uint8_t note) const;
    
    // Konstanty pro optimalizaci rozsahu (klavírní rozsah pro alokaci vzorků).
    static const uint8_t MIN_NOTE = 21;  // A0
    static const uint8_t MAX_NOTE = 108; // C8
    
    // Pole pro vzorky (velikost 128 pro MIDI rozsah, ale alokováno jen pro MIN-MAX).
    SampleSegment samples[128];
    
    // Aktuální sample rate (nastaven v initialize).
    double sampleRate_;
    
    // Reference na logger pro protokolování.
    Logger& logger_;
};


===== File: VoiceManager.cpp =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.cpp
=====
#include "VoiceManager.h"

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244) // Conversion warnings pro MIDI values
#endif

/**
 * Konstruktor SynthVoice: Inicializuje hlas s číslem.
 */
SynthVoice::SynthVoice(int voiceNumber)
    : voiceNumber_(voiceNumber), currentNote_(0), velocity_(0), isPlaying_(false),
      queuePosition_(0), samplePosition_(0), pitchWheel_(0),
      logger_(Logger::getInstance())
{
    // Inicializace hlasu.
}

/**
 * Metoda pro spuštění/ zastavení noty.
 */
void SynthVoice::play(bool gate, uint8_t note)
{
    // Nastavení gate a noty pro hraní.
    isPlaying_ = gate;
    currentNote_ = note;
    samplePosition_ = 0;  // Reset pozice vzorku.
}

/**
 * Metoda pro nastavení velocity.
 */
void SynthVoice::setVelocity(uint8_t velocity)
{
    // Nastavení velocity pro hlasitost.
    velocity_ = velocity;
}

/**
 * Metoda pro nastavení pitch wheel.
 */
void SynthVoice::setPitchWheel(int16_t pitchWheel)
{
    // Nastavení pitch wheel pro modifikaci výšky tónu.
    pitchWheel_ = pitchWheel;
}

/**
 * Metoda pro generování audio z vzorku.
 */
void SynthVoice::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    // Získání vzorku pro aktuální notu.
    uint32_t sampleLength;
    const float* sampleData = sampleLibrary.getSampleForNote(currentNote_, sampleLength);
    
    if (!isPlaying_ || sampleData == nullptr) {
        // Žádný výstup pokud není aktivní nebo vzorek chybí.
        return;
    }
    
    // Generování audio: Kopírování vzorku do bufferu (s podporou polyfonie - míchaní v VoiceManager).
    for (int i = 0; i < numSamples; ++i) {
        if (samplePosition_ < sampleLength) {
            outputBuffer[i] += sampleData[samplePosition_] * (velocity_ / 127.0f);  // Aplikování velocity.
            samplePosition_++;
        } else {
            // Loop nebo zastavení na konci vzorku.
            isPlaying_ = false;
            break;
        }
    }
}

/**
 * Metoda pro reset hlasu.
 */
void SynthVoice::reset()
{
    // Reset stavu hlasu.
    isPlaying_ = false;
    samplePosition_ = 0;
}

/**
 * Konstruktor VoiceManager: Inicializuje maximální počet hlasů.
 */
VoiceManager::VoiceManager(int maxVoices)
    : voiceCount_(maxVoices > MAX_VOICES ? MAX_VOICES : maxVoices),
      globalPitchWheel_(0), logger_(Logger::getInstance())
{
    // Inicializace hlasů pro polyfonii.
    for (int i = 0; i < voiceCount_; ++i) {
        voices_[i] = new SynthVoice(i);
    }
}

/**
 * Destruktor VoiceManager: Uvolní hlasy.
 */
VoiceManager::~VoiceManager()
{
    // Uvolnění hlasů.
    for (int i = 0; i < voiceCount_; ++i) {
        delete voices_[i];
    }
}

/**
 * Metoda pro spuštění/ zastavení noty s velocity.
 */
void VoiceManager::play(bool gate, uint8_t note, uint8_t velocity)
{
    // Hledání volného hlasu a přiřazení noty (podpora polyfonie).
    int voice = getFreeVoice(note);
    voices_[voice]->play(gate, note);
    voices_[voice]->setVelocity(velocity);
}

/**
 * Metoda pro nastavení pitch wheel pro všechny hlasy.
 */
void VoiceManager::setPitchWheel(int16_t pitchWheel)
{
    // Nastavení pitch wheel pro všechny hlasy.
    globalPitchWheel_ = pitchWheel;
    for (int i = 0; i < voiceCount_; ++i) {
        voices_[i]->setPitchWheel(pitchWheel);
    }
}

/**
 * Metoda pro generování audio ze všech aktivních hlasů.
 */
void VoiceManager::generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary)
{
    // Míchání audio ze všech aktivních hlasů (polyfonie).
    std::fill(outputBuffer, outputBuffer + numSamples, 0.0f);  // Reset bufferu.
    for (int i = 0; i < voiceCount_; ++i) {
        if (voices_[i]->getGate()) {
            voices_[i]->generateAudio(outputBuffer, numSamples, sampleLibrary);
        }
    }
}

/**
 * Metoda pro refresh stavu hlasů.
 */
void VoiceManager::refresh()
{
    // Refresh stavu všech hlasů.
    for (int i = 0; i < voiceCount_; ++i) {
        voices_[i]->reset();  // Příklad: Reset neaktivních.
    }
}

/**
 * Metoda pro zpracování MIDI událostí z MidiStateManager.
 */
void VoiceManager::processMidiEvents(MidiStateManager& midiState)
{
    // Zpracování MIDI událostí pro polyfonii (více not).
    for (uint8_t channel = 0; channel < 16; ++channel) {
        uint8_t note;
        while ((note = midiState.popNoteOn(channel)) != 0xff) {
            uint8_t velocity = midiState.getVelocity(channel, note);
            play(true, note, velocity);
        }
        while ((note = midiState.popNoteOff(channel)) != 0xff) {
            play(false, note, 0);
        }
    }
    setPitchWheel(midiState.getPitchWheel());
}

/**
 * Metoda pro nalezení volného hlasu pro notu (s voice stealingem).
 */
int VoiceManager::getFreeVoice(uint8_t note)
{
    // Algoritmus pro nalezení volného hlasu nebo voice stealing.
    int voiceCandidate = -1;
    for (int voice = 0; voice < voiceCount_; ++voice) {
        if (voices_[voice]->getNote() == note) {
            return voice;
        }
    }
    for (int voice = 0; voice < voiceCount_; ++voice) {
        if (!voices_[voice]->getGate()) {
            if (voiceCandidate == -1 || voices_[voice]->getQueue() > voices_[voiceCandidate]->getQueue()) {
                voiceCandidate = voice;
            }
        }
    }
    if (voiceCandidate != -1) {
        mixleQueue(voices_[voiceCandidate]->getQueue());
        return voiceCandidate;
    }
    // Voice stealing: Vybrat nejstarší.
    for (int voice = 0; voice < voiceCount_; ++voice) {
        if (voices_[voice]->getQueue() == voiceCount_ - 1) {
            mixleQueue(voices_[voice]->getQueue());
            return voice;
        }
    }
    return 0;  // Fallback.
}

/**
 * Metoda pro reorganizaci queue hlasů.
 */
void VoiceManager::mixleQueue(int queueNumber)
{
    // Reorganizace queue pro voice stealing.
    for (int alpha = 0; alpha < voiceCount_; ++alpha) {
        if (voices_[alpha]->getQueue() == queueNumber) {
            voices_[alpha]->setQueue(0);
        } else {
            voices_[alpha]->setQueue(voices_[alpha]->getQueue() + 1);
        }
    }
    for (int alpha = 0; alpha < voiceCount_; ++alpha) {
        if (voices_[alpha]->getQueue() > queueNumber) {
            voices_[alpha]->setQueue(voices_[alpha]->getQueue() - 1);
        }
    }
    logger_.log("VoiceManager/mixleQueue", "debug", "Queue reorganizovana pro pozici " + juce::String(queueNumber));
}

#ifdef _WIN32
#pragma warning(pop)
#endif


===== File: VoiceManager.h =====
Path: C:\Users\nemej992\Documents\Repos\IthacaPlayer\VoiceManager.h
=====
#pragma once

#include <juce_core/juce_core.h>
#include "MidiStateManager.h"
#include "SampleLibrary.h"
#include "Logger.h"

/**
 * SynthVoice - reprezentuje jeden hlas syntezátoru.
 * Podporuje polyfonii tím, že hraje vzorek pro danou notu.
 */
class SynthVoice 
{
public:
    // Konstruktor: Inicializuje hlas s číslem.
    SynthVoice(int voiceNumber);
    
    // Metoda pro spuštění/ zastavení noty.
    void play(bool gate, uint8_t note);
    
    // Metoda pro nastavení velocity.
    void setVelocity(uint8_t velocity);
    
    // Metoda pro nastavení pitch wheel.
    void setPitchWheel(int16_t pitchWheel);
    
    // Metoda pro získání aktuální noty.
    uint8_t getNote() const { return currentNote_; }
    
    // Metoda pro získání gate stavu.
    bool getGate() const { return isPlaying_; }
    
    // Metoda pro získání/ nastavení queue pozice pro voice stealing.
    uint8_t getQueue() const { return queuePosition_; }
    void setQueue(uint8_t position) { queuePosition_ = position; }
    
    // Metoda pro generování audio z vzorku.
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Metoda pro reset hlasu.
    void reset();

private:
    int voiceNumber_;           // Číslo hlasu.
    uint8_t currentNote_;       // Aktuální nota.
    uint8_t velocity_;          // Velocity noty.
    bool isPlaying_;            // Gate stav (aktivní/ neaktivní).
    uint8_t queuePosition_;     // Pozice v queue pro voice stealing.
    uint32_t samplePosition_;   // Pozice v aktuálním vzorku.
    int16_t pitchWheel_;        // Hodnota pitch wheel.
    
    Logger& logger_;            // Reference na logger.
};

/**
 * VoiceManager - správa hlasů pro polyfonii.
 * Podporuje až 16 hlasů s voice stealingem pro hraní více not.
 */
class VoiceManager 
{
public:
    // Konstruktor: Inicializuje maximální počet hlasů.
    VoiceManager(int maxVoices = 16);
    
    // Destruktor: Uvolní hlasy.
    ~VoiceManager();
    
    // Metoda pro spuštění/ zastavení noty s velocity.
    void play(bool gate, uint8_t note, uint8_t velocity);
    
    // Metoda pro nastavení pitch wheel pro všechny hlasy.
    void setPitchWheel(int16_t pitchWheel);
    
    // Metoda pro generování audio ze všech aktivních hlasů.
    void generateAudio(float* outputBuffer, int numSamples, const SampleLibrary& sampleLibrary);
    
    // Metoda pro refresh stavu hlasů.
    void refresh();
    
    // Metoda pro získání počtu hlasů.
    int getVoiceCount() const { return voiceCount_; }
    
    // Metoda pro zpracování MIDI událostí z MidiStateManager.
    void processMidiEvents(MidiStateManager& midiState);

private:
    // Metoda pro nalezení volného hlasu pro notu (s voice stealingem).
    int getFreeVoice(uint8_t note);
    
    // Metoda pro reorganizaci queue hlasů.
    void mixleQueue(int queueNumber);
    
    // Maximální počet hlasů pro polyfonii.
    static const int MAX_VOICES = 16;
    SynthVoice* voices_[MAX_VOICES];  // Pole hlasů.
    int voiceCount_;                  // Aktuální počet hlasů.
    int16_t globalPitchWheel_;        // Globální pitch wheel.
    
    Logger& logger_;                  // Reference na logger.
    
    // Pomocná metoda pro nastavení počtu hlasů.
    void setVoiceCount(int count) { voiceCount_ = count; }
};


